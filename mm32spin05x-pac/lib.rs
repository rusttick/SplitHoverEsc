# ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] # ! [doc = "Peripheral access API (generated using chiptool v0.1.0 (828b7b8 2025-09-01))"] # [derive (Copy , Clone , Debug , PartialEq , Eq)] # [cfg_attr (feature = "defmt" , derive (defmt :: Format))] pub enum Interrupt { # [doc = "0 - Watchdog interrupt"] WWDG_IWDG = 0 , # [doc = "1 - PVD through EXTI line detection interrupt"] PVD = 1 , # [doc = "2 - Commutation and Input Interrupt"] PWM = 2 , # [doc = "3 - Flash global interrupt"] FLASH = 3 , # [doc = "4 - RCC global interrupt"] RCC = 4 , # [doc = "5 - EXTI Line0_1 interrupt"] EXTI0_1 = 5 , # [doc = "6 - EXTI Line2_3 interrupt"] EXTI2_3 = 6 , # [doc = "7 - EXTI Line4_15 interrupt"] EXTI4_15 = 7 , # [doc = "8 - HWDIV global interrupt"] HWDIV = 8 , # [doc = "9 - DMA1 Channel1 global interrupt"] DMA1_CHANNEL1 = 9 , # [doc = "10 - DMA1 Channel2_3 global interrupt"] DMA1_CHANNEL2_3 = 10 , # [doc = "11 - DMA1 Channel4_5 global interrupt"] DMA1_CHANNEL4_5 = 11 , # [doc = "12 - ADC and COMP global interrupt"] ADC_COMP = 12 , # [doc = "13 - TIM1 break,Update,Trigger and Commutation interrupt"] TIM1_BRK_UP_TRG_COM = 13 , # [doc = "14 - TIM1 Capture Compare interrupt"] TIM1_CC = 14 , # [doc = "15 - TIM2 global interrupt"] TIM2 = 15 , # [doc = "16 - TIM3 global interrupt"] TIM3 = 16 , # [doc = "19 - TIM14 global interrupt"] TIM14 = 19 , # [doc = "21 - TIM16 global interrupt"] TIM16 = 21 , # [doc = "22 - TIM17 global interrupt"] TIM17 = 22 , # [doc = "23 - I2C1 interrupt"] I2C1 = 23 , # [doc = "25 - SPI1 global interrupt"] SPI1 = 25 , # [doc = "26 - SPI2 global interrupt"] SPI2 = 26 , # [doc = "27 - UART1 global interrupt"] UART1 = 27 , # [doc = "28 - UART2 global interrupt"] UART2 = 28 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt { # [inline (always)] fn number (self) -> u16 { self as u16 } } # [cfg (feature = "rt")] mod _vectors { unsafe extern "C" { fn WWDG_IWDG () ; fn PVD () ; fn PWM () ; fn FLASH () ; fn RCC () ; fn EXTI0_1 () ; fn EXTI2_3 () ; fn EXTI4_15 () ; fn HWDIV () ; fn DMA1_CHANNEL1 () ; fn DMA1_CHANNEL2_3 () ; fn DMA1_CHANNEL4_5 () ; fn ADC_COMP () ; fn TIM1_BRK_UP_TRG_COM () ; fn TIM1_CC () ; fn TIM2 () ; fn TIM3 () ; fn TIM14 () ; fn TIM16 () ; fn TIM17 () ; fn I2C1 () ; fn SPI1 () ; fn SPI2 () ; fn UART1 () ; fn UART2 () ; } pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , } # [unsafe (link_section = ".vector_table.interrupts")] # [unsafe (no_mangle)] pub static __INTERRUPTS : [Vector ; 29] = [Vector { _handler : WWDG_IWDG } , Vector { _handler : PVD } , Vector { _handler : PWM } , Vector { _handler : FLASH } , Vector { _handler : RCC } , Vector { _handler : EXTI0_1 } , Vector { _handler : EXTI2_3 } , Vector { _handler : EXTI4_15 } , Vector { _handler : HWDIV } , Vector { _handler : DMA1_CHANNEL1 } , Vector { _handler : DMA1_CHANNEL2_3 } , Vector { _handler : DMA1_CHANNEL4_5 } , Vector { _handler : ADC_COMP } , Vector { _handler : TIM1_BRK_UP_TRG_COM } , Vector { _handler : TIM1_CC } , Vector { _handler : TIM2 } , Vector { _handler : TIM3 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : TIM14 } , Vector { _reserved : 0 } , Vector { _handler : TIM16 } , Vector { _handler : TIM17 } , Vector { _handler : I2C1 } , Vector { _reserved : 0 } , Vector { _handler : SPI1 } , Vector { _handler : SPI2 } , Vector { _handler : UART1 } , Vector { _handler : UART2 } ,] ; } # [doc = "DEVICE"] pub const DEVICE : device :: Device = unsafe { device :: Device :: from_ptr (0x1fff_f7e8usize as _) } ; # [doc = "General purpose timer"] pub const TIM2 : tim2 :: Tim2 = unsafe { tim2 :: Tim2 :: from_ptr (0x4000_0000usize as _) } ; # [doc = "General purpose timer"] pub const TIM3 : tim3 :: Tim3 = unsafe { tim3 :: Tim3 :: from_ptr (0x4000_0400usize as _) } ; # [doc = "Window watchdog"] pub const WWDG : wwdg :: Wwdg = unsafe { wwdg :: Wwdg :: from_ptr (0x4000_2c00usize as _) } ; # [doc = "Independent watchdog"] pub const IWDG : iwdg :: Iwdg = unsafe { iwdg :: Iwdg :: from_ptr (0x4000_3000usize as _) } ; pub const SPI2 : spi1 :: Spi1 = unsafe { spi1 :: Spi1 :: from_ptr (0x4000_3800usize as _) } ; pub const UART2 : uart1 :: Uart1 = unsafe { uart1 :: Uart1 :: from_ptr (0x4000_4400usize as _) } ; # [doc = "Inter integrated circuit"] pub const I2C1 : i2c1 :: I2c1 = unsafe { i2c1 :: I2c1 :: from_ptr (0x4000_5400usize as _) } ; # [doc = "Power control"] pub const PWR : pwr :: Pwr = unsafe { pwr :: Pwr :: from_ptr (0x4000_7000usize as _) } ; # [doc = "External interrupt/event controller"] pub const EXTI : exti :: Exti = unsafe { exti :: Exti :: from_ptr (0x4001_0000usize as _) } ; # [doc = "Analog to digital converter"] pub const ADC : adc :: Adc = unsafe { adc :: Adc :: from_ptr (0x4001_2400usize as _) } ; # [doc = "Advanced timer"] pub const TIM1 : tim1 :: Tim1 = unsafe { tim1 :: Tim1 :: from_ptr (0x4001_2c00usize as _) } ; # [doc = "Serial peripheral interface"] pub const SPI1 : spi1 :: Spi1 = unsafe { spi1 :: Spi1 :: from_ptr (0x4001_3000usize as _) } ; # [doc = "Debug support"] pub const DBG : dbg :: Dbg = unsafe { dbg :: Dbg :: from_ptr (0x4001_3400usize as _) } ; # [doc = "Universal asynchronous receiver transmitter"] pub const UART1 : uart1 :: Uart1 = unsafe { uart1 :: Uart1 :: from_ptr (0x4001_3800usize as _) } ; # [doc = "comparator"] pub const COMP : comp :: Comp = unsafe { comp :: Comp :: from_ptr (0x4001_3c00usize as _) } ; # [doc = "Basic purpose timer"] pub const TIM14 : tim14 :: Tim14 = unsafe { tim14 :: Tim14 :: from_ptr (0x4001_4000usize as _) } ; # [doc = "Basic purpose timer"] pub const TIM16 : tim16 :: Tim16 = unsafe { tim16 :: Tim16 :: from_ptr (0x4001_4400usize as _) } ; pub const TIM17 : tim16 :: Tim16 = unsafe { tim16 :: Tim16 :: from_ptr (0x4001_4800usize as _) } ; # [doc = "PWM Control"] pub const PWM : pwm :: Pwm = unsafe { pwm :: Pwm :: from_ptr (0x4001_6400usize as _) } ; # [doc = "DMA1 controller"] pub const DMA1 : dma1 :: Dma1 = unsafe { dma1 :: Dma1 :: from_ptr (0x4002_0000usize as _) } ; # [doc = "Reset and clock control"] pub const RCC : rcc :: Rcc = unsafe { rcc :: Rcc :: from_ptr (0x4002_1000usize as _) } ; # [doc = "FLASH"] pub const FLASH : flash :: Flash = unsafe { flash :: Flash :: from_ptr (0x4002_2000usize as _) } ; # [doc = "CRC calculation unit"] pub const CRC : crc :: Crc = unsafe { crc :: Crc :: from_ptr (0x4002_3000usize as _) } ; # [doc = "Hardware divider"] pub const DIV : div :: Div = unsafe { div :: Div :: from_ptr (0x4003_0000usize as _) } ; # [doc = "General purpose I/O"] pub const GPIOA : gpioa :: Gpioa = unsafe { gpioa :: Gpioa :: from_ptr (0x4800_0000usize as _) } ; pub const GPIOB : gpioa :: Gpioa = unsafe { gpioa :: Gpioa :: from_ptr (0x4800_0400usize as _) } ; pub const GPIOC : gpioa :: Gpioa = unsafe { gpioa :: Gpioa :: from_ptr (0x4800_0800usize as _) } ; pub const GPIOD : gpioa :: Gpioa = unsafe { gpioa :: Gpioa :: from_ptr (0x4800_0c00usize as _) } ; # [doc = r" Number available in the NVIC for configuring priority"] # [cfg (feature = "rt")] pub const NVIC_PRIO_BITS : u8 = 2 ; # [cfg (feature = "rt")] pub use cortex_m_rt :: interrupt ; # [cfg (feature = "rt")] pub use Interrupt as interrupt ; pub mod adc { # [doc = "Analog to digital converter"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Adc { ptr : * mut u8 } unsafe impl Send for Adc { } unsafe impl Sync for Adc { } impl Adc { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Data register"] # [inline (always)] pub const fn dr (self) -> crate :: common :: Reg < regs :: Dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Configure register"] # [inline (always)] pub const fn cfgr (self) -> crate :: common :: Reg < regs :: Cfgr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Control register"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "Channel select register"] # [inline (always)] pub const fn chsr (self) -> crate :: common :: Reg < regs :: Chsr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "Compare register"] # [inline (always)] pub const fn cmpr (self) -> crate :: common :: Reg < regs :: Cmpr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "Status register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "Channel 0 data register"] # [inline (always)] pub const fn ch0dr (self) -> crate :: common :: Reg < regs :: Ch0dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "Channel 1 data register"] # [inline (always)] pub const fn ch1dr (self) -> crate :: common :: Reg < regs :: Ch1dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "Channel 2 data register"] # [inline (always)] pub const fn ch2dr (self) -> crate :: common :: Reg < regs :: Ch2dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "Channel 3 data register"] # [inline (always)] pub const fn ch3dr (self) -> crate :: common :: Reg < regs :: Ch3dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "Channel 4 data register"] # [inline (always)] pub const fn ch4dr (self) -> crate :: common :: Reg < regs :: Ch4dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "Channel 5 data register"] # [inline (always)] pub const fn ch5dr (self) -> crate :: common :: Reg < regs :: Ch5dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x2cusize) as _) } } # [doc = "Channel 6 data register"] # [inline (always)] pub const fn ch6dr (self) -> crate :: common :: Reg < regs :: Ch6dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x30usize) as _) } } # [doc = "Channel 7 data register"] # [inline (always)] pub const fn ch7dr (self) -> crate :: common :: Reg < regs :: Ch7dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x34usize) as _) } } # [doc = "Channel 8 data register"] # [inline (always)] pub const fn ch8dr (self) -> crate :: common :: Reg < regs :: Ch8dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x38usize) as _) } } # [doc = "Channel 9 data register"] # [inline (always)] pub const fn ch9dr (self) -> crate :: common :: Reg < regs :: Ch9dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x3cusize) as _) } } # [doc = "Channel 10 data register"] # [inline (always)] pub const fn ch10dr (self) -> crate :: common :: Reg < regs :: Ch10dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x40usize) as _) } } # [doc = "Channel 11 data register"] # [inline (always)] pub const fn ch11dr (self) -> crate :: common :: Reg < regs :: Ch11dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x44usize) as _) } } # [doc = "Channel 12 data register"] # [inline (always)] pub const fn ch12dr (self) -> crate :: common :: Reg < regs :: Ch12dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x48usize) as _) } } # [doc = "Channel 14 data register"] # [inline (always)] pub const fn ch14dr (self) -> crate :: common :: Reg < regs :: Ch14dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x50usize) as _) } } # [doc = "Channel 15 data register"] # [inline (always)] pub const fn ch15dr (self) -> crate :: common :: Reg < regs :: Ch15dr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x54usize) as _) } } # [doc = "Extended status register"] # [inline (always)] pub const fn sta_ext (self) -> crate :: common :: Reg < regs :: StaExt , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x58usize) as _) } } } pub mod regs { # [doc = "Configure register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cfgr (pub u32) ; impl Cfgr { # [doc = "ADC enable"] # [must_use] # [inline (always)] pub const fn aden (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "ADC enable"] # [inline (always)] pub const fn set_aden (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "ADC window comparison enable"] # [must_use] # [inline (always)] pub const fn adwen (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "ADC window comparison enable"] # [inline (always)] pub const fn set_adwen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Temperature sensor enable"] # [must_use] # [inline (always)] pub const fn tsen (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Temperature sensor enable"] # [inline (always)] pub const fn set_tsen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Reference voltage enable"] # [must_use] # [inline (always)] pub const fn vsen (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Reference voltage enable"] # [inline (always)] pub const fn set_vsen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "ADC high prescaler coefficient"] # [must_use] # [inline (always)] pub const fn preh (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "ADC high prescaler coefficient"] # [inline (always)] pub const fn set_preh (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Resolution"] # [must_use] # [inline (always)] pub const fn rsltctl (& self) -> u8 { let val = (self . 0 >> 7usize) & 0x07 ; val as u8 } # [doc = "Resolution"] # [inline (always)] pub const fn set_rsltctl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 7usize)) | (((val as u32) & 0x07) << 7usize) ; } # [doc = "Channel x Sample time selection"] # [must_use] # [inline (always)] pub const fn samctl (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x0f ; val as u8 } # [doc = "Channel x Sample time selection"] # [inline (always)] pub const fn set_samctl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 10usize)) | (((val as u32) & 0x0f) << 10usize) ; } # [doc = "ADC low prescaler coefficient"] # [must_use] # [inline (always)] pub const fn prel (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "ADC low prescaler coefficient"] # [inline (always)] pub const fn set_prel (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } } impl Default for Cfgr { # [inline (always)] fn default () -> Cfgr { Cfgr (0) } } impl core :: fmt :: Debug for Cfgr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cfgr") . field ("aden" , & self . aden ()) . field ("adwen" , & self . adwen ()) . field ("tsen" , & self . tsen ()) . field ("vsen" , & self . vsen ()) . field ("preh" , & self . preh ()) . field ("rsltctl" , & self . rsltctl ()) . field ("samctl" , & self . samctl ()) . field ("prel" , & self . prel ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cfgr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cfgr {{ aden: {=bool:?}, adwen: {=bool:?}, tsen: {=bool:?}, vsen: {=bool:?}, preh: {=u8:?}, rsltctl: {=u8:?}, samctl: {=u8:?}, prel: {=bool:?} }}" , self . aden () , self . adwen () , self . tsen () , self . vsen () , self . preh () , self . rsltctl () , self . samctl () , self . prel ()) } } # [doc = "Channel 0 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch0dr (pub u32) ; impl Ch0dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch0dr { # [inline (always)] fn default () -> Ch0dr { Ch0dr (0) } } impl core :: fmt :: Debug for Ch0dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch0dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch0dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch0dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 10 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch10dr (pub u32) ; impl Ch10dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch10dr { # [inline (always)] fn default () -> Ch10dr { Ch10dr (0) } } impl core :: fmt :: Debug for Ch10dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch10dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch10dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch10dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 11 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch11dr (pub u32) ; impl Ch11dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch11dr { # [inline (always)] fn default () -> Ch11dr { Ch11dr (0) } } impl core :: fmt :: Debug for Ch11dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch11dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch11dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch11dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 12 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch12dr (pub u32) ; impl Ch12dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch12dr { # [inline (always)] fn default () -> Ch12dr { Ch12dr (0) } } impl core :: fmt :: Debug for Ch12dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch12dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch12dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch12dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 14 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch14dr (pub u32) ; impl Ch14dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch14dr { # [inline (always)] fn default () -> Ch14dr { Ch14dr (0) } } impl core :: fmt :: Debug for Ch14dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch14dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch14dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch14dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 15 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch15dr (pub u32) ; impl Ch15dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch15dr { # [inline (always)] fn default () -> Ch15dr { Ch15dr (0) } } impl core :: fmt :: Debug for Ch15dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch15dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch15dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch15dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 1 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch1dr (pub u32) ; impl Ch1dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch1dr { # [inline (always)] fn default () -> Ch1dr { Ch1dr (0) } } impl core :: fmt :: Debug for Ch1dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch1dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch1dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch1dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 2 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch2dr (pub u32) ; impl Ch2dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch2dr { # [inline (always)] fn default () -> Ch2dr { Ch2dr (0) } } impl core :: fmt :: Debug for Ch2dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch2dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch2dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch2dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 3 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch3dr (pub u32) ; impl Ch3dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch3dr { # [inline (always)] fn default () -> Ch3dr { Ch3dr (0) } } impl core :: fmt :: Debug for Ch3dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch3dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch3dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch3dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 4 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch4dr (pub u32) ; impl Ch4dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch4dr { # [inline (always)] fn default () -> Ch4dr { Ch4dr (0) } } impl core :: fmt :: Debug for Ch4dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch4dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch4dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch4dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 5 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch5dr (pub u32) ; impl Ch5dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch5dr { # [inline (always)] fn default () -> Ch5dr { Ch5dr (0) } } impl core :: fmt :: Debug for Ch5dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch5dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch5dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch5dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 6 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch6dr (pub u32) ; impl Ch6dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch6dr { # [inline (always)] fn default () -> Ch6dr { Ch6dr (0) } } impl core :: fmt :: Debug for Ch6dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch6dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch6dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch6dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 7 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch7dr (pub u32) ; impl Ch7dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch7dr { # [inline (always)] fn default () -> Ch7dr { Ch7dr (0) } } impl core :: fmt :: Debug for Ch7dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch7dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch7dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch7dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 8 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch8dr (pub u32) ; impl Ch8dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch8dr { # [inline (always)] fn default () -> Ch8dr { Ch8dr (0) } } impl core :: fmt :: Debug for Ch8dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch8dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch8dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch8dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel 9 data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ch9dr (pub u32) ; impl Ch9dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Ch9dr { # [inline (always)] fn default () -> Ch9dr { Ch9dr (0) } } impl core :: fmt :: Debug for Ch9dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ch9dr") . field ("data" , & self . data ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ch9dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ch9dr {{ data: {=u16:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . overrun () , self . valid ()) } } # [doc = "Channel select register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Chsr (pub u32) ; impl Chsr { # [doc = "Analog input channel 0 enable"] # [must_use] # [inline (always)] pub const fn ch0en (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 0 enable"] # [inline (always)] pub const fn set_ch0en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Analog input channel 1 enable"] # [must_use] # [inline (always)] pub const fn ch1en (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 1 enable"] # [inline (always)] pub const fn set_ch1en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Analog input channel 2 enable"] # [must_use] # [inline (always)] pub const fn ch2en (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 2 enable"] # [inline (always)] pub const fn set_ch2en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Analog input channel 3 enable"] # [must_use] # [inline (always)] pub const fn ch3en (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 3 enable"] # [inline (always)] pub const fn set_ch3en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Analog input channel 4 enable"] # [must_use] # [inline (always)] pub const fn ch4en (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 4 enable"] # [inline (always)] pub const fn set_ch4en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Analog input channel 5 enable"] # [must_use] # [inline (always)] pub const fn ch5en (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 5 enable"] # [inline (always)] pub const fn set_ch5en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Analog input channel 6 enable"] # [must_use] # [inline (always)] pub const fn ch6en (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 6 enable"] # [inline (always)] pub const fn set_ch6en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Analog input channel 7 enable"] # [must_use] # [inline (always)] pub const fn ch7en (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 7 enable"] # [inline (always)] pub const fn set_ch7en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Analog input channel 8 enable"] # [must_use] # [inline (always)] pub const fn ch8en (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 8 enable"] # [inline (always)] pub const fn set_ch8en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Analog input channel 9 enable"] # [must_use] # [inline (always)] pub const fn ch9en (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 9 enable"] # [inline (always)] pub const fn set_ch9en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Analog input channel 10 enable"] # [must_use] # [inline (always)] pub const fn ch10en (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 10 enable"] # [inline (always)] pub const fn set_ch10en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Analog input channel 11 enable"] # [must_use] # [inline (always)] pub const fn ch11en (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Analog input channel 11 enable"] # [inline (always)] pub const fn set_ch11en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Enable ADC internal self-calibration channel"] # [must_use] # [inline (always)] pub const fn chcalib (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Enable ADC internal self-calibration channel"] # [inline (always)] pub const fn set_chcalib (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Temperature Sensor channel enable"] # [must_use] # [inline (always)] pub const fn chtsen (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Temperature Sensor channel enable"] # [inline (always)] pub const fn set_chtsen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Internal reference voltage channel enable"] # [must_use] # [inline (always)] pub const fn chvsen (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Internal reference voltage channel enable"] # [inline (always)] pub const fn set_chvsen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Chsr { # [inline (always)] fn default () -> Chsr { Chsr (0) } } impl core :: fmt :: Debug for Chsr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Chsr") . field ("ch0en" , & self . ch0en ()) . field ("ch1en" , & self . ch1en ()) . field ("ch2en" , & self . ch2en ()) . field ("ch3en" , & self . ch3en ()) . field ("ch4en" , & self . ch4en ()) . field ("ch5en" , & self . ch5en ()) . field ("ch6en" , & self . ch6en ()) . field ("ch7en" , & self . ch7en ()) . field ("ch8en" , & self . ch8en ()) . field ("ch9en" , & self . ch9en ()) . field ("ch10en" , & self . ch10en ()) . field ("ch11en" , & self . ch11en ()) . field ("chcalib" , & self . chcalib ()) . field ("chtsen" , & self . chtsen ()) . field ("chvsen" , & self . chvsen ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Chsr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Chsr {{ ch0en: {=bool:?}, ch1en: {=bool:?}, ch2en: {=bool:?}, ch3en: {=bool:?}, ch4en: {=bool:?}, ch5en: {=bool:?}, ch6en: {=bool:?}, ch7en: {=bool:?}, ch8en: {=bool:?}, ch9en: {=bool:?}, ch10en: {=bool:?}, ch11en: {=bool:?}, chcalib: {=bool:?}, chtsen: {=bool:?}, chvsen: {=bool:?} }}" , self . ch0en () , self . ch1en () , self . ch2en () , self . ch3en () , self . ch4en () , self . ch5en () , self . ch6en () , self . ch7en () , self . ch8en () , self . ch9en () , self . ch10en () , self . ch11en () , self . chcalib () , self . chtsen () , self . chvsen ()) } } # [doc = "Compare register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cmpr (pub u32) ; impl Cmpr { # [doc = "Compare data low limit"] # [must_use] # [inline (always)] pub const fn cmpldata (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x0fff ; val as u16 } # [doc = "Compare data low limit"] # [inline (always)] pub const fn set_cmpldata (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize) ; } # [doc = "Compare data high limit"] # [must_use] # [inline (always)] pub const fn cmphdata (& self) -> u16 { let val = (self . 0 >> 16usize) & 0x0fff ; val as u16 } # [doc = "Compare data high limit"] # [inline (always)] pub const fn set_cmphdata (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x0fff << 16usize)) | (((val as u32) & 0x0fff) << 16usize) ; } } impl Default for Cmpr { # [inline (always)] fn default () -> Cmpr { Cmpr (0) } } impl core :: fmt :: Debug for Cmpr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cmpr") . field ("cmpldata" , & self . cmpldata ()) . field ("cmphdata" , & self . cmphdata ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cmpr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cmpr {{ cmpldata: {=u16:?}, cmphdata: {=u16:?} }}" , self . cmpldata () , self . cmphdata ()) } } # [doc = "Control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "ADC interrupt enable"] # [must_use] # [inline (always)] pub const fn adie (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "ADC interrupt enable"] # [inline (always)] pub const fn set_adie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "ADC window comparator interrupt enable"] # [must_use] # [inline (always)] pub const fn adwie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "ADC window comparator interrupt enable"] # [inline (always)] pub const fn set_adwie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "External trigger enable"] # [must_use] # [inline (always)] pub const fn trgen (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "External trigger enable"] # [inline (always)] pub const fn set_trgen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Direct memory access enable"] # [must_use] # [inline (always)] pub const fn dmaen (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Direct memory access enable"] # [inline (always)] pub const fn set_dmaen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "External trigger selection low"] # [must_use] # [inline (always)] pub const fn trgsell (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "External trigger selection low"] # [inline (always)] pub const fn set_trgsell (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "ADC start"] # [must_use] # [inline (always)] pub const fn adst (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "ADC start"] # [inline (always)] pub const fn set_adst (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "ADC mode"] # [must_use] # [inline (always)] pub const fn mode (& self) -> u8 { let val = (self . 0 >> 9usize) & 0x03 ; val as u8 } # [doc = "ADC mode"] # [inline (always)] pub const fn set_mode (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 9usize)) | (((val as u32) & 0x03) << 9usize) ; } # [doc = "Data alignment"] # [must_use] # [inline (always)] pub const fn align (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Data alignment"] # [inline (always)] pub const fn set_align (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Window comparison channel selection"] # [must_use] # [inline (always)] pub const fn cmpch (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "Window comparison channel selection"] # [inline (always)] pub const fn set_cmpch (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } # [doc = "ADC scan direction"] # [must_use] # [inline (always)] pub const fn scandir (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "ADC scan direction"] # [inline (always)] pub const fn set_scandir (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "External trigger selection high"] # [must_use] # [inline (always)] pub const fn trgselh (& self) -> u8 { let val = (self . 0 >> 17usize) & 0x03 ; val as u8 } # [doc = "External trigger selection high"] # [inline (always)] pub const fn set_trgselh (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 17usize)) | (((val as u32) & 0x03) << 17usize) ; } # [doc = "External trigger shift sample"] # [must_use] # [inline (always)] pub const fn trgshift (& self) -> u8 { let val = (self . 0 >> 19usize) & 0x07 ; val as u8 } # [doc = "External trigger shift sample"] # [inline (always)] pub const fn set_trgshift (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 19usize)) | (((val as u32) & 0x07) << 19usize) ; } # [doc = "Self-calibration enable"] # [must_use] # [inline (always)] pub const fn caliben (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "Self-calibration enable"] # [inline (always)] pub const fn set_caliben (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "Self-calibration voltage selection"] # [must_use] # [inline (always)] pub const fn calibsel (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "Self-calibration voltage selection"] # [inline (always)] pub const fn set_calibsel (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("adie" , & self . adie ()) . field ("adwie" , & self . adwie ()) . field ("trgen" , & self . trgen ()) . field ("dmaen" , & self . dmaen ()) . field ("trgsell" , & self . trgsell ()) . field ("adst" , & self . adst ()) . field ("mode" , & self . mode ()) . field ("align" , & self . align ()) . field ("cmpch" , & self . cmpch ()) . field ("scandir" , & self . scandir ()) . field ("trgselh" , & self . trgselh ()) . field ("trgshift" , & self . trgshift ()) . field ("caliben" , & self . caliben ()) . field ("calibsel" , & self . calibsel ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ adie: {=bool:?}, adwie: {=bool:?}, trgen: {=bool:?}, dmaen: {=bool:?}, trgsell: {=u8:?}, adst: {=bool:?}, mode: {=u8:?}, align: {=bool:?}, cmpch: {=u8:?}, scandir: {=bool:?}, trgselh: {=u8:?}, trgshift: {=u8:?}, caliben: {=bool:?}, calibsel: {=bool:?} }}" , self . adie () , self . adwie () , self . trgen () , self . dmaen () , self . trgsell () , self . adst () , self . mode () , self . align () , self . cmpch () , self . scandir () , self . trgselh () , self . trgshift () , self . caliben () , self . calibsel ()) } } # [doc = "Data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dr (pub u32) ; impl Dr { # [doc = "Transfer data"] # [must_use] # [inline (always)] pub const fn data (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Transfer data"] # [inline (always)] pub const fn set_data (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "ADC current channel convert data"] # [must_use] # [inline (always)] pub const fn ch (& self) -> u8 { let val = (self . 0 >> 16usize) & 0x0f ; val as u8 } # [doc = "ADC current channel convert data"] # [inline (always)] pub const fn set_ch (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Dr { # [inline (always)] fn default () -> Dr { Dr (0) } } impl core :: fmt :: Debug for Dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dr") . field ("data" , & self . data ()) . field ("ch" , & self . ch ()) . field ("overrun" , & self . overrun ()) . field ("valid" , & self . valid ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dr {{ data: {=u16:?}, ch: {=u8:?}, overrun: {=bool:?}, valid: {=bool:?} }}" , self . data () , self . ch () , self . overrun () , self . valid ()) } } # [doc = "Status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "ADC interrupt flag"] # [must_use] # [inline (always)] pub const fn adif (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "ADC interrupt flag"] # [inline (always)] pub const fn set_adif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "ADC window comparator interrupt flag"] # [must_use] # [inline (always)] pub const fn adwif (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "ADC window comparator interrupt flag"] # [inline (always)] pub const fn set_adwif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Busy"] # [must_use] # [inline (always)] pub const fn busy (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Busy"] # [inline (always)] pub const fn set_busy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Current conversion channel"] # [must_use] # [inline (always)] pub const fn ch (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Current conversion channel"] # [inline (always)] pub const fn set_ch (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> u16 { let val = (self . 0 >> 8usize) & 0x0fff ; val as u16 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x0fff << 8usize)) | (((val as u32) & 0x0fff) << 8usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> u16 { let val = (self . 0 >> 20usize) & 0x0fff ; val as u16 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x0fff << 20usize)) | (((val as u32) & 0x0fff) << 20usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("adif" , & self . adif ()) . field ("adwif" , & self . adwif ()) . field ("busy" , & self . busy ()) . field ("ch" , & self . ch ()) . field ("valid" , & self . valid ()) . field ("overrun" , & self . overrun ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ adif: {=bool:?}, adwif: {=bool:?}, busy: {=bool:?}, ch: {=u8:?}, valid: {=u16:?}, overrun: {=u16:?} }}" , self . adif () , self . adwif () , self . busy () , self . ch () , self . valid () , self . overrun ()) } } # [doc = "Extended status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct StaExt (pub u32) ; impl StaExt { # [doc = "Valid flag"] # [must_use] # [inline (always)] pub const fn valid (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "Valid flag"] # [inline (always)] pub const fn set_valid (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "Overrun flag"] # [must_use] # [inline (always)] pub const fn overrun (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Overrun flag"] # [inline (always)] pub const fn set_overrun (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } } impl Default for StaExt { # [inline (always)] fn default () -> StaExt { StaExt (0) } } impl core :: fmt :: Debug for StaExt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("StaExt") . field ("valid" , & self . valid ()) . field ("overrun" , & self . overrun ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for StaExt { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "StaExt {{ valid: {=u8:?}, overrun: {=u8:?} }}" , self . valid () , self . overrun ()) } } } } pub mod common { use core :: marker :: PhantomData ; # [derive (Copy , Clone , PartialEq , Eq)] pub struct RW ; # [derive (Copy , Clone , PartialEq , Eq)] pub struct R ; # [derive (Copy , Clone , PartialEq , Eq)] pub struct W ; mod sealed { use super ::*; pub trait Access { } impl Access for R { } impl Access for W { } impl Access for RW { } } pub trait Access : sealed :: Access + Copy { } impl Access for R { } impl Access for W { } impl Access for RW { } pub trait Read : Access { } impl Read for RW { } impl Read for R { } pub trait Write : Access { } impl Write for RW { } impl Write for W { } # [derive (Copy , Clone , PartialEq , Eq)] pub struct Reg < T : Copy , A : Access > { ptr : * mut u8 , phantom : PhantomData <* mut (T , A) >, } unsafe impl < T : Copy , A : Access > Send for Reg < T , A > { } unsafe impl < T : Copy , A : Access > Sync for Reg < T , A > { } impl < T : Copy , A : Access > Reg < T , A > { # [allow (clippy :: missing_safety_doc)] # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut T) -> Self { Self { ptr : ptr as _ , phantom : PhantomData , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut T { self . ptr as _ } } impl < T : Copy , A : Read > Reg < T , A > { # [inline (always)] pub fn read (& self) -> T { unsafe { (self . ptr as * mut T) . read_volatile () } } } impl < T : Copy , A : Write > Reg < T , A > { # [inline (always)] pub fn write_value (& self , val : T) { unsafe { (self . ptr as * mut T) . write_volatile (val) } } } impl < T : Default + Copy , A : Write > Reg < T , A > { # [inline (always)] pub fn write (& self , f : impl FnOnce (& mut T)) { let mut val = Default :: default () ; f (& mut val) ; self . write_value (val) ; } } impl < T : Copy , A : Read + Write > Reg < T , A > { # [inline (always)] pub fn modify (& self , f : impl FnOnce (& mut T)) { let mut val = self . read () ; f (& mut val) ; self . write_value (val) ; } } } pub mod comp { # [doc = "comparator"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Comp { ptr : * mut u8 } unsafe impl Send for Comp { } unsafe impl Sync for Comp { } impl Comp { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "COMP1_CSR"] # [inline (always)] pub const fn comp1_csr (self) -> crate :: common :: Reg < regs :: Comp1Csr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "COMP_CRV"] # [inline (always)] pub const fn comp_crv (self) -> crate :: common :: Reg < regs :: CompCrv , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "COMP1_POLL"] # [inline (always)] pub const fn comp1_poll (self) -> crate :: common :: Reg < regs :: Comp1Poll , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } } pub mod regs { # [doc = "COMP1_CSR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Comp1Csr (pub u32) ; impl Comp1Csr { # [doc = "Comparator 1 enable"] # [must_use] # [inline (always)] pub const fn en (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Comparator 1 enable"] # [inline (always)] pub const fn set_en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Comparator 1 mode"] # [must_use] # [inline (always)] pub const fn mode (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Comparator 1 mode"] # [inline (always)] pub const fn set_mode (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Comparator 1 inverting input selection"] # [must_use] # [inline (always)] pub const fn inm (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x03 ; val as u8 } # [doc = "Comparator 1 inverting input selection"] # [inline (always)] pub const fn set_inm (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize) ; } # [doc = "Comparator 1 normal phase input selection"] # [must_use] # [inline (always)] pub const fn inp (& self) -> u8 { let val = (self . 0 >> 7usize) & 0x03 ; val as u8 } # [doc = "Comparator 1 normal phase input selection"] # [inline (always)] pub const fn set_inp (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 7usize)) | (((val as u32) & 0x03) << 7usize) ; } # [doc = "Comparator 1 output selection"] # [must_use] # [inline (always)] pub const fn out (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x0f ; val as u8 } # [doc = "Comparator 1 output selection"] # [inline (always)] pub const fn set_out (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 10usize)) | (((val as u32) & 0x0f) << 10usize) ; } # [doc = "Comparator 1 output polarity"] # [must_use] # [inline (always)] pub const fn pol (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Comparator 1 output polarity"] # [inline (always)] pub const fn set_pol (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "Comparator 1 hysteresis"] # [must_use] # [inline (always)] pub const fn hyst (& self) -> u8 { let val = (self . 0 >> 16usize) & 0x03 ; val as u8 } # [doc = "Comparator 1 hysteresis"] # [inline (always)] pub const fn set_hyst (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize) ; } # [doc = "Comparator 1 output filter"] # [must_use] # [inline (always)] pub const fn oflt (& self) -> u8 { let val = (self . 0 >> 18usize) & 0x07 ; val as u8 } # [doc = "Comparator 1 output filter"] # [inline (always)] pub const fn set_oflt (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 18usize)) | (((val as u32) & 0x07) << 18usize) ; } # [doc = "Comparator 1 output status"] # [must_use] # [inline (always)] pub const fn sta (& self) -> bool { let val = (self . 0 >> 30usize) & 0x01 ; val != 0 } # [doc = "Comparator 1 output status"] # [inline (always)] pub const fn set_sta (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize) ; } # [doc = "Comparator 1 lock"] # [must_use] # [inline (always)] pub const fn lock (& self) -> bool { let val = (self . 0 >> 31usize) & 0x01 ; val != 0 } # [doc = "Comparator 1 lock"] # [inline (always)] pub const fn set_lock (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize) ; } } impl Default for Comp1Csr { # [inline (always)] fn default () -> Comp1Csr { Comp1Csr (0) } } impl core :: fmt :: Debug for Comp1Csr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Comp1Csr") . field ("en" , & self . en ()) . field ("mode" , & self . mode ()) . field ("inm" , & self . inm ()) . field ("inp" , & self . inp ()) . field ("out" , & self . out ()) . field ("pol" , & self . pol ()) . field ("hyst" , & self . hyst ()) . field ("oflt" , & self . oflt ()) . field ("sta" , & self . sta ()) . field ("lock" , & self . lock ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Comp1Csr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Comp1Csr {{ en: {=bool:?}, mode: {=u8:?}, inm: {=u8:?}, inp: {=u8:?}, out: {=u8:?}, pol: {=bool:?}, hyst: {=u8:?}, oflt: {=u8:?}, sta: {=bool:?}, lock: {=bool:?} }}" , self . en () , self . mode () , self . inm () , self . inp () , self . out () , self . pol () , self . hyst () , self . oflt () , self . sta () , self . lock ()) } } # [doc = "COMP1_POLL"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Comp1Poll (pub u32) ; impl Comp1Poll { # [doc = "Comparator 1 polling enable"] # [must_use] # [inline (always)] pub const fn en (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Comparator 1 polling enable"] # [inline (always)] pub const fn set_en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Comparator 1 polling channel"] # [must_use] # [inline (always)] pub const fn ch (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Comparator 1 polling channel"] # [inline (always)] pub const fn set_ch (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Comparator 1 Polling inverting input fix"] # [must_use] # [inline (always)] pub const fn fixn (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Comparator 1 Polling inverting input fix"] # [inline (always)] pub const fn set_fixn (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Comparator 1 polling wait cycle"] # [must_use] # [inline (always)] pub const fn period (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Comparator 1 polling wait cycle"] # [inline (always)] pub const fn set_period (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Comparator 1 Polling output"] # [must_use] # [inline (always)] pub const fn pout (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x07 ; val as u8 } # [doc = "Comparator 1 Polling output"] # [inline (always)] pub const fn set_pout (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize) ; } } impl Default for Comp1Poll { # [inline (always)] fn default () -> Comp1Poll { Comp1Poll (0) } } impl core :: fmt :: Debug for Comp1Poll { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Comp1Poll") . field ("en" , & self . en ()) . field ("ch" , & self . ch ()) . field ("fixn" , & self . fixn ()) . field ("period" , & self . period ()) . field ("pout" , & self . pout ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Comp1Poll { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Comp1Poll {{ en: {=bool:?}, ch: {=bool:?}, fixn: {=bool:?}, period: {=u8:?}, pout: {=u8:?} }}" , self . en () , self . ch () , self . fixn () , self . period () , self . pout ()) } } # [doc = "COMP_CRV"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct CompCrv (pub u32) ; impl CompCrv { # [doc = "Comparator external referencevoltage select"] # [must_use] # [inline (always)] pub const fn crv_sel (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "Comparator external referencevoltage select"] # [inline (always)] pub const fn set_crv_sel (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "Comparator external referencevoltage enable"] # [must_use] # [inline (always)] pub const fn en (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Comparator external referencevoltage enable"] # [inline (always)] pub const fn set_en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Comparator external refer-ence voltage source select"] # [must_use] # [inline (always)] pub const fn crv_src (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Comparator external refer-ence voltage source select"] # [inline (always)] pub const fn set_crv_src (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } } impl Default for CompCrv { # [inline (always)] fn default () -> CompCrv { CompCrv (0) } } impl core :: fmt :: Debug for CompCrv { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("CompCrv") . field ("crv_sel" , & self . crv_sel ()) . field ("en" , & self . en ()) . field ("crv_src" , & self . crv_src ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for CompCrv { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "CompCrv {{ crv_sel: {=u8:?}, en: {=bool:?}, crv_src: {=bool:?} }}" , self . crv_sel () , self . en () , self . crv_src ()) } } } } pub mod crc { # [doc = "CRC calculation unit"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Crc { ptr : * mut u8 } unsafe impl Send for Crc { } unsafe impl Sync for Crc { } impl Crc { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Data register"] # [inline (always)] pub const fn dr (self) -> crate :: common :: Reg < regs :: Dr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Independent data register"] # [inline (always)] pub const fn idr (self) -> crate :: common :: Reg < regs :: Idr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Control register"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } } pub mod regs { # [doc = "Control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "CRC reset"] # [must_use] # [inline (always)] pub const fn reset (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "CRC reset"] # [inline (always)] pub const fn set_reset (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("reset" , & self . reset ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ reset: {=bool:?} }}" , self . reset ()) } } # [doc = "Data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dr (pub u32) ; impl Dr { # [doc = "Data register bits"] # [must_use] # [inline (always)] pub const fn dr (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Data register bits"] # [inline (always)] pub const fn set_dr (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Dr { # [inline (always)] fn default () -> Dr { Dr (0) } } impl core :: fmt :: Debug for Dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dr") . field ("dr" , & self . dr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dr {{ dr: {=u32:?} }}" , self . dr ()) } } # [doc = "Independent data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Idr (pub u32) ; impl Idr { # [doc = "General-purpose 8-bit data register bits"] # [must_use] # [inline (always)] pub const fn idr (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "General-purpose 8-bit data register bits"] # [inline (always)] pub const fn set_idr (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Idr { # [inline (always)] fn default () -> Idr { Idr (0) } } impl core :: fmt :: Debug for Idr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Idr") . field ("idr" , & self . idr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Idr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Idr {{ idr: {=u8:?} }}" , self . idr ()) } } } } pub mod dbg { # [doc = "Debug support"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dbg { ptr : * mut u8 } unsafe impl Send for Dbg { } unsafe impl Sync for Dbg { } impl Dbg { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "IDCODE"] # [inline (always)] pub const fn idcode (self) -> crate :: common :: Reg < regs :: Idcode , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "CR"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } } pub mod regs { # [doc = "CR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "Debug Sleep mode"] # [must_use] # [inline (always)] pub const fn dbg_sleep (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Debug Sleep mode"] # [inline (always)] pub const fn set_dbg_sleep (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Debug Stop mode"] # [must_use] # [inline (always)] pub const fn dbg_stop (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Debug Stop mode"] # [inline (always)] pub const fn set_dbg_stop (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Debug Standby mode"] # [must_use] # [inline (always)] pub const fn dbg_standby (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Debug Standby mode"] # [inline (always)] pub const fn set_dbg_standby (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Debug independent watchdog stopped when core is stopped"] # [must_use] # [inline (always)] pub const fn dbg_iwdg_stop (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Debug independent watchdog stopped when core is stopped"] # [inline (always)] pub const fn set_dbg_iwdg_stop (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Debug window watchdog when core is halted"] # [must_use] # [inline (always)] pub const fn dbg_wwdg_stop (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Debug window watchdog when core is halted"] # [inline (always)] pub const fn set_dbg_wwdg_stop (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "TIMx counter stopped when core is halted"] # [must_use] # [inline (always)] pub const fn dbg_timx_stop (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x0f ; val as u8 } # [doc = "TIMx counter stopped when core is halted"] # [inline (always)] pub const fn set_dbg_timx_stop (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 10usize)) | (((val as u32) & 0x0f) << 10usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("dbg_sleep" , & self . dbg_sleep ()) . field ("dbg_stop" , & self . dbg_stop ()) . field ("dbg_standby" , & self . dbg_standby ()) . field ("dbg_iwdg_stop" , & self . dbg_iwdg_stop ()) . field ("dbg_wwdg_stop" , & self . dbg_wwdg_stop ()) . field ("dbg_timx_stop" , & self . dbg_timx_stop ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ dbg_sleep: {=bool:?}, dbg_stop: {=bool:?}, dbg_standby: {=bool:?}, dbg_iwdg_stop: {=bool:?}, dbg_wwdg_stop: {=bool:?}, dbg_timx_stop: {=u8:?} }}" , self . dbg_sleep () , self . dbg_stop () , self . dbg_standby () , self . dbg_iwdg_stop () , self . dbg_wwdg_stop () , self . dbg_timx_stop ()) } } # [doc = "IDCODE"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Idcode (pub u32) ; impl Idcode { # [doc = "Device identifier"] # [must_use] # [inline (always)] pub const fn dev_id (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Device identifier"] # [inline (always)] pub const fn set_dev_id (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Idcode { # [inline (always)] fn default () -> Idcode { Idcode (0) } } impl core :: fmt :: Debug for Idcode { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Idcode") . field ("dev_id" , & self . dev_id ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Idcode { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Idcode {{ dev_id: {=u32:?} }}" , self . dev_id ()) } } } } pub mod device { # [doc = "DEVICE"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Device { ptr : * mut u8 } unsafe impl Send for Device { } unsafe impl Sync for Device { } impl Device { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Configuration register"] # [inline (always)] pub const fn uid1 (self) -> crate :: common :: Reg < regs :: Uid1 , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Configuration register"] # [inline (always)] pub const fn uid2 (self) -> crate :: common :: Reg < regs :: Uid2 , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x02usize) as _) } } # [doc = "Configuration register"] # [inline (always)] pub const fn uid3 (self) -> crate :: common :: Reg < regs :: Uid3 , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Configuration register"] # [inline (always)] pub const fn uid4 (self) -> crate :: common :: Reg < regs :: Uid4 , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } } pub mod regs { # [doc = "Configuration register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Uid1 (pub u16) ; impl Uid1 { # [doc = "15:0 unique ID bits"] # [must_use] # [inline (always)] pub const fn u_id (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "15:0 unique ID bits"] # [inline (always)] pub const fn set_u_id (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize) ; } } impl Default for Uid1 { # [inline (always)] fn default () -> Uid1 { Uid1 (0) } } impl core :: fmt :: Debug for Uid1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uid1") . field ("u_id" , & self . u_id ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Uid1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Uid1 {{ u_id: {=u16:?} }}" , self . u_id ()) } } # [doc = "Configuration register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Uid2 (pub u16) ; impl Uid2 { # [doc = "31:16 unique ID bits"] # [must_use] # [inline (always)] pub const fn u_id (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "31:16 unique ID bits"] # [inline (always)] pub const fn set_u_id (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u16) & 0xffff) << 0usize) ; } } impl Default for Uid2 { # [inline (always)] fn default () -> Uid2 { Uid2 (0) } } impl core :: fmt :: Debug for Uid2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uid2") . field ("u_id" , & self . u_id ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Uid2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Uid2 {{ u_id: {=u16:?} }}" , self . u_id ()) } } # [doc = "Configuration register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Uid3 (pub u32) ; impl Uid3 { # [doc = "63:32 unique ID bits"] # [must_use] # [inline (always)] pub const fn u_id (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "63:32 unique ID bits"] # [inline (always)] pub const fn set_u_id (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Uid3 { # [inline (always)] fn default () -> Uid3 { Uid3 (0) } } impl core :: fmt :: Debug for Uid3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uid3") . field ("u_id" , & self . u_id ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Uid3 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Uid3 {{ u_id: {=u32:?} }}" , self . u_id ()) } } # [doc = "Configuration register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Uid4 (pub u32) ; impl Uid4 { # [doc = "95:64 unique ID bits"] # [must_use] # [inline (always)] pub const fn u_id (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "95:64 unique ID bits"] # [inline (always)] pub const fn set_u_id (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Uid4 { # [inline (always)] fn default () -> Uid4 { Uid4 (0) } } impl core :: fmt :: Debug for Uid4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uid4") . field ("u_id" , & self . u_id ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Uid4 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Uid4 {{ u_id: {=u32:?} }}" , self . u_id ()) } } } } pub mod div { # [doc = "Hardware divider"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Div { ptr : * mut u8 } unsafe impl Send for Div { } unsafe impl Sync for Div { } impl Div { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "DVDR"] # [inline (always)] pub const fn dvdr (self) -> crate :: common :: Reg < regs :: Dvdr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "DVSR"] # [inline (always)] pub const fn dvsr (self) -> crate :: common :: Reg < regs :: Dvsr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "QUOTR"] # [inline (always)] pub const fn quotr (self) -> crate :: common :: Reg < regs :: Quotr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "RMDR"] # [inline (always)] pub const fn rmdr (self) -> crate :: common :: Reg < regs :: Rmdr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "SR"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "CR"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } } pub mod regs { # [doc = "CR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "unsigned enable"] # [must_use] # [inline (always)] pub const fn usign (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "unsigned enable"] # [inline (always)] pub const fn set_usign (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Overflow interrupt enable"] # [must_use] # [inline (always)] pub const fn ovfe (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Overflow interrupt enable"] # [inline (always)] pub const fn set_ovfe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("usign" , & self . usign ()) . field ("ovfe" , & self . ovfe ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ usign: {=bool:?}, ovfe: {=bool:?} }}" , self . usign () , self . ovfe ()) } } # [doc = "DVDR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dvdr (pub u32) ; impl Dvdr { # [doc = "Dividend data"] # [must_use] # [inline (always)] pub const fn dividend (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Dividend data"] # [inline (always)] pub const fn set_dividend (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Dvdr { # [inline (always)] fn default () -> Dvdr { Dvdr (0) } } impl core :: fmt :: Debug for Dvdr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dvdr") . field ("dividend" , & self . dividend ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dvdr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dvdr {{ dividend: {=u32:?} }}" , self . dividend ()) } } # [doc = "DVSR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dvsr (pub u32) ; impl Dvsr { # [doc = "Divisor data"] # [must_use] # [inline (always)] pub const fn divisor (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Divisor data"] # [inline (always)] pub const fn set_divisor (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Dvsr { # [inline (always)] fn default () -> Dvsr { Dvsr (0) } } impl core :: fmt :: Debug for Dvsr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dvsr") . field ("divisor" , & self . divisor ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dvsr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dvsr {{ divisor: {=u32:?} }}" , self . divisor ()) } } # [doc = "QUOTR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Quotr (pub u32) ; impl Quotr { # [doc = "Quotient data"] # [must_use] # [inline (always)] pub const fn quotient (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Quotient data"] # [inline (always)] pub const fn set_quotient (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Quotr { # [inline (always)] fn default () -> Quotr { Quotr (0) } } impl core :: fmt :: Debug for Quotr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Quotr") . field ("quotient" , & self . quotient ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Quotr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Quotr {{ quotient: {=u32:?} }}" , self . quotient ()) } } # [doc = "RMDR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rmdr (pub u32) ; impl Rmdr { # [doc = "Remainder data"] # [must_use] # [inline (always)] pub const fn remainder (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Remainder data"] # [inline (always)] pub const fn set_remainder (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Rmdr { # [inline (always)] fn default () -> Rmdr { Rmdr (0) } } impl core :: fmt :: Debug for Rmdr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rmdr") . field ("remainder" , & self . remainder ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rmdr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rmdr {{ remainder: {=u32:?} }}" , self . remainder ()) } } # [doc = "SR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "Overflow flag"] # [must_use] # [inline (always)] pub const fn ovf (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Overflow flag"] # [inline (always)] pub const fn set_ovf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("ovf" , & self . ovf ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ ovf: {=bool:?} }}" , self . ovf ()) } } } } pub mod dma1 { # [doc = "DMA1 controller"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dma1 { ptr : * mut u8 } unsafe impl Send for Dma1 { } unsafe impl Sync for Dma1 { } impl Dma1 { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "ISR"] # [inline (always)] pub const fn isr (self) -> crate :: common :: Reg < regs :: Isr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "IFCR"] # [inline (always)] pub const fn ifcr (self) -> crate :: common :: Reg < regs :: Ifcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "CCR1"] # [inline (always)] pub const fn ccr1 (self) -> crate :: common :: Reg < regs :: Ccr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "CNDTR1"] # [inline (always)] pub const fn cndtr1 (self) -> crate :: common :: Reg < regs :: Cndtr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "CPAR1"] # [inline (always)] pub const fn cpar1 (self) -> crate :: common :: Reg < regs :: Cpar1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "CMAR1"] # [inline (always)] pub const fn cmar1 (self) -> crate :: common :: Reg < regs :: Cmar1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "CCR2"] # [inline (always)] pub const fn ccr2 (self) -> crate :: common :: Reg < regs :: Ccr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "CNDTR2"] # [inline (always)] pub const fn cndtr2 (self) -> crate :: common :: Reg < regs :: Cndtr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "CPAR2"] # [inline (always)] pub const fn cpar2 (self) -> crate :: common :: Reg < regs :: Cpar2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "CMAR2"] # [inline (always)] pub const fn cmar2 (self) -> crate :: common :: Reg < regs :: Cmar2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "CCR3"] # [inline (always)] pub const fn ccr3 (self) -> crate :: common :: Reg < regs :: Ccr3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x30usize) as _) } } # [doc = "CNDTR3"] # [inline (always)] pub const fn cndtr3 (self) -> crate :: common :: Reg < regs :: Cndtr3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x34usize) as _) } } # [doc = "CPAR3"] # [inline (always)] pub const fn cpar3 (self) -> crate :: common :: Reg < regs :: Cpar3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x38usize) as _) } } # [doc = "CMAR3"] # [inline (always)] pub const fn cmar3 (self) -> crate :: common :: Reg < regs :: Cmar3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x3cusize) as _) } } # [doc = "CCR4"] # [inline (always)] pub const fn ccr4 (self) -> crate :: common :: Reg < regs :: Ccr4 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x44usize) as _) } } # [doc = "CNDTR4"] # [inline (always)] pub const fn cndtr4 (self) -> crate :: common :: Reg < regs :: Cndtr4 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x48usize) as _) } } # [doc = "CPAR4"] # [inline (always)] pub const fn cpar4 (self) -> crate :: common :: Reg < regs :: Cpar4 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x4cusize) as _) } } # [doc = "CMAR4"] # [inline (always)] pub const fn cmar4 (self) -> crate :: common :: Reg < regs :: Cmar4 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x50usize) as _) } } # [doc = "CCR5"] # [inline (always)] pub const fn ccr5 (self) -> crate :: common :: Reg < regs :: Ccr5 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x58usize) as _) } } # [doc = "CNDTR5"] # [inline (always)] pub const fn cndtr5 (self) -> crate :: common :: Reg < regs :: Cndtr5 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x5cusize) as _) } } # [doc = "CPAR5"] # [inline (always)] pub const fn cpar5 (self) -> crate :: common :: Reg < regs :: Cpar5 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x60usize) as _) } } # [doc = "CMAR5"] # [inline (always)] pub const fn cmar5 (self) -> crate :: common :: Reg < regs :: Cmar5 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x64usize) as _) } } } pub mod regs { # [doc = "CCR1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr1 (pub u32) ; impl Ccr1 { # [doc = "Channel enable"] # [must_use] # [inline (always)] pub const fn en (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Channel enable"] # [inline (always)] pub const fn set_en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Transfer complete interrupt enable"] # [must_use] # [inline (always)] pub const fn tcie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Transfer complete interrupt enable"] # [inline (always)] pub const fn set_tcie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Half transfer interrupt enable"] # [must_use] # [inline (always)] pub const fn htie (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Half transfer interrupt enable"] # [inline (always)] pub const fn set_htie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Transfer error interrupt enable"] # [must_use] # [inline (always)] pub const fn teie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Transfer error interrupt enable"] # [inline (always)] pub const fn set_teie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Data transfer direction"] # [must_use] # [inline (always)] pub const fn dir (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Data transfer direction"] # [inline (always)] pub const fn set_dir (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Circular mode"] # [must_use] # [inline (always)] pub const fn circ (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Circular mode"] # [inline (always)] pub const fn set_circ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Peripheral increment mode"] # [must_use] # [inline (always)] pub const fn pinc (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Peripheral increment mode"] # [inline (always)] pub const fn set_pinc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Memory increment mode"] # [must_use] # [inline (always)] pub const fn minc (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Memory increment mode"] # [inline (always)] pub const fn set_minc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Peripheral size"] # [must_use] # [inline (always)] pub const fn psize (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Peripheral size"] # [inline (always)] pub const fn set_psize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Memory size"] # [must_use] # [inline (always)] pub const fn msize (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Memory size"] # [inline (always)] pub const fn set_msize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Channel priority level"] # [must_use] # [inline (always)] pub const fn pl (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "Channel priority level"] # [inline (always)] pub const fn set_pl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "Memory to memory mode"] # [must_use] # [inline (always)] pub const fn mem2mem (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Memory to memory mode"] # [inline (always)] pub const fn set_mem2mem (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Auto-Reload Enable bit"] # [must_use] # [inline (always)] pub const fn are (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Auto-Reload Enable bit"] # [inline (always)] pub const fn set_are (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccr1 { # [inline (always)] fn default () -> Ccr1 { Ccr1 (0) } } impl core :: fmt :: Debug for Ccr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr1") . field ("en" , & self . en ()) . field ("tcie" , & self . tcie ()) . field ("htie" , & self . htie ()) . field ("teie" , & self . teie ()) . field ("dir" , & self . dir ()) . field ("circ" , & self . circ ()) . field ("pinc" , & self . pinc ()) . field ("minc" , & self . minc ()) . field ("psize" , & self . psize ()) . field ("msize" , & self . msize ()) . field ("pl" , & self . pl ()) . field ("mem2mem" , & self . mem2mem ()) . field ("are" , & self . are ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr1 {{ en: {=bool:?}, tcie: {=bool:?}, htie: {=bool:?}, teie: {=bool:?}, dir: {=bool:?}, circ: {=bool:?}, pinc: {=bool:?}, minc: {=bool:?}, psize: {=u8:?}, msize: {=u8:?}, pl: {=u8:?}, mem2mem: {=bool:?}, are: {=bool:?} }}" , self . en () , self . tcie () , self . htie () , self . teie () , self . dir () , self . circ () , self . pinc () , self . minc () , self . psize () , self . msize () , self . pl () , self . mem2mem () , self . are ()) } } # [doc = "CCR2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr2 (pub u32) ; impl Ccr2 { # [doc = "Channel enable"] # [must_use] # [inline (always)] pub const fn en (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Channel enable"] # [inline (always)] pub const fn set_en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Transfer complete interrupt enable"] # [must_use] # [inline (always)] pub const fn tcie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Transfer complete interrupt enable"] # [inline (always)] pub const fn set_tcie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Half transfer interrupt enable"] # [must_use] # [inline (always)] pub const fn htie (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Half transfer interrupt enable"] # [inline (always)] pub const fn set_htie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Transfer error interrupt enable"] # [must_use] # [inline (always)] pub const fn teie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Transfer error interrupt enable"] # [inline (always)] pub const fn set_teie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Data transfer direction"] # [must_use] # [inline (always)] pub const fn dir (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Data transfer direction"] # [inline (always)] pub const fn set_dir (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Circular mode"] # [must_use] # [inline (always)] pub const fn circ (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Circular mode"] # [inline (always)] pub const fn set_circ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Peripheral increment mode"] # [must_use] # [inline (always)] pub const fn pinc (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Peripheral increment mode"] # [inline (always)] pub const fn set_pinc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Memory increment mode"] # [must_use] # [inline (always)] pub const fn minc (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Memory increment mode"] # [inline (always)] pub const fn set_minc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Peripheral size"] # [must_use] # [inline (always)] pub const fn psize (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Peripheral size"] # [inline (always)] pub const fn set_psize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Memory size"] # [must_use] # [inline (always)] pub const fn msize (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Memory size"] # [inline (always)] pub const fn set_msize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Channel priority level"] # [must_use] # [inline (always)] pub const fn pl (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "Channel priority level"] # [inline (always)] pub const fn set_pl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "Memory to memory mode"] # [must_use] # [inline (always)] pub const fn mem2mem (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Memory to memory mode"] # [inline (always)] pub const fn set_mem2mem (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Auto-Reload Enable bit"] # [must_use] # [inline (always)] pub const fn are (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Auto-Reload Enable bit"] # [inline (always)] pub const fn set_are (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccr2 { # [inline (always)] fn default () -> Ccr2 { Ccr2 (0) } } impl core :: fmt :: Debug for Ccr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr2") . field ("en" , & self . en ()) . field ("tcie" , & self . tcie ()) . field ("htie" , & self . htie ()) . field ("teie" , & self . teie ()) . field ("dir" , & self . dir ()) . field ("circ" , & self . circ ()) . field ("pinc" , & self . pinc ()) . field ("minc" , & self . minc ()) . field ("psize" , & self . psize ()) . field ("msize" , & self . msize ()) . field ("pl" , & self . pl ()) . field ("mem2mem" , & self . mem2mem ()) . field ("are" , & self . are ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr2 {{ en: {=bool:?}, tcie: {=bool:?}, htie: {=bool:?}, teie: {=bool:?}, dir: {=bool:?}, circ: {=bool:?}, pinc: {=bool:?}, minc: {=bool:?}, psize: {=u8:?}, msize: {=u8:?}, pl: {=u8:?}, mem2mem: {=bool:?}, are: {=bool:?} }}" , self . en () , self . tcie () , self . htie () , self . teie () , self . dir () , self . circ () , self . pinc () , self . minc () , self . psize () , self . msize () , self . pl () , self . mem2mem () , self . are ()) } } # [doc = "CCR3"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr3 (pub u32) ; impl Ccr3 { # [doc = "Channel enable"] # [must_use] # [inline (always)] pub const fn en (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Channel enable"] # [inline (always)] pub const fn set_en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Transfer complete interrupt enable"] # [must_use] # [inline (always)] pub const fn tcie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Transfer complete interrupt enable"] # [inline (always)] pub const fn set_tcie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Half transfer interrupt enable"] # [must_use] # [inline (always)] pub const fn htie (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Half transfer interrupt enable"] # [inline (always)] pub const fn set_htie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Transfer error interrupt enable"] # [must_use] # [inline (always)] pub const fn teie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Transfer error interrupt enable"] # [inline (always)] pub const fn set_teie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Data transfer direction"] # [must_use] # [inline (always)] pub const fn dir (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Data transfer direction"] # [inline (always)] pub const fn set_dir (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Circular mode"] # [must_use] # [inline (always)] pub const fn circ (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Circular mode"] # [inline (always)] pub const fn set_circ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Peripheral increment mode"] # [must_use] # [inline (always)] pub const fn pinc (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Peripheral increment mode"] # [inline (always)] pub const fn set_pinc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Memory increment mode"] # [must_use] # [inline (always)] pub const fn minc (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Memory increment mode"] # [inline (always)] pub const fn set_minc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Peripheral size"] # [must_use] # [inline (always)] pub const fn psize (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Peripheral size"] # [inline (always)] pub const fn set_psize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Memory size"] # [must_use] # [inline (always)] pub const fn msize (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Memory size"] # [inline (always)] pub const fn set_msize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Channel priority level"] # [must_use] # [inline (always)] pub const fn pl (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "Channel priority level"] # [inline (always)] pub const fn set_pl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "Memory to memory mode"] # [must_use] # [inline (always)] pub const fn mem2mem (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Memory to memory mode"] # [inline (always)] pub const fn set_mem2mem (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Auto-Reload Enable bit"] # [must_use] # [inline (always)] pub const fn are (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Auto-Reload Enable bit"] # [inline (always)] pub const fn set_are (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccr3 { # [inline (always)] fn default () -> Ccr3 { Ccr3 (0) } } impl core :: fmt :: Debug for Ccr3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr3") . field ("en" , & self . en ()) . field ("tcie" , & self . tcie ()) . field ("htie" , & self . htie ()) . field ("teie" , & self . teie ()) . field ("dir" , & self . dir ()) . field ("circ" , & self . circ ()) . field ("pinc" , & self . pinc ()) . field ("minc" , & self . minc ()) . field ("psize" , & self . psize ()) . field ("msize" , & self . msize ()) . field ("pl" , & self . pl ()) . field ("mem2mem" , & self . mem2mem ()) . field ("are" , & self . are ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr3 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr3 {{ en: {=bool:?}, tcie: {=bool:?}, htie: {=bool:?}, teie: {=bool:?}, dir: {=bool:?}, circ: {=bool:?}, pinc: {=bool:?}, minc: {=bool:?}, psize: {=u8:?}, msize: {=u8:?}, pl: {=u8:?}, mem2mem: {=bool:?}, are: {=bool:?} }}" , self . en () , self . tcie () , self . htie () , self . teie () , self . dir () , self . circ () , self . pinc () , self . minc () , self . psize () , self . msize () , self . pl () , self . mem2mem () , self . are ()) } } # [doc = "CCR4"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr4 (pub u32) ; impl Ccr4 { # [doc = "Channel enable"] # [must_use] # [inline (always)] pub const fn en (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Channel enable"] # [inline (always)] pub const fn set_en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Transfer complete interrupt enable"] # [must_use] # [inline (always)] pub const fn tcie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Transfer complete interrupt enable"] # [inline (always)] pub const fn set_tcie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Half transfer interrupt enable"] # [must_use] # [inline (always)] pub const fn htie (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Half transfer interrupt enable"] # [inline (always)] pub const fn set_htie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Transfer error interrupt enable"] # [must_use] # [inline (always)] pub const fn teie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Transfer error interrupt enable"] # [inline (always)] pub const fn set_teie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Data transfer direction"] # [must_use] # [inline (always)] pub const fn dir (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Data transfer direction"] # [inline (always)] pub const fn set_dir (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Circular mode"] # [must_use] # [inline (always)] pub const fn circ (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Circular mode"] # [inline (always)] pub const fn set_circ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Peripheral increment mode"] # [must_use] # [inline (always)] pub const fn pinc (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Peripheral increment mode"] # [inline (always)] pub const fn set_pinc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Memory increment mode"] # [must_use] # [inline (always)] pub const fn minc (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Memory increment mode"] # [inline (always)] pub const fn set_minc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Peripheral size"] # [must_use] # [inline (always)] pub const fn psize (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Peripheral size"] # [inline (always)] pub const fn set_psize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Memory size"] # [must_use] # [inline (always)] pub const fn msize (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Memory size"] # [inline (always)] pub const fn set_msize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Channel priority level"] # [must_use] # [inline (always)] pub const fn pl (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "Channel priority level"] # [inline (always)] pub const fn set_pl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "Memory to memory mode"] # [must_use] # [inline (always)] pub const fn mem2mem (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Memory to memory mode"] # [inline (always)] pub const fn set_mem2mem (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Auto-Reload Enable bit"] # [must_use] # [inline (always)] pub const fn are (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Auto-Reload Enable bit"] # [inline (always)] pub const fn set_are (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccr4 { # [inline (always)] fn default () -> Ccr4 { Ccr4 (0) } } impl core :: fmt :: Debug for Ccr4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr4") . field ("en" , & self . en ()) . field ("tcie" , & self . tcie ()) . field ("htie" , & self . htie ()) . field ("teie" , & self . teie ()) . field ("dir" , & self . dir ()) . field ("circ" , & self . circ ()) . field ("pinc" , & self . pinc ()) . field ("minc" , & self . minc ()) . field ("psize" , & self . psize ()) . field ("msize" , & self . msize ()) . field ("pl" , & self . pl ()) . field ("mem2mem" , & self . mem2mem ()) . field ("are" , & self . are ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr4 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr4 {{ en: {=bool:?}, tcie: {=bool:?}, htie: {=bool:?}, teie: {=bool:?}, dir: {=bool:?}, circ: {=bool:?}, pinc: {=bool:?}, minc: {=bool:?}, psize: {=u8:?}, msize: {=u8:?}, pl: {=u8:?}, mem2mem: {=bool:?}, are: {=bool:?} }}" , self . en () , self . tcie () , self . htie () , self . teie () , self . dir () , self . circ () , self . pinc () , self . minc () , self . psize () , self . msize () , self . pl () , self . mem2mem () , self . are ()) } } # [doc = "CCR5"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr5 (pub u32) ; impl Ccr5 { # [doc = "Channel enable"] # [must_use] # [inline (always)] pub const fn en (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Channel enable"] # [inline (always)] pub const fn set_en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Transfer complete interrupt enable"] # [must_use] # [inline (always)] pub const fn tcie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Transfer complete interrupt enable"] # [inline (always)] pub const fn set_tcie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Half transfer interrupt enable"] # [must_use] # [inline (always)] pub const fn htie (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Half transfer interrupt enable"] # [inline (always)] pub const fn set_htie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Transfer error interrupt enable"] # [must_use] # [inline (always)] pub const fn teie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Transfer error interrupt enable"] # [inline (always)] pub const fn set_teie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Data transfer direction"] # [must_use] # [inline (always)] pub const fn dir (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Data transfer direction"] # [inline (always)] pub const fn set_dir (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Circular mode"] # [must_use] # [inline (always)] pub const fn circ (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Circular mode"] # [inline (always)] pub const fn set_circ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Peripheral increment mode"] # [must_use] # [inline (always)] pub const fn pinc (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Peripheral increment mode"] # [inline (always)] pub const fn set_pinc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Memory increment mode"] # [must_use] # [inline (always)] pub const fn minc (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Memory increment mode"] # [inline (always)] pub const fn set_minc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Peripheral size"] # [must_use] # [inline (always)] pub const fn psize (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Peripheral size"] # [inline (always)] pub const fn set_psize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Memory size"] # [must_use] # [inline (always)] pub const fn msize (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Memory size"] # [inline (always)] pub const fn set_msize (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Channel priority level"] # [must_use] # [inline (always)] pub const fn pl (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "Channel priority level"] # [inline (always)] pub const fn set_pl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "Memory to memory mode"] # [must_use] # [inline (always)] pub const fn mem2mem (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Memory to memory mode"] # [inline (always)] pub const fn set_mem2mem (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Auto-Reload Enable bit"] # [must_use] # [inline (always)] pub const fn are (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Auto-Reload Enable bit"] # [inline (always)] pub const fn set_are (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccr5 { # [inline (always)] fn default () -> Ccr5 { Ccr5 (0) } } impl core :: fmt :: Debug for Ccr5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr5") . field ("en" , & self . en ()) . field ("tcie" , & self . tcie ()) . field ("htie" , & self . htie ()) . field ("teie" , & self . teie ()) . field ("dir" , & self . dir ()) . field ("circ" , & self . circ ()) . field ("pinc" , & self . pinc ()) . field ("minc" , & self . minc ()) . field ("psize" , & self . psize ()) . field ("msize" , & self . msize ()) . field ("pl" , & self . pl ()) . field ("mem2mem" , & self . mem2mem ()) . field ("are" , & self . are ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr5 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr5 {{ en: {=bool:?}, tcie: {=bool:?}, htie: {=bool:?}, teie: {=bool:?}, dir: {=bool:?}, circ: {=bool:?}, pinc: {=bool:?}, minc: {=bool:?}, psize: {=u8:?}, msize: {=u8:?}, pl: {=u8:?}, mem2mem: {=bool:?}, are: {=bool:?} }}" , self . en () , self . tcie () , self . htie () , self . teie () , self . dir () , self . circ () , self . pinc () , self . minc () , self . psize () , self . msize () , self . pl () , self . mem2mem () , self . are ()) } } # [doc = "CMAR1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cmar1 (pub u32) ; impl Cmar1 { # [doc = "Memory address"] # [must_use] # [inline (always)] pub const fn ma (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Memory address"] # [inline (always)] pub const fn set_ma (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cmar1 { # [inline (always)] fn default () -> Cmar1 { Cmar1 (0) } } impl core :: fmt :: Debug for Cmar1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cmar1") . field ("ma" , & self . ma ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cmar1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cmar1 {{ ma: {=u32:?} }}" , self . ma ()) } } # [doc = "CMAR2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cmar2 (pub u32) ; impl Cmar2 { # [doc = "Memory address"] # [must_use] # [inline (always)] pub const fn ma (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Memory address"] # [inline (always)] pub const fn set_ma (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cmar2 { # [inline (always)] fn default () -> Cmar2 { Cmar2 (0) } } impl core :: fmt :: Debug for Cmar2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cmar2") . field ("ma" , & self . ma ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cmar2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cmar2 {{ ma: {=u32:?} }}" , self . ma ()) } } # [doc = "CMAR3"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cmar3 (pub u32) ; impl Cmar3 { # [doc = "Memory address"] # [must_use] # [inline (always)] pub const fn ma (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Memory address"] # [inline (always)] pub const fn set_ma (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cmar3 { # [inline (always)] fn default () -> Cmar3 { Cmar3 (0) } } impl core :: fmt :: Debug for Cmar3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cmar3") . field ("ma" , & self . ma ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cmar3 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cmar3 {{ ma: {=u32:?} }}" , self . ma ()) } } # [doc = "CMAR4"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cmar4 (pub u32) ; impl Cmar4 { # [doc = "Memory address"] # [must_use] # [inline (always)] pub const fn ma (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Memory address"] # [inline (always)] pub const fn set_ma (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cmar4 { # [inline (always)] fn default () -> Cmar4 { Cmar4 (0) } } impl core :: fmt :: Debug for Cmar4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cmar4") . field ("ma" , & self . ma ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cmar4 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cmar4 {{ ma: {=u32:?} }}" , self . ma ()) } } # [doc = "CMAR5"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cmar5 (pub u32) ; impl Cmar5 { # [doc = "Memory address"] # [must_use] # [inline (always)] pub const fn ma (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Memory address"] # [inline (always)] pub const fn set_ma (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cmar5 { # [inline (always)] fn default () -> Cmar5 { Cmar5 (0) } } impl core :: fmt :: Debug for Cmar5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cmar5") . field ("ma" , & self . ma ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cmar5 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cmar5 {{ ma: {=u32:?} }}" , self . ma ()) } } # [doc = "CNDTR1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cndtr1 (pub u32) ; impl Cndtr1 { # [doc = "Number of data to transfer"] # [must_use] # [inline (always)] pub const fn ndt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Number of data to transfer"] # [inline (always)] pub const fn set_ndt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Cndtr1 { # [inline (always)] fn default () -> Cndtr1 { Cndtr1 (0) } } impl core :: fmt :: Debug for Cndtr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cndtr1") . field ("ndt" , & self . ndt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cndtr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cndtr1 {{ ndt: {=u16:?} }}" , self . ndt ()) } } # [doc = "CNDTR2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cndtr2 (pub u32) ; impl Cndtr2 { # [doc = "Number of data to transfer"] # [must_use] # [inline (always)] pub const fn ndt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Number of data to transfer"] # [inline (always)] pub const fn set_ndt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Cndtr2 { # [inline (always)] fn default () -> Cndtr2 { Cndtr2 (0) } } impl core :: fmt :: Debug for Cndtr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cndtr2") . field ("ndt" , & self . ndt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cndtr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cndtr2 {{ ndt: {=u16:?} }}" , self . ndt ()) } } # [doc = "CNDTR3"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cndtr3 (pub u32) ; impl Cndtr3 { # [doc = "Number of data to transfer"] # [must_use] # [inline (always)] pub const fn ndt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Number of data to transfer"] # [inline (always)] pub const fn set_ndt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Cndtr3 { # [inline (always)] fn default () -> Cndtr3 { Cndtr3 (0) } } impl core :: fmt :: Debug for Cndtr3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cndtr3") . field ("ndt" , & self . ndt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cndtr3 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cndtr3 {{ ndt: {=u16:?} }}" , self . ndt ()) } } # [doc = "CNDTR4"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cndtr4 (pub u32) ; impl Cndtr4 { # [doc = "Number of data to transfer"] # [must_use] # [inline (always)] pub const fn ndt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Number of data to transfer"] # [inline (always)] pub const fn set_ndt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Cndtr4 { # [inline (always)] fn default () -> Cndtr4 { Cndtr4 (0) } } impl core :: fmt :: Debug for Cndtr4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cndtr4") . field ("ndt" , & self . ndt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cndtr4 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cndtr4 {{ ndt: {=u16:?} }}" , self . ndt ()) } } # [doc = "CNDTR5"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cndtr5 (pub u32) ; impl Cndtr5 { # [doc = "Number of data to transfer"] # [must_use] # [inline (always)] pub const fn ndt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Number of data to transfer"] # [inline (always)] pub const fn set_ndt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Cndtr5 { # [inline (always)] fn default () -> Cndtr5 { Cndtr5 (0) } } impl core :: fmt :: Debug for Cndtr5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cndtr5") . field ("ndt" , & self . ndt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cndtr5 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cndtr5 {{ ndt: {=u16:?} }}" , self . ndt ()) } } # [doc = "CPAR1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cpar1 (pub u32) ; impl Cpar1 { # [doc = "Peripheral address"] # [must_use] # [inline (always)] pub const fn pa (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Peripheral address"] # [inline (always)] pub const fn set_pa (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cpar1 { # [inline (always)] fn default () -> Cpar1 { Cpar1 (0) } } impl core :: fmt :: Debug for Cpar1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cpar1") . field ("pa" , & self . pa ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cpar1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cpar1 {{ pa: {=u32:?} }}" , self . pa ()) } } # [doc = "CPAR2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cpar2 (pub u32) ; impl Cpar2 { # [doc = "Peripheral address"] # [must_use] # [inline (always)] pub const fn pa (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Peripheral address"] # [inline (always)] pub const fn set_pa (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cpar2 { # [inline (always)] fn default () -> Cpar2 { Cpar2 (0) } } impl core :: fmt :: Debug for Cpar2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cpar2") . field ("pa" , & self . pa ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cpar2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cpar2 {{ pa: {=u32:?} }}" , self . pa ()) } } # [doc = "CPAR3"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cpar3 (pub u32) ; impl Cpar3 { # [doc = "Peripheral address"] # [must_use] # [inline (always)] pub const fn pa (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Peripheral address"] # [inline (always)] pub const fn set_pa (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cpar3 { # [inline (always)] fn default () -> Cpar3 { Cpar3 (0) } } impl core :: fmt :: Debug for Cpar3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cpar3") . field ("pa" , & self . pa ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cpar3 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cpar3 {{ pa: {=u32:?} }}" , self . pa ()) } } # [doc = "CPAR4"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cpar4 (pub u32) ; impl Cpar4 { # [doc = "Peripheral address"] # [must_use] # [inline (always)] pub const fn pa (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Peripheral address"] # [inline (always)] pub const fn set_pa (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cpar4 { # [inline (always)] fn default () -> Cpar4 { Cpar4 (0) } } impl core :: fmt :: Debug for Cpar4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cpar4") . field ("pa" , & self . pa ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cpar4 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cpar4 {{ pa: {=u32:?} }}" , self . pa ()) } } # [doc = "CPAR5"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cpar5 (pub u32) ; impl Cpar5 { # [doc = "Peripheral address"] # [must_use] # [inline (always)] pub const fn pa (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Peripheral address"] # [inline (always)] pub const fn set_pa (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cpar5 { # [inline (always)] fn default () -> Cpar5 { Cpar5 (0) } } impl core :: fmt :: Debug for Cpar5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cpar5") . field ("pa" , & self . pa ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cpar5 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cpar5 {{ pa: {=u32:?} }}" , self . pa ()) } } # [doc = "IFCR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ifcr (pub u32) ; impl Ifcr { # [doc = "channel 1 global interrupt clear"] # [must_use] # [inline (always)] pub const fn cgif1 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "channel 1 global interrupt clear"] # [inline (always)] pub const fn set_cgif1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "channel 1 transfer complete clear"] # [must_use] # [inline (always)] pub const fn ctcif1 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "channel 1 transfer complete clear"] # [inline (always)] pub const fn set_ctcif1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "channel 1 half transfer clear"] # [must_use] # [inline (always)] pub const fn chtif1 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "channel 1 half transfer clear"] # [inline (always)] pub const fn set_chtif1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "channel 1 transfer error clear"] # [must_use] # [inline (always)] pub const fn cteif1 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "channel 1 transfer error clear"] # [inline (always)] pub const fn set_cteif1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "channel 2 global interrupt clear"] # [must_use] # [inline (always)] pub const fn cgif2 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "channel 2 global interrupt clear"] # [inline (always)] pub const fn set_cgif2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "channel 2 transfer complete clear"] # [must_use] # [inline (always)] pub const fn ctcif2 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "channel 2 transfer complete clear"] # [inline (always)] pub const fn set_ctcif2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "channel 2 half transfer clear"] # [must_use] # [inline (always)] pub const fn chtif2 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "channel 2 half transfer clear"] # [inline (always)] pub const fn set_chtif2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "channel 2 transfer error clear"] # [must_use] # [inline (always)] pub const fn cteif2 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "channel 2 transfer error clear"] # [inline (always)] pub const fn set_cteif2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "channel 3 global interrupt clear"] # [must_use] # [inline (always)] pub const fn cgif3 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "channel 3 global interrupt clear"] # [inline (always)] pub const fn set_cgif3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "channel 3 transfer complete clear"] # [must_use] # [inline (always)] pub const fn ctcif3 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "channel 3 transfer complete clear"] # [inline (always)] pub const fn set_ctcif3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "channel 3 half transfer clear"] # [must_use] # [inline (always)] pub const fn chtif3 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "channel 3 half transfer clear"] # [inline (always)] pub const fn set_chtif3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "channel 3 transfer error clear"] # [must_use] # [inline (always)] pub const fn cteif3 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "channel 3 transfer error clear"] # [inline (always)] pub const fn set_cteif3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "channel 4 global interrupt clear"] # [must_use] # [inline (always)] pub const fn cgif4 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "channel 4 global interrupt clear"] # [inline (always)] pub const fn set_cgif4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "channel 4 transfer complete clear"] # [must_use] # [inline (always)] pub const fn ctcif4 (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "channel 4 transfer complete clear"] # [inline (always)] pub const fn set_ctcif4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "channel 4 half transfer clear"] # [must_use] # [inline (always)] pub const fn chtif4 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "channel 4 half transfer clear"] # [inline (always)] pub const fn set_chtif4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "channel 4 transfer error clear"] # [must_use] # [inline (always)] pub const fn cteif4 (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "channel 4 transfer error clear"] # [inline (always)] pub const fn set_cteif4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "channel 5 global interrupt clear"] # [must_use] # [inline (always)] pub const fn cgif5 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "channel 5 global interrupt clear"] # [inline (always)] pub const fn set_cgif5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "channel 5 transfer complete clear"] # [must_use] # [inline (always)] pub const fn ctcif5 (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "channel 5 transfer complete clear"] # [inline (always)] pub const fn set_ctcif5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "channel 5 half transfer clear"] # [must_use] # [inline (always)] pub const fn chtif5 (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "channel 5 half transfer clear"] # [inline (always)] pub const fn set_chtif5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "channel 5 transfer error clear"] # [must_use] # [inline (always)] pub const fn cteif5 (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "channel 5 transfer error clear"] # [inline (always)] pub const fn set_cteif5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } } impl Default for Ifcr { # [inline (always)] fn default () -> Ifcr { Ifcr (0) } } impl core :: fmt :: Debug for Ifcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ifcr") . field ("cgif1" , & self . cgif1 ()) . field ("ctcif1" , & self . ctcif1 ()) . field ("chtif1" , & self . chtif1 ()) . field ("cteif1" , & self . cteif1 ()) . field ("cgif2" , & self . cgif2 ()) . field ("ctcif2" , & self . ctcif2 ()) . field ("chtif2" , & self . chtif2 ()) . field ("cteif2" , & self . cteif2 ()) . field ("cgif3" , & self . cgif3 ()) . field ("ctcif3" , & self . ctcif3 ()) . field ("chtif3" , & self . chtif3 ()) . field ("cteif3" , & self . cteif3 ()) . field ("cgif4" , & self . cgif4 ()) . field ("ctcif4" , & self . ctcif4 ()) . field ("chtif4" , & self . chtif4 ()) . field ("cteif4" , & self . cteif4 ()) . field ("cgif5" , & self . cgif5 ()) . field ("ctcif5" , & self . ctcif5 ()) . field ("chtif5" , & self . chtif5 ()) . field ("cteif5" , & self . cteif5 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ifcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ifcr {{ cgif1: {=bool:?}, ctcif1: {=bool:?}, chtif1: {=bool:?}, cteif1: {=bool:?}, cgif2: {=bool:?}, ctcif2: {=bool:?}, chtif2: {=bool:?}, cteif2: {=bool:?}, cgif3: {=bool:?}, ctcif3: {=bool:?}, chtif3: {=bool:?}, cteif3: {=bool:?}, cgif4: {=bool:?}, ctcif4: {=bool:?}, chtif4: {=bool:?}, cteif4: {=bool:?}, cgif5: {=bool:?}, ctcif5: {=bool:?}, chtif5: {=bool:?}, cteif5: {=bool:?} }}" , self . cgif1 () , self . ctcif1 () , self . chtif1 () , self . cteif1 () , self . cgif2 () , self . ctcif2 () , self . chtif2 () , self . cteif2 () , self . cgif3 () , self . ctcif3 () , self . chtif3 () , self . cteif3 () , self . cgif4 () , self . ctcif4 () , self . chtif4 () , self . cteif4 () , self . cgif5 () , self . ctcif5 () , self . chtif5 () , self . cteif5 ()) } } # [doc = "ISR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Isr (pub u32) ; impl Isr { # [doc = "channel 1 global interrupt flag"] # [must_use] # [inline (always)] pub const fn gif1 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "channel 1 global interrupt flag"] # [inline (always)] pub const fn set_gif1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "channel 1 transfer complete flag"] # [must_use] # [inline (always)] pub const fn tcif1 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "channel 1 transfer complete flag"] # [inline (always)] pub const fn set_tcif1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "channel 1 half transfer flag"] # [must_use] # [inline (always)] pub const fn htif1 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "channel 1 half transfer flag"] # [inline (always)] pub const fn set_htif1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "channel 1 transfer error flag"] # [must_use] # [inline (always)] pub const fn teif1 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "channel 1 transfer error flag"] # [inline (always)] pub const fn set_teif1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "channel 2 global interrupt flag"] # [must_use] # [inline (always)] pub const fn gif2 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "channel 2 global interrupt flag"] # [inline (always)] pub const fn set_gif2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "channel 2 transfer complete flag"] # [must_use] # [inline (always)] pub const fn tcif2 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "channel 2 transfer complete flag"] # [inline (always)] pub const fn set_tcif2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "channel 2 half transfer flag"] # [must_use] # [inline (always)] pub const fn htif2 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "channel 2 half transfer flag"] # [inline (always)] pub const fn set_htif2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "channel 2 transfer error flag"] # [must_use] # [inline (always)] pub const fn teif2 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "channel 2 transfer error flag"] # [inline (always)] pub const fn set_teif2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "channel 3 global interrupt flag"] # [must_use] # [inline (always)] pub const fn gif3 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "channel 3 global interrupt flag"] # [inline (always)] pub const fn set_gif3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "channel 3 transfer complete flag"] # [must_use] # [inline (always)] pub const fn tcif3 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "channel 3 transfer complete flag"] # [inline (always)] pub const fn set_tcif3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "channel 3 half transfer flag"] # [must_use] # [inline (always)] pub const fn htif3 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "channel 3 half transfer flag"] # [inline (always)] pub const fn set_htif3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "channel 3 transfer error flag"] # [must_use] # [inline (always)] pub const fn teif3 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "channel 3 transfer error flag"] # [inline (always)] pub const fn set_teif3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "channel 4 global interrupt flag"] # [must_use] # [inline (always)] pub const fn gif4 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "channel 4 global interrupt flag"] # [inline (always)] pub const fn set_gif4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "channel 4 transfer complete flag"] # [must_use] # [inline (always)] pub const fn tcif4 (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "channel 4 transfer complete flag"] # [inline (always)] pub const fn set_tcif4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "channel 4 half transfer flag"] # [must_use] # [inline (always)] pub const fn htif4 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "channel 4 half transfer flag"] # [inline (always)] pub const fn set_htif4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "channel 4 transfer error flag"] # [must_use] # [inline (always)] pub const fn teif4 (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "channel 4 transfer error flag"] # [inline (always)] pub const fn set_teif4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "channel 5 global interrupt flag"] # [must_use] # [inline (always)] pub const fn gif5 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "channel 5 global interrupt flag"] # [inline (always)] pub const fn set_gif5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "channel 5 transfer complete flag"] # [must_use] # [inline (always)] pub const fn tcif5 (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "channel 5 transfer complete flag"] # [inline (always)] pub const fn set_tcif5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "channel 5 half transfer flag"] # [must_use] # [inline (always)] pub const fn htif5 (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "channel 5 half transfer flag"] # [inline (always)] pub const fn set_htif5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "channel 5 transfer error flag"] # [must_use] # [inline (always)] pub const fn teif5 (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "channel 5 transfer error flag"] # [inline (always)] pub const fn set_teif5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } } impl Default for Isr { # [inline (always)] fn default () -> Isr { Isr (0) } } impl core :: fmt :: Debug for Isr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Isr") . field ("gif1" , & self . gif1 ()) . field ("tcif1" , & self . tcif1 ()) . field ("htif1" , & self . htif1 ()) . field ("teif1" , & self . teif1 ()) . field ("gif2" , & self . gif2 ()) . field ("tcif2" , & self . tcif2 ()) . field ("htif2" , & self . htif2 ()) . field ("teif2" , & self . teif2 ()) . field ("gif3" , & self . gif3 ()) . field ("tcif3" , & self . tcif3 ()) . field ("htif3" , & self . htif3 ()) . field ("teif3" , & self . teif3 ()) . field ("gif4" , & self . gif4 ()) . field ("tcif4" , & self . tcif4 ()) . field ("htif4" , & self . htif4 ()) . field ("teif4" , & self . teif4 ()) . field ("gif5" , & self . gif5 ()) . field ("tcif5" , & self . tcif5 ()) . field ("htif5" , & self . htif5 ()) . field ("teif5" , & self . teif5 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Isr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Isr {{ gif1: {=bool:?}, tcif1: {=bool:?}, htif1: {=bool:?}, teif1: {=bool:?}, gif2: {=bool:?}, tcif2: {=bool:?}, htif2: {=bool:?}, teif2: {=bool:?}, gif3: {=bool:?}, tcif3: {=bool:?}, htif3: {=bool:?}, teif3: {=bool:?}, gif4: {=bool:?}, tcif4: {=bool:?}, htif4: {=bool:?}, teif4: {=bool:?}, gif5: {=bool:?}, tcif5: {=bool:?}, htif5: {=bool:?}, teif5: {=bool:?} }}" , self . gif1 () , self . tcif1 () , self . htif1 () , self . teif1 () , self . gif2 () , self . tcif2 () , self . htif2 () , self . teif2 () , self . gif3 () , self . tcif3 () , self . htif3 () , self . teif3 () , self . gif4 () , self . tcif4 () , self . htif4 () , self . teif4 () , self . gif5 () , self . tcif5 () , self . htif5 () , self . teif5 ()) } } } } pub mod exti { # [doc = "External interrupt/event controller"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Exti { ptr : * mut u8 } unsafe impl Send for Exti { } unsafe impl Sync for Exti { } impl Exti { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Configuration register"] # [inline (always)] pub const fn cfgr (self) -> crate :: common :: Reg < regs :: Cfgr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "External interrupt configuration register 1"] # [inline (always)] pub const fn cr1 (self) -> crate :: common :: Reg < regs :: Cr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "External interrupt configuration register 2"] # [inline (always)] pub const fn cr2 (self) -> crate :: common :: Reg < regs :: Cr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "External interrupt configuration register 3"] # [inline (always)] pub const fn cr3 (self) -> crate :: common :: Reg < regs :: Cr3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "External interrupt configuration register 4"] # [inline (always)] pub const fn cr4 (self) -> crate :: common :: Reg < regs :: Cr4 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "Interrupt mask register"] # [inline (always)] pub const fn imr (self) -> crate :: common :: Reg < regs :: Imr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0400usize) as _) } } # [doc = "Event mask register"] # [inline (always)] pub const fn emr (self) -> crate :: common :: Reg < regs :: Emr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0404usize) as _) } } # [doc = "Rising trigger selection register"] # [inline (always)] pub const fn rtsr (self) -> crate :: common :: Reg < regs :: Rtsr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0408usize) as _) } } # [doc = "Falling trigger selection register"] # [inline (always)] pub const fn ftsr (self) -> crate :: common :: Reg < regs :: Ftsr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x040cusize) as _) } } # [doc = "Software interrupt event register"] # [inline (always)] pub const fn swier (self) -> crate :: common :: Reg < regs :: Swier , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0410usize) as _) } } # [doc = "Pending register"] # [inline (always)] pub const fn pr (self) -> crate :: common :: Reg < regs :: Pr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0414usize) as _) } } } pub mod regs { # [doc = "Configuration register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cfgr (pub u32) ; impl Cfgr { # [doc = "MEM_MODE"] # [must_use] # [inline (always)] pub const fn mem_mode (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "MEM_MODE"] # [inline (always)] pub const fn set_mem_mode (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "ADC_DMA_RMP"] # [must_use] # [inline (always)] pub const fn adc_dma (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "ADC_DMA_RMP"] # [inline (always)] pub const fn set_adc_dma (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "UART1_TX_DMA_RMP"] # [must_use] # [inline (always)] pub const fn uart1_tx_dma (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "UART1_TX_DMA_RMP"] # [inline (always)] pub const fn set_uart1_tx_dma (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "UART1_RX_DMA_RMP"] # [must_use] # [inline (always)] pub const fn uart1_rx_dma (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "UART1_RX_DMA_RMP"] # [inline (always)] pub const fn set_uart1_rx_dma (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "TIM16_DMA_RMP"] # [must_use] # [inline (always)] pub const fn tim16_dma (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "TIM16_DMA_RMP"] # [inline (always)] pub const fn set_tim16_dma (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "TIM17_DMA_RMP"] # [must_use] # [inline (always)] pub const fn tim17_dma (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "TIM17_DMA_RMP"] # [inline (always)] pub const fn set_tim17_dma (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Cfgr { # [inline (always)] fn default () -> Cfgr { Cfgr (0) } } impl core :: fmt :: Debug for Cfgr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cfgr") . field ("mem_mode" , & self . mem_mode ()) . field ("adc_dma" , & self . adc_dma ()) . field ("uart1_tx_dma" , & self . uart1_tx_dma ()) . field ("uart1_rx_dma" , & self . uart1_rx_dma ()) . field ("tim16_dma" , & self . tim16_dma ()) . field ("tim17_dma" , & self . tim17_dma ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cfgr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cfgr {{ mem_mode: {=u8:?}, adc_dma: {=bool:?}, uart1_tx_dma: {=bool:?}, uart1_rx_dma: {=bool:?}, tim16_dma: {=bool:?}, tim17_dma: {=bool:?} }}" , self . mem_mode () , self . adc_dma () , self . uart1_tx_dma () , self . uart1_rx_dma () , self . tim16_dma () , self . tim17_dma ()) } } # [doc = "External interrupt configuration register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr1 (pub u32) ; impl Cr1 { # [doc = "EXTI0 configuration"] # [must_use] # [inline (always)] pub const fn exti0 (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "EXTI0 configuration"] # [inline (always)] pub const fn set_exti0 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "EXTI1 configuration"] # [must_use] # [inline (always)] pub const fn exti1 (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "EXTI1 configuration"] # [inline (always)] pub const fn set_exti1 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "EXTI2 configuration"] # [must_use] # [inline (always)] pub const fn exti2 (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "EXTI2 configuration"] # [inline (always)] pub const fn set_exti2 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "EXTI3 configuration"] # [must_use] # [inline (always)] pub const fn exti3 (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "EXTI3 configuration"] # [inline (always)] pub const fn set_exti3 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Cr1 { # [inline (always)] fn default () -> Cr1 { Cr1 (0) } } impl core :: fmt :: Debug for Cr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr1") . field ("exti0" , & self . exti0 ()) . field ("exti1" , & self . exti1 ()) . field ("exti2" , & self . exti2 ()) . field ("exti3" , & self . exti3 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr1 {{ exti0: {=u8:?}, exti1: {=u8:?}, exti2: {=u8:?}, exti3: {=u8:?} }}" , self . exti0 () , self . exti1 () , self . exti2 () , self . exti3 ()) } } # [doc = "External interrupt configuration register 2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr2 (pub u32) ; impl Cr2 { # [doc = "EXTI4 configuration"] # [must_use] # [inline (always)] pub const fn exti4 (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "EXTI4 configuration"] # [inline (always)] pub const fn set_exti4 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "EXTI5 configuration"] # [must_use] # [inline (always)] pub const fn exti5 (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "EXTI5 configuration"] # [inline (always)] pub const fn set_exti5 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "EXTI6 configuration"] # [must_use] # [inline (always)] pub const fn exti6 (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "EXTI6 configuration"] # [inline (always)] pub const fn set_exti6 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "EXTI7 configuration"] # [must_use] # [inline (always)] pub const fn exti7 (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "EXTI7 configuration"] # [inline (always)] pub const fn set_exti7 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Cr2 { # [inline (always)] fn default () -> Cr2 { Cr2 (0) } } impl core :: fmt :: Debug for Cr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr2") . field ("exti4" , & self . exti4 ()) . field ("exti5" , & self . exti5 ()) . field ("exti6" , & self . exti6 ()) . field ("exti7" , & self . exti7 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr2 {{ exti4: {=u8:?}, exti5: {=u8:?}, exti6: {=u8:?}, exti7: {=u8:?} }}" , self . exti4 () , self . exti5 () , self . exti6 () , self . exti7 ()) } } # [doc = "External interrupt configuration register 3"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr3 (pub u32) ; impl Cr3 { # [doc = "EXTI8 configuration"] # [must_use] # [inline (always)] pub const fn exti8 (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "EXTI8 configuration"] # [inline (always)] pub const fn set_exti8 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "EXTI9 configuration"] # [must_use] # [inline (always)] pub const fn exti9 (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "EXTI9 configuration"] # [inline (always)] pub const fn set_exti9 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "EXTI10 configuration"] # [must_use] # [inline (always)] pub const fn exti10 (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "EXTI10 configuration"] # [inline (always)] pub const fn set_exti10 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "EXTI11 configuration"] # [must_use] # [inline (always)] pub const fn exti11 (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "EXTI11 configuration"] # [inline (always)] pub const fn set_exti11 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Cr3 { # [inline (always)] fn default () -> Cr3 { Cr3 (0) } } impl core :: fmt :: Debug for Cr3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr3") . field ("exti8" , & self . exti8 ()) . field ("exti9" , & self . exti9 ()) . field ("exti10" , & self . exti10 ()) . field ("exti11" , & self . exti11 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr3 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr3 {{ exti8: {=u8:?}, exti9: {=u8:?}, exti10: {=u8:?}, exti11: {=u8:?} }}" , self . exti8 () , self . exti9 () , self . exti10 () , self . exti11 ()) } } # [doc = "External interrupt configuration register 4"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr4 (pub u32) ; impl Cr4 { # [doc = "EXTI12 configuration"] # [must_use] # [inline (always)] pub const fn exti12 (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "EXTI12 configuration"] # [inline (always)] pub const fn set_exti12 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "EXTI13 configuration"] # [must_use] # [inline (always)] pub const fn exti13 (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "EXTI13 configuration"] # [inline (always)] pub const fn set_exti13 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "EXTI14 configuration"] # [must_use] # [inline (always)] pub const fn exti14 (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "EXTI14 configuration"] # [inline (always)] pub const fn set_exti14 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "EXTI15 configuration"] # [must_use] # [inline (always)] pub const fn exti15 (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "EXTI15 configuration"] # [inline (always)] pub const fn set_exti15 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Cr4 { # [inline (always)] fn default () -> Cr4 { Cr4 (0) } } impl core :: fmt :: Debug for Cr4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr4") . field ("exti12" , & self . exti12 ()) . field ("exti13" , & self . exti13 ()) . field ("exti14" , & self . exti14 ()) . field ("exti15" , & self . exti15 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr4 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr4 {{ exti12: {=u8:?}, exti13: {=u8:?}, exti14: {=u8:?}, exti15: {=u8:?} }}" , self . exti12 () , self . exti13 () , self . exti14 () , self . exti15 ()) } } # [doc = "Event mask register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Emr (pub u32) ; impl Emr { # [doc = "Event Mask on line 0"] # [must_use] # [inline (always)] pub const fn emr0 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 0"] # [inline (always)] pub const fn set_emr0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Event Mask on line 1"] # [must_use] # [inline (always)] pub const fn emr1 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 1"] # [inline (always)] pub const fn set_emr1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Event Mask on line 2"] # [must_use] # [inline (always)] pub const fn emr2 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 2"] # [inline (always)] pub const fn set_emr2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Event Mask on line 3"] # [must_use] # [inline (always)] pub const fn emr3 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 3"] # [inline (always)] pub const fn set_emr3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Event Mask on line 4"] # [must_use] # [inline (always)] pub const fn emr4 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 4"] # [inline (always)] pub const fn set_emr4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Event Mask on line 5"] # [must_use] # [inline (always)] pub const fn emr5 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 5"] # [inline (always)] pub const fn set_emr5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Event Mask on line 6"] # [must_use] # [inline (always)] pub const fn emr6 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 6"] # [inline (always)] pub const fn set_emr6 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Event Mask on line 7"] # [must_use] # [inline (always)] pub const fn emr7 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 7"] # [inline (always)] pub const fn set_emr7 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Event Mask on line 8"] # [must_use] # [inline (always)] pub const fn emr8 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 8"] # [inline (always)] pub const fn set_emr8 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Event Mask on line 9"] # [must_use] # [inline (always)] pub const fn emr9 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 9"] # [inline (always)] pub const fn set_emr9 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Event Mask on line 10"] # [must_use] # [inline (always)] pub const fn emr10 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 10"] # [inline (always)] pub const fn set_emr10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Event Mask on line 11"] # [must_use] # [inline (always)] pub const fn emr11 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 11"] # [inline (always)] pub const fn set_emr11 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Event Mask on line 12"] # [must_use] # [inline (always)] pub const fn emr12 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 12"] # [inline (always)] pub const fn set_emr12 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Event Mask on line 13"] # [must_use] # [inline (always)] pub const fn emr13 (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 13"] # [inline (always)] pub const fn set_emr13 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Event Mask on line 14"] # [must_use] # [inline (always)] pub const fn emr14 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 14"] # [inline (always)] pub const fn set_emr14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Event Mask on line 15"] # [must_use] # [inline (always)] pub const fn emr15 (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 15"] # [inline (always)] pub const fn set_emr15 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "Event Mask on line 16"] # [must_use] # [inline (always)] pub const fn emr16 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 16"] # [inline (always)] pub const fn set_emr16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Event Mask on line 19"] # [must_use] # [inline (always)] pub const fn emr19 (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 19"] # [inline (always)] pub const fn set_emr19 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "Event Mask on line 24"] # [must_use] # [inline (always)] pub const fn emr24 (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Event Mask on line 24"] # [inline (always)] pub const fn set_emr24 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } } impl Default for Emr { # [inline (always)] fn default () -> Emr { Emr (0) } } impl core :: fmt :: Debug for Emr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Emr") . field ("emr0" , & self . emr0 ()) . field ("emr1" , & self . emr1 ()) . field ("emr2" , & self . emr2 ()) . field ("emr3" , & self . emr3 ()) . field ("emr4" , & self . emr4 ()) . field ("emr5" , & self . emr5 ()) . field ("emr6" , & self . emr6 ()) . field ("emr7" , & self . emr7 ()) . field ("emr8" , & self . emr8 ()) . field ("emr9" , & self . emr9 ()) . field ("emr10" , & self . emr10 ()) . field ("emr11" , & self . emr11 ()) . field ("emr12" , & self . emr12 ()) . field ("emr13" , & self . emr13 ()) . field ("emr14" , & self . emr14 ()) . field ("emr15" , & self . emr15 ()) . field ("emr16" , & self . emr16 ()) . field ("emr19" , & self . emr19 ()) . field ("emr24" , & self . emr24 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Emr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Emr {{ emr0: {=bool:?}, emr1: {=bool:?}, emr2: {=bool:?}, emr3: {=bool:?}, emr4: {=bool:?}, emr5: {=bool:?}, emr6: {=bool:?}, emr7: {=bool:?}, emr8: {=bool:?}, emr9: {=bool:?}, emr10: {=bool:?}, emr11: {=bool:?}, emr12: {=bool:?}, emr13: {=bool:?}, emr14: {=bool:?}, emr15: {=bool:?}, emr16: {=bool:?}, emr19: {=bool:?}, emr24: {=bool:?} }}" , self . emr0 () , self . emr1 () , self . emr2 () , self . emr3 () , self . emr4 () , self . emr5 () , self . emr6 () , self . emr7 () , self . emr8 () , self . emr9 () , self . emr10 () , self . emr11 () , self . emr12 () , self . emr13 () , self . emr14 () , self . emr15 () , self . emr16 () , self . emr19 () , self . emr24 ()) } } # [doc = "Falling trigger selection register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ftsr (pub u32) ; impl Ftsr { # [doc = "Falling trigger event configuration bit of line 0"] # [must_use] # [inline (always)] pub const fn tr0 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 0"] # [inline (always)] pub const fn set_tr0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Falling trigger event configuration bit of line 1"] # [must_use] # [inline (always)] pub const fn tr1 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 1"] # [inline (always)] pub const fn set_tr1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Falling trigger event configuration bit of line 2"] # [must_use] # [inline (always)] pub const fn tr2 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 2"] # [inline (always)] pub const fn set_tr2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Falling trigger event configuration bit of line 3"] # [must_use] # [inline (always)] pub const fn tr3 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 3"] # [inline (always)] pub const fn set_tr3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Falling trigger event configuration bit of line 4"] # [must_use] # [inline (always)] pub const fn tr4 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 4"] # [inline (always)] pub const fn set_tr4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Falling trigger event configuration bit of line 5"] # [must_use] # [inline (always)] pub const fn tr5 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 5"] # [inline (always)] pub const fn set_tr5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Falling trigger event configuration bit of line 6"] # [must_use] # [inline (always)] pub const fn tr6 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 6"] # [inline (always)] pub const fn set_tr6 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Falling trigger event configuration bit of line 7"] # [must_use] # [inline (always)] pub const fn tr7 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 7"] # [inline (always)] pub const fn set_tr7 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Falling trigger event configuration bit of line 8"] # [must_use] # [inline (always)] pub const fn tr8 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 8"] # [inline (always)] pub const fn set_tr8 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Falling trigger event configuration bit of line 9"] # [must_use] # [inline (always)] pub const fn tr9 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 9"] # [inline (always)] pub const fn set_tr9 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Falling trigger event configuration bit of line 10"] # [must_use] # [inline (always)] pub const fn tr10 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 10"] # [inline (always)] pub const fn set_tr10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Falling trigger event configuration bit of line 11"] # [must_use] # [inline (always)] pub const fn tr11 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 11"] # [inline (always)] pub const fn set_tr11 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Falling trigger event configuration bit of line 12"] # [must_use] # [inline (always)] pub const fn tr12 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 12"] # [inline (always)] pub const fn set_tr12 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Falling trigger event configuration bit of line 13"] # [must_use] # [inline (always)] pub const fn tr13 (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 13"] # [inline (always)] pub const fn set_tr13 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Falling trigger event configuration bit of line 14"] # [must_use] # [inline (always)] pub const fn tr14 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 14"] # [inline (always)] pub const fn set_tr14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Falling trigger event configuration bit of line 15"] # [must_use] # [inline (always)] pub const fn tr15 (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 15"] # [inline (always)] pub const fn set_tr15 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "Falling trigger event configuration bit of line 16"] # [must_use] # [inline (always)] pub const fn tr16 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 16"] # [inline (always)] pub const fn set_tr16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Falling trigger event configuration bit of line 19"] # [must_use] # [inline (always)] pub const fn tr19 (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 19"] # [inline (always)] pub const fn set_tr19 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "Falling trigger event configuration bit of line 24"] # [must_use] # [inline (always)] pub const fn tr24 (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Falling trigger event configuration bit of line 24"] # [inline (always)] pub const fn set_tr24 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } } impl Default for Ftsr { # [inline (always)] fn default () -> Ftsr { Ftsr (0) } } impl core :: fmt :: Debug for Ftsr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ftsr") . field ("tr0" , & self . tr0 ()) . field ("tr1" , & self . tr1 ()) . field ("tr2" , & self . tr2 ()) . field ("tr3" , & self . tr3 ()) . field ("tr4" , & self . tr4 ()) . field ("tr5" , & self . tr5 ()) . field ("tr6" , & self . tr6 ()) . field ("tr7" , & self . tr7 ()) . field ("tr8" , & self . tr8 ()) . field ("tr9" , & self . tr9 ()) . field ("tr10" , & self . tr10 ()) . field ("tr11" , & self . tr11 ()) . field ("tr12" , & self . tr12 ()) . field ("tr13" , & self . tr13 ()) . field ("tr14" , & self . tr14 ()) . field ("tr15" , & self . tr15 ()) . field ("tr16" , & self . tr16 ()) . field ("tr19" , & self . tr19 ()) . field ("tr24" , & self . tr24 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ftsr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ftsr {{ tr0: {=bool:?}, tr1: {=bool:?}, tr2: {=bool:?}, tr3: {=bool:?}, tr4: {=bool:?}, tr5: {=bool:?}, tr6: {=bool:?}, tr7: {=bool:?}, tr8: {=bool:?}, tr9: {=bool:?}, tr10: {=bool:?}, tr11: {=bool:?}, tr12: {=bool:?}, tr13: {=bool:?}, tr14: {=bool:?}, tr15: {=bool:?}, tr16: {=bool:?}, tr19: {=bool:?}, tr24: {=bool:?} }}" , self . tr0 () , self . tr1 () , self . tr2 () , self . tr3 () , self . tr4 () , self . tr5 () , self . tr6 () , self . tr7 () , self . tr8 () , self . tr9 () , self . tr10 () , self . tr11 () , self . tr12 () , self . tr13 () , self . tr14 () , self . tr15 () , self . tr16 () , self . tr19 () , self . tr24 ()) } } # [doc = "Interrupt mask register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Imr (pub u32) ; impl Imr { # [doc = "Interrupt Mask on line 0"] # [must_use] # [inline (always)] pub const fn imr0 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 0"] # [inline (always)] pub const fn set_imr0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Interrupt Mask on line 1"] # [must_use] # [inline (always)] pub const fn imr1 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 1"] # [inline (always)] pub const fn set_imr1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Interrupt Mask on line 2"] # [must_use] # [inline (always)] pub const fn imr2 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 2"] # [inline (always)] pub const fn set_imr2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Interrupt Mask on line 3"] # [must_use] # [inline (always)] pub const fn imr3 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 3"] # [inline (always)] pub const fn set_imr3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Interrupt Mask on line 4"] # [must_use] # [inline (always)] pub const fn imr4 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 4"] # [inline (always)] pub const fn set_imr4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Interrupt Mask on line 5"] # [must_use] # [inline (always)] pub const fn imr5 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 5"] # [inline (always)] pub const fn set_imr5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Interrupt Mask on line 6"] # [must_use] # [inline (always)] pub const fn imr6 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 6"] # [inline (always)] pub const fn set_imr6 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Interrupt Mask on line 7"] # [must_use] # [inline (always)] pub const fn imr7 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 7"] # [inline (always)] pub const fn set_imr7 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Interrupt Mask on line 8"] # [must_use] # [inline (always)] pub const fn imr8 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 8"] # [inline (always)] pub const fn set_imr8 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Interrupt Mask on line 9"] # [must_use] # [inline (always)] pub const fn imr9 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 9"] # [inline (always)] pub const fn set_imr9 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Interrupt Mask on line 10"] # [must_use] # [inline (always)] pub const fn imr10 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 10"] # [inline (always)] pub const fn set_imr10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Interrupt Mask on line 11"] # [must_use] # [inline (always)] pub const fn imr11 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 11"] # [inline (always)] pub const fn set_imr11 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Interrupt Mask on line 12"] # [must_use] # [inline (always)] pub const fn imr12 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 12"] # [inline (always)] pub const fn set_imr12 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Interrupt Mask on line 13"] # [must_use] # [inline (always)] pub const fn imr13 (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 13"] # [inline (always)] pub const fn set_imr13 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Interrupt Mask on line 14"] # [must_use] # [inline (always)] pub const fn imr14 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 14"] # [inline (always)] pub const fn set_imr14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Interrupt Mask on line 15"] # [must_use] # [inline (always)] pub const fn imr15 (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 15"] # [inline (always)] pub const fn set_imr15 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "Interrupt Mask on line 16"] # [must_use] # [inline (always)] pub const fn imr16 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 16"] # [inline (always)] pub const fn set_imr16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Interrupt Mask on line 19"] # [must_use] # [inline (always)] pub const fn imr19 (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 19"] # [inline (always)] pub const fn set_imr19 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "Interrupt Mask on line 24"] # [must_use] # [inline (always)] pub const fn imr24 (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Interrupt Mask on line 24"] # [inline (always)] pub const fn set_imr24 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } } impl Default for Imr { # [inline (always)] fn default () -> Imr { Imr (0) } } impl core :: fmt :: Debug for Imr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Imr") . field ("imr0" , & self . imr0 ()) . field ("imr1" , & self . imr1 ()) . field ("imr2" , & self . imr2 ()) . field ("imr3" , & self . imr3 ()) . field ("imr4" , & self . imr4 ()) . field ("imr5" , & self . imr5 ()) . field ("imr6" , & self . imr6 ()) . field ("imr7" , & self . imr7 ()) . field ("imr8" , & self . imr8 ()) . field ("imr9" , & self . imr9 ()) . field ("imr10" , & self . imr10 ()) . field ("imr11" , & self . imr11 ()) . field ("imr12" , & self . imr12 ()) . field ("imr13" , & self . imr13 ()) . field ("imr14" , & self . imr14 ()) . field ("imr15" , & self . imr15 ()) . field ("imr16" , & self . imr16 ()) . field ("imr19" , & self . imr19 ()) . field ("imr24" , & self . imr24 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Imr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Imr {{ imr0: {=bool:?}, imr1: {=bool:?}, imr2: {=bool:?}, imr3: {=bool:?}, imr4: {=bool:?}, imr5: {=bool:?}, imr6: {=bool:?}, imr7: {=bool:?}, imr8: {=bool:?}, imr9: {=bool:?}, imr10: {=bool:?}, imr11: {=bool:?}, imr12: {=bool:?}, imr13: {=bool:?}, imr14: {=bool:?}, imr15: {=bool:?}, imr16: {=bool:?}, imr19: {=bool:?}, imr24: {=bool:?} }}" , self . imr0 () , self . imr1 () , self . imr2 () , self . imr3 () , self . imr4 () , self . imr5 () , self . imr6 () , self . imr7 () , self . imr8 () , self . imr9 () , self . imr10 () , self . imr11 () , self . imr12 () , self . imr13 () , self . imr14 () , self . imr15 () , self . imr16 () , self . imr19 () , self . imr24 ()) } } # [doc = "Pending register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Pr (pub u32) ; impl Pr { # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr0 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr1 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr2 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr3 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr4 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr5 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr6 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr6 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr7 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr7 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr8 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr8 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr9 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr9 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr10 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr11 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr11 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr12 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr12 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr13 (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr13 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr14 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr15 (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr15 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr16 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr19 (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr19 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "Pending bit"] # [must_use] # [inline (always)] pub const fn pr24 (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Pending bit"] # [inline (always)] pub const fn set_pr24 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } } impl Default for Pr { # [inline (always)] fn default () -> Pr { Pr (0) } } impl core :: fmt :: Debug for Pr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pr") . field ("pr0" , & self . pr0 ()) . field ("pr1" , & self . pr1 ()) . field ("pr2" , & self . pr2 ()) . field ("pr3" , & self . pr3 ()) . field ("pr4" , & self . pr4 ()) . field ("pr5" , & self . pr5 ()) . field ("pr6" , & self . pr6 ()) . field ("pr7" , & self . pr7 ()) . field ("pr8" , & self . pr8 ()) . field ("pr9" , & self . pr9 ()) . field ("pr10" , & self . pr10 ()) . field ("pr11" , & self . pr11 ()) . field ("pr12" , & self . pr12 ()) . field ("pr13" , & self . pr13 ()) . field ("pr14" , & self . pr14 ()) . field ("pr15" , & self . pr15 ()) . field ("pr16" , & self . pr16 ()) . field ("pr19" , & self . pr19 ()) . field ("pr24" , & self . pr24 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Pr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Pr {{ pr0: {=bool:?}, pr1: {=bool:?}, pr2: {=bool:?}, pr3: {=bool:?}, pr4: {=bool:?}, pr5: {=bool:?}, pr6: {=bool:?}, pr7: {=bool:?}, pr8: {=bool:?}, pr9: {=bool:?}, pr10: {=bool:?}, pr11: {=bool:?}, pr12: {=bool:?}, pr13: {=bool:?}, pr14: {=bool:?}, pr15: {=bool:?}, pr16: {=bool:?}, pr19: {=bool:?}, pr24: {=bool:?} }}" , self . pr0 () , self . pr1 () , self . pr2 () , self . pr3 () , self . pr4 () , self . pr5 () , self . pr6 () , self . pr7 () , self . pr8 () , self . pr9 () , self . pr10 () , self . pr11 () , self . pr12 () , self . pr13 () , self . pr14 () , self . pr15 () , self . pr16 () , self . pr19 () , self . pr24 ()) } } # [doc = "Rising trigger selection register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rtsr (pub u32) ; impl Rtsr { # [doc = "Rising trigger event configuration bit of line 0"] # [must_use] # [inline (always)] pub const fn tr0 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 0"] # [inline (always)] pub const fn set_tr0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Rising trigger event configuration bit of line 1"] # [must_use] # [inline (always)] pub const fn tr1 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 1"] # [inline (always)] pub const fn set_tr1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Rising trigger event configuration bit of line 2"] # [must_use] # [inline (always)] pub const fn tr2 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 2"] # [inline (always)] pub const fn set_tr2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Rising trigger event configuration bit of line 3"] # [must_use] # [inline (always)] pub const fn tr3 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 3"] # [inline (always)] pub const fn set_tr3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Rising trigger event configuration bit of line 4"] # [must_use] # [inline (always)] pub const fn tr4 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 4"] # [inline (always)] pub const fn set_tr4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Rising trigger event configuration bit of line 5"] # [must_use] # [inline (always)] pub const fn tr5 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 5"] # [inline (always)] pub const fn set_tr5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Rising trigger event configuration bit of line 6"] # [must_use] # [inline (always)] pub const fn tr6 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 6"] # [inline (always)] pub const fn set_tr6 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Rising trigger event configuration bit of line 7"] # [must_use] # [inline (always)] pub const fn tr7 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 7"] # [inline (always)] pub const fn set_tr7 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Rising trigger event configuration bit of line 8"] # [must_use] # [inline (always)] pub const fn tr8 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 8"] # [inline (always)] pub const fn set_tr8 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Rising trigger event configuration bit of line 9"] # [must_use] # [inline (always)] pub const fn tr9 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 9"] # [inline (always)] pub const fn set_tr9 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Rising trigger event configuration bit of line 10"] # [must_use] # [inline (always)] pub const fn tr10 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 10"] # [inline (always)] pub const fn set_tr10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Rising trigger event configuration bit of line 11"] # [must_use] # [inline (always)] pub const fn tr11 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 11"] # [inline (always)] pub const fn set_tr11 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Rising trigger event configuration bit of line 12"] # [must_use] # [inline (always)] pub const fn tr12 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 12"] # [inline (always)] pub const fn set_tr12 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Rising trigger event configuration bit of line 13"] # [must_use] # [inline (always)] pub const fn tr13 (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 13"] # [inline (always)] pub const fn set_tr13 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Rising trigger event configuration bit of line 14"] # [must_use] # [inline (always)] pub const fn tr14 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 14"] # [inline (always)] pub const fn set_tr14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Rising trigger event configuration bit of line 15"] # [must_use] # [inline (always)] pub const fn tr15 (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 15"] # [inline (always)] pub const fn set_tr15 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "Rising trigger event configuration bit of line 16"] # [must_use] # [inline (always)] pub const fn tr16 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 16"] # [inline (always)] pub const fn set_tr16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Rising trigger event configuration bit of line 19"] # [must_use] # [inline (always)] pub const fn tr19 (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 19"] # [inline (always)] pub const fn set_tr19 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "Rising trigger event configuration bit of line 24"] # [must_use] # [inline (always)] pub const fn tr24 (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Rising trigger event configuration bit of line 24"] # [inline (always)] pub const fn set_tr24 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } } impl Default for Rtsr { # [inline (always)] fn default () -> Rtsr { Rtsr (0) } } impl core :: fmt :: Debug for Rtsr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rtsr") . field ("tr0" , & self . tr0 ()) . field ("tr1" , & self . tr1 ()) . field ("tr2" , & self . tr2 ()) . field ("tr3" , & self . tr3 ()) . field ("tr4" , & self . tr4 ()) . field ("tr5" , & self . tr5 ()) . field ("tr6" , & self . tr6 ()) . field ("tr7" , & self . tr7 ()) . field ("tr8" , & self . tr8 ()) . field ("tr9" , & self . tr9 ()) . field ("tr10" , & self . tr10 ()) . field ("tr11" , & self . tr11 ()) . field ("tr12" , & self . tr12 ()) . field ("tr13" , & self . tr13 ()) . field ("tr14" , & self . tr14 ()) . field ("tr15" , & self . tr15 ()) . field ("tr16" , & self . tr16 ()) . field ("tr19" , & self . tr19 ()) . field ("tr24" , & self . tr24 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rtsr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rtsr {{ tr0: {=bool:?}, tr1: {=bool:?}, tr2: {=bool:?}, tr3: {=bool:?}, tr4: {=bool:?}, tr5: {=bool:?}, tr6: {=bool:?}, tr7: {=bool:?}, tr8: {=bool:?}, tr9: {=bool:?}, tr10: {=bool:?}, tr11: {=bool:?}, tr12: {=bool:?}, tr13: {=bool:?}, tr14: {=bool:?}, tr15: {=bool:?}, tr16: {=bool:?}, tr19: {=bool:?}, tr24: {=bool:?} }}" , self . tr0 () , self . tr1 () , self . tr2 () , self . tr3 () , self . tr4 () , self . tr5 () , self . tr6 () , self . tr7 () , self . tr8 () , self . tr9 () , self . tr10 () , self . tr11 () , self . tr12 () , self . tr13 () , self . tr14 () , self . tr15 () , self . tr16 () , self . tr19 () , self . tr24 ()) } } # [doc = "Software interrupt event register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Swier (pub u32) ; impl Swier { # [doc = "Software interrupt on line 0"] # [must_use] # [inline (always)] pub const fn swier0 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 0"] # [inline (always)] pub const fn set_swier0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Software interrupt on line 1"] # [must_use] # [inline (always)] pub const fn swier1 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 1"] # [inline (always)] pub const fn set_swier1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Software interrupt on line 2"] # [must_use] # [inline (always)] pub const fn swier2 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 2"] # [inline (always)] pub const fn set_swier2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Software interrupt on line 3"] # [must_use] # [inline (always)] pub const fn swier3 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 3"] # [inline (always)] pub const fn set_swier3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Software interrupt on line 4"] # [must_use] # [inline (always)] pub const fn swier4 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 4"] # [inline (always)] pub const fn set_swier4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Software interrupt on line 5"] # [must_use] # [inline (always)] pub const fn swier5 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 5"] # [inline (always)] pub const fn set_swier5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Software interrupt on line 6"] # [must_use] # [inline (always)] pub const fn swier6 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 6"] # [inline (always)] pub const fn set_swier6 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Software interrupt on line 7"] # [must_use] # [inline (always)] pub const fn swier7 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 7"] # [inline (always)] pub const fn set_swier7 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Software interrupt on line 8"] # [must_use] # [inline (always)] pub const fn swier8 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 8"] # [inline (always)] pub const fn set_swier8 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Software interrupt on line 9"] # [must_use] # [inline (always)] pub const fn swier9 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 9"] # [inline (always)] pub const fn set_swier9 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Software interrupt on line 10"] # [must_use] # [inline (always)] pub const fn swier10 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 10"] # [inline (always)] pub const fn set_swier10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Software interrupt on line 11"] # [must_use] # [inline (always)] pub const fn swier11 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 11"] # [inline (always)] pub const fn set_swier11 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Software interrupt on line 12"] # [must_use] # [inline (always)] pub const fn swier12 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 12"] # [inline (always)] pub const fn set_swier12 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Software interrupt on line 13"] # [must_use] # [inline (always)] pub const fn swier13 (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 13"] # [inline (always)] pub const fn set_swier13 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Software interrupt on line 14"] # [must_use] # [inline (always)] pub const fn swier14 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 14"] # [inline (always)] pub const fn set_swier14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Software interrupt on line 15"] # [must_use] # [inline (always)] pub const fn swier15 (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 15"] # [inline (always)] pub const fn set_swier15 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "Software interrupt on line 16"] # [must_use] # [inline (always)] pub const fn swier16 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 16"] # [inline (always)] pub const fn set_swier16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Software interrupt on line 19"] # [must_use] # [inline (always)] pub const fn swier19 (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 19"] # [inline (always)] pub const fn set_swier19 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "Software interrupt on line 24"] # [must_use] # [inline (always)] pub const fn swier24 (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Software interrupt on line 24"] # [inline (always)] pub const fn set_swier24 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } } impl Default for Swier { # [inline (always)] fn default () -> Swier { Swier (0) } } impl core :: fmt :: Debug for Swier { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Swier") . field ("swier0" , & self . swier0 ()) . field ("swier1" , & self . swier1 ()) . field ("swier2" , & self . swier2 ()) . field ("swier3" , & self . swier3 ()) . field ("swier4" , & self . swier4 ()) . field ("swier5" , & self . swier5 ()) . field ("swier6" , & self . swier6 ()) . field ("swier7" , & self . swier7 ()) . field ("swier8" , & self . swier8 ()) . field ("swier9" , & self . swier9 ()) . field ("swier10" , & self . swier10 ()) . field ("swier11" , & self . swier11 ()) . field ("swier12" , & self . swier12 ()) . field ("swier13" , & self . swier13 ()) . field ("swier14" , & self . swier14 ()) . field ("swier15" , & self . swier15 ()) . field ("swier16" , & self . swier16 ()) . field ("swier19" , & self . swier19 ()) . field ("swier24" , & self . swier24 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Swier { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Swier {{ swier0: {=bool:?}, swier1: {=bool:?}, swier2: {=bool:?}, swier3: {=bool:?}, swier4: {=bool:?}, swier5: {=bool:?}, swier6: {=bool:?}, swier7: {=bool:?}, swier8: {=bool:?}, swier9: {=bool:?}, swier10: {=bool:?}, swier11: {=bool:?}, swier12: {=bool:?}, swier13: {=bool:?}, swier14: {=bool:?}, swier15: {=bool:?}, swier16: {=bool:?}, swier19: {=bool:?}, swier24: {=bool:?} }}" , self . swier0 () , self . swier1 () , self . swier2 () , self . swier3 () , self . swier4 () , self . swier5 () , self . swier6 () , self . swier7 () , self . swier8 () , self . swier9 () , self . swier10 () , self . swier11 () , self . swier12 () , self . swier13 () , self . swier14 () , self . swier15 () , self . swier16 () , self . swier19 () , self . swier24 ()) } } } } pub mod flash { # [doc = "FLASH"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Flash { ptr : * mut u8 } unsafe impl Send for Flash { } unsafe impl Sync for Flash { } impl Flash { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Flash access control register"] # [inline (always)] pub const fn acr (self) -> crate :: common :: Reg < regs :: Acr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Flash key"] # [inline (always)] pub const fn keyr (self) -> crate :: common :: Reg < regs :: Keyr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Option byte key"] # [inline (always)] pub const fn optkeyr (self) -> crate :: common :: Reg < regs :: Optkeyr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "Flash status register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "Flash control register"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "Flash address register"] # [inline (always)] pub const fn ar (self) -> crate :: common :: Reg < regs :: Ar , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "Option byte register"] # [inline (always)] pub const fn obr (self) -> crate :: common :: Reg < regs :: Obr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "Write protect register"] # [inline (always)] pub const fn wrpr (self) -> crate :: common :: Reg < regs :: Wrpr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } } pub mod regs { # [doc = "Flash access control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Acr (pub u32) ; impl Acr { # [doc = "Latency"] # [must_use] # [inline (always)] pub const fn latency (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x07 ; val as u8 } # [doc = "Latency"] # [inline (always)] pub const fn set_latency (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize) ; } # [doc = "Flash half cycle access enable"] # [must_use] # [inline (always)] pub const fn hlfcya (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Flash half cycle access enable"] # [inline (always)] pub const fn set_hlfcya (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Prefetch buffer enable"] # [must_use] # [inline (always)] pub const fn prftbe (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Prefetch buffer enable"] # [inline (always)] pub const fn set_prftbe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } } impl Default for Acr { # [inline (always)] fn default () -> Acr { Acr (0) } } impl core :: fmt :: Debug for Acr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Acr") . field ("latency" , & self . latency ()) . field ("hlfcya" , & self . hlfcya ()) . field ("prftbe" , & self . prftbe ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Acr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Acr {{ latency: {=u8:?}, hlfcya: {=bool:?}, prftbe: {=bool:?} }}" , self . latency () , self . hlfcya () , self . prftbe ()) } } # [doc = "Flash address register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ar (pub u32) ; impl Ar { # [doc = "Flash Address"] # [must_use] # [inline (always)] pub const fn far (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Flash Address"] # [inline (always)] pub const fn set_far (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Ar { # [inline (always)] fn default () -> Ar { Ar (0) } } impl core :: fmt :: Debug for Ar { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ar") . field ("far" , & self . far ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ar { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ar {{ far: {=u32:?} }}" , self . far ()) } } # [doc = "Flash control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "Programming"] # [must_use] # [inline (always)] pub const fn pg (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Programming"] # [inline (always)] pub const fn set_pg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Page erase"] # [must_use] # [inline (always)] pub const fn per (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Page erase"] # [inline (always)] pub const fn set_per (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Mass erase"] # [must_use] # [inline (always)] pub const fn mer (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Mass erase"] # [inline (always)] pub const fn set_mer (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Option byte programming"] # [must_use] # [inline (always)] pub const fn optpg (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Option byte programming"] # [inline (always)] pub const fn set_optpg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Option byte erase"] # [must_use] # [inline (always)] pub const fn opter (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Option byte erase"] # [inline (always)] pub const fn set_opter (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Start"] # [must_use] # [inline (always)] pub const fn strt (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Start"] # [inline (always)] pub const fn set_strt (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Lock"] # [must_use] # [inline (always)] pub const fn lock (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Lock"] # [inline (always)] pub const fn set_lock (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Option byte write enable"] # [must_use] # [inline (always)] pub const fn optwre (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Option byte write enable"] # [inline (always)] pub const fn set_optwre (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Error interrupt enable"] # [must_use] # [inline (always)] pub const fn errie (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Error interrupt enable"] # [inline (always)] pub const fn set_errie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "End of operation interrupt enable"] # [must_use] # [inline (always)] pub const fn eopie (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "End of operation interrupt enable"] # [inline (always)] pub const fn set_eopie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("pg" , & self . pg ()) . field ("per" , & self . per ()) . field ("mer" , & self . mer ()) . field ("optpg" , & self . optpg ()) . field ("opter" , & self . opter ()) . field ("strt" , & self . strt ()) . field ("lock" , & self . lock ()) . field ("optwre" , & self . optwre ()) . field ("errie" , & self . errie ()) . field ("eopie" , & self . eopie ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ pg: {=bool:?}, per: {=bool:?}, mer: {=bool:?}, optpg: {=bool:?}, opter: {=bool:?}, strt: {=bool:?}, lock: {=bool:?}, optwre: {=bool:?}, errie: {=bool:?}, eopie: {=bool:?} }}" , self . pg () , self . per () , self . mer () , self . optpg () , self . opter () , self . strt () , self . lock () , self . optwre () , self . errie () , self . eopie ()) } } # [doc = "Flash key"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Keyr (pub u32) ; impl Keyr { # [doc = "Flash key"] # [must_use] # [inline (always)] pub const fn fkeyr (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Flash key"] # [inline (always)] pub const fn set_fkeyr (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Keyr { # [inline (always)] fn default () -> Keyr { Keyr (0) } } impl core :: fmt :: Debug for Keyr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Keyr") . field ("fkeyr" , & self . fkeyr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Keyr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Keyr {{ fkeyr: {=u32:?} }}" , self . fkeyr ()) } } # [doc = "Option byte register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Obr (pub u32) ; impl Obr { # [doc = "Option byte error"] # [must_use] # [inline (always)] pub const fn opterr (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Option byte error"] # [inline (always)] pub const fn set_opterr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "WDG_SW"] # [must_use] # [inline (always)] pub const fn wdg_sw (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "WDG_SW"] # [inline (always)] pub const fn set_wdg_sw (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "nRST_STOP"] # [must_use] # [inline (always)] pub const fn n_rst_stop (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "nRST_STOP"] # [inline (always)] pub const fn set_n_rst_stop (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "nRST_STDBY"] # [must_use] # [inline (always)] pub const fn n_rst_stdby (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "nRST_STDBY"] # [inline (always)] pub const fn set_n_rst_stdby (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "nBOOT1"] # [must_use] # [inline (always)] pub const fn n_boot1 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "nBOOT1"] # [inline (always)] pub const fn set_n_boot1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Data0"] # [must_use] # [inline (always)] pub const fn data0 (& self) -> u8 { let val = (self . 0 >> 10usize) & 0xff ; val as u8 } # [doc = "Data0"] # [inline (always)] pub const fn set_data0 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 10usize)) | (((val as u32) & 0xff) << 10usize) ; } # [doc = "Data1"] # [must_use] # [inline (always)] pub const fn data1 (& self) -> u8 { let val = (self . 0 >> 18usize) & 0xff ; val as u8 } # [doc = "Data1"] # [inline (always)] pub const fn set_data1 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 18usize)) | (((val as u32) & 0xff) << 18usize) ; } } impl Default for Obr { # [inline (always)] fn default () -> Obr { Obr (0) } } impl core :: fmt :: Debug for Obr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Obr") . field ("opterr" , & self . opterr ()) . field ("wdg_sw" , & self . wdg_sw ()) . field ("n_rst_stop" , & self . n_rst_stop ()) . field ("n_rst_stdby" , & self . n_rst_stdby ()) . field ("n_boot1" , & self . n_boot1 ()) . field ("data0" , & self . data0 ()) . field ("data1" , & self . data1 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Obr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Obr {{ opterr: {=bool:?}, wdg_sw: {=bool:?}, n_rst_stop: {=bool:?}, n_rst_stdby: {=bool:?}, n_boot1: {=bool:?}, data0: {=u8:?}, data1: {=u8:?} }}" , self . opterr () , self . wdg_sw () , self . n_rst_stop () , self . n_rst_stdby () , self . n_boot1 () , self . data0 () , self . data1 ()) } } # [doc = "Option byte key"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Optkeyr (pub u32) ; impl Optkeyr { # [doc = "Option byte key"] # [must_use] # [inline (always)] pub const fn optkeyr (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Option byte key"] # [inline (always)] pub const fn set_optkeyr (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Optkeyr { # [inline (always)] fn default () -> Optkeyr { Optkeyr (0) } } impl core :: fmt :: Debug for Optkeyr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Optkeyr") . field ("optkeyr" , & self . optkeyr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Optkeyr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Optkeyr {{ optkeyr: {=u32:?} }}" , self . optkeyr ()) } } # [doc = "Flash status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "Busy"] # [must_use] # [inline (always)] pub const fn bsy (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Busy"] # [inline (always)] pub const fn set_bsy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Programming error"] # [must_use] # [inline (always)] pub const fn pgerr (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Programming error"] # [inline (always)] pub const fn set_pgerr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Write protection error"] # [must_use] # [inline (always)] pub const fn wrprterr (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Write protection error"] # [inline (always)] pub const fn set_wrprterr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "End of operation"] # [must_use] # [inline (always)] pub const fn eop (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "End of operation"] # [inline (always)] pub const fn set_eop (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("bsy" , & self . bsy ()) . field ("pgerr" , & self . pgerr ()) . field ("wrprterr" , & self . wrprterr ()) . field ("eop" , & self . eop ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ bsy: {=bool:?}, pgerr: {=bool:?}, wrprterr: {=bool:?}, eop: {=bool:?} }}" , self . bsy () , self . pgerr () , self . wrprterr () , self . eop ()) } } # [doc = "Write protect register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Wrpr (pub u32) ; impl Wrpr { # [doc = "Write protect"] # [must_use] # [inline (always)] pub const fn wrp (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Write protect"] # [inline (always)] pub const fn set_wrp (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Wrpr { # [inline (always)] fn default () -> Wrpr { Wrpr (0) } } impl core :: fmt :: Debug for Wrpr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Wrpr") . field ("wrp" , & self . wrp ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Wrpr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Wrpr {{ wrp: {=u32:?} }}" , self . wrp ()) } } } } pub mod gpioa { # [doc = "General purpose I/O"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Gpioa { ptr : * mut u8 } unsafe impl Send for Gpioa { } unsafe impl Sync for Gpioa { } impl Gpioa { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "configuration low register"] # [inline (always)] pub const fn crl (self) -> crate :: common :: Reg < regs :: Crl , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "configuration high register"] # [inline (always)] pub const fn crh (self) -> crate :: common :: Reg < regs :: Crh , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "input data register"] # [inline (always)] pub const fn idr (self) -> crate :: common :: Reg < regs :: Idr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "output data register"] # [inline (always)] pub const fn odr (self) -> crate :: common :: Reg < regs :: Odr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "bit set/reset register"] # [inline (always)] pub const fn bsrr (self) -> crate :: common :: Reg < regs :: Bsrr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "bit reset register"] # [inline (always)] pub const fn brr (self) -> crate :: common :: Reg < regs :: Brr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "Port configuration lock register"] # [inline (always)] pub const fn lckr (self) -> crate :: common :: Reg < regs :: Lckr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "Port Multiplexing Function Low Register"] # [inline (always)] pub const fn afrl (self) -> crate :: common :: Reg < regs :: Afrl , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "Port Multiplexing Function High Register"] # [inline (always)] pub const fn afrh (self) -> crate :: common :: Reg < regs :: Afrh , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } } pub mod regs { # [doc = "Port Multiplexing Function High Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Afrh (pub u32) ; impl Afrh { # [doc = "Multiplexing function selection for bit 8 of portx"] # [must_use] # [inline (always)] pub const fn afr8 (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 8 of portx"] # [inline (always)] pub const fn set_afr8 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "Multiplexing function selection for bit 9 of portx"] # [must_use] # [inline (always)] pub const fn afr9 (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 9 of portx"] # [inline (always)] pub const fn set_afr9 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Multiplexing function selection for bit 10 of portx"] # [must_use] # [inline (always)] pub const fn afr10 (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 10 of portx"] # [inline (always)] pub const fn set_afr10 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "Multiplexing function selection for bit 11 of portx"] # [must_use] # [inline (always)] pub const fn afr11 (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 11 of portx"] # [inline (always)] pub const fn set_afr11 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } # [doc = "Multiplexing function selection for bit 12 of portx"] # [must_use] # [inline (always)] pub const fn afr12 (& self) -> u8 { let val = (self . 0 >> 16usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 12 of portx"] # [inline (always)] pub const fn set_afr12 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize) ; } # [doc = "Multiplexing function selection for bit 13 of portx"] # [must_use] # [inline (always)] pub const fn afr13 (& self) -> u8 { let val = (self . 0 >> 20usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 13 of portx"] # [inline (always)] pub const fn set_afr13 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize) ; } # [doc = "Multiplexing function selection for bit 14 of portx"] # [must_use] # [inline (always)] pub const fn afr14 (& self) -> u8 { let val = (self . 0 >> 24usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 14 of portx"] # [inline (always)] pub const fn set_afr14 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize) ; } # [doc = "Multiplexing function selection for bit 15 of portx"] # [must_use] # [inline (always)] pub const fn afr15 (& self) -> u8 { let val = (self . 0 >> 28usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 15 of portx"] # [inline (always)] pub const fn set_afr15 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize) ; } } impl Default for Afrh { # [inline (always)] fn default () -> Afrh { Afrh (0) } } impl core :: fmt :: Debug for Afrh { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Afrh") . field ("afr8" , & self . afr8 ()) . field ("afr9" , & self . afr9 ()) . field ("afr10" , & self . afr10 ()) . field ("afr11" , & self . afr11 ()) . field ("afr12" , & self . afr12 ()) . field ("afr13" , & self . afr13 ()) . field ("afr14" , & self . afr14 ()) . field ("afr15" , & self . afr15 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Afrh { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Afrh {{ afr8: {=u8:?}, afr9: {=u8:?}, afr10: {=u8:?}, afr11: {=u8:?}, afr12: {=u8:?}, afr13: {=u8:?}, afr14: {=u8:?}, afr15: {=u8:?} }}" , self . afr8 () , self . afr9 () , self . afr10 () , self . afr11 () , self . afr12 () , self . afr13 () , self . afr14 () , self . afr15 ()) } } # [doc = "Port Multiplexing Function Low Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Afrl (pub u32) ; impl Afrl { # [doc = "Multiplexing function selection for bit 0 of portx"] # [must_use] # [inline (always)] pub const fn afr0 (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 0 of portx"] # [inline (always)] pub const fn set_afr0 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } # [doc = "Multiplexing function selection for bit 1 of portx"] # [must_use] # [inline (always)] pub const fn afr1 (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 1 of portx"] # [inline (always)] pub const fn set_afr1 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Multiplexing function selection for bit 2 of portx"] # [must_use] # [inline (always)] pub const fn afr2 (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 2 of portx"] # [inline (always)] pub const fn set_afr2 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "Multiplexing function selection for bit 3 of portx"] # [must_use] # [inline (always)] pub const fn afr3 (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 3 of portx"] # [inline (always)] pub const fn set_afr3 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } # [doc = "Multiplexing function selection for bit 4 of portx"] # [must_use] # [inline (always)] pub const fn afr4 (& self) -> u8 { let val = (self . 0 >> 16usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 4 of portx"] # [inline (always)] pub const fn set_afr4 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize) ; } # [doc = "Multiplexing function selection for bit 5 of portx"] # [must_use] # [inline (always)] pub const fn afr5 (& self) -> u8 { let val = (self . 0 >> 20usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 5 of portx"] # [inline (always)] pub const fn set_afr5 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize) ; } # [doc = "Multiplexing function selection for bit 6 of portx"] # [must_use] # [inline (always)] pub const fn afr6 (& self) -> u8 { let val = (self . 0 >> 24usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 6 of portx"] # [inline (always)] pub const fn set_afr6 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize) ; } # [doc = "Multiplexing function selection for bit 7 of portx"] # [must_use] # [inline (always)] pub const fn afr7 (& self) -> u8 { let val = (self . 0 >> 28usize) & 0x0f ; val as u8 } # [doc = "Multiplexing function selection for bit 7 of portx"] # [inline (always)] pub const fn set_afr7 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize) ; } } impl Default for Afrl { # [inline (always)] fn default () -> Afrl { Afrl (0) } } impl core :: fmt :: Debug for Afrl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Afrl") . field ("afr0" , & self . afr0 ()) . field ("afr1" , & self . afr1 ()) . field ("afr2" , & self . afr2 ()) . field ("afr3" , & self . afr3 ()) . field ("afr4" , & self . afr4 ()) . field ("afr5" , & self . afr5 ()) . field ("afr6" , & self . afr6 ()) . field ("afr7" , & self . afr7 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Afrl { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Afrl {{ afr0: {=u8:?}, afr1: {=u8:?}, afr2: {=u8:?}, afr3: {=u8:?}, afr4: {=u8:?}, afr5: {=u8:?}, afr6: {=u8:?}, afr7: {=u8:?} }}" , self . afr0 () , self . afr1 () , self . afr2 () , self . afr3 () , self . afr4 () , self . afr5 () , self . afr6 () , self . afr7 ()) } } # [doc = "bit reset register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Brr (pub u32) ; impl Brr { # [doc = "Port x Reset bit y"] # [must_use] # [inline (always)] pub const fn br (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Port x Reset bit y"] # [inline (always)] pub const fn set_br (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Brr { # [inline (always)] fn default () -> Brr { Brr (0) } } impl core :: fmt :: Debug for Brr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Brr") . field ("br" , & self . br ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Brr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Brr {{ br: {=u16:?} }}" , self . br ()) } } # [doc = "bit set/reset register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Bsrr (pub u32) ; impl Bsrr { # [doc = "Port x Set bit 0"] # [must_use] # [inline (always)] pub const fn bs0 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 0"] # [inline (always)] pub const fn set_bs0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Port x Set bit 1"] # [must_use] # [inline (always)] pub const fn bs1 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 1"] # [inline (always)] pub const fn set_bs1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Port x Set bit 2"] # [must_use] # [inline (always)] pub const fn bs2 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 2"] # [inline (always)] pub const fn set_bs2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Port x Set bit 3"] # [must_use] # [inline (always)] pub const fn bs3 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 3"] # [inline (always)] pub const fn set_bs3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Port x Set bit 4"] # [must_use] # [inline (always)] pub const fn bs4 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 4"] # [inline (always)] pub const fn set_bs4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Port x Set bit 5"] # [must_use] # [inline (always)] pub const fn bs5 (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 5"] # [inline (always)] pub const fn set_bs5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Port x Set bit 6"] # [must_use] # [inline (always)] pub const fn bs6 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 6"] # [inline (always)] pub const fn set_bs6 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Port x Set bit 7"] # [must_use] # [inline (always)] pub const fn bs7 (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 7"] # [inline (always)] pub const fn set_bs7 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Port x Set bit 8"] # [must_use] # [inline (always)] pub const fn bs8 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 8"] # [inline (always)] pub const fn set_bs8 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Port x Set bit 9"] # [must_use] # [inline (always)] pub const fn bs9 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 9"] # [inline (always)] pub const fn set_bs9 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Port x Set bit 10"] # [must_use] # [inline (always)] pub const fn bs10 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 10"] # [inline (always)] pub const fn set_bs10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Port x Set bit 11"] # [must_use] # [inline (always)] pub const fn bs11 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 11"] # [inline (always)] pub const fn set_bs11 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Port x Set bit 12"] # [must_use] # [inline (always)] pub const fn bs12 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 12"] # [inline (always)] pub const fn set_bs12 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Port x Set bit 13"] # [must_use] # [inline (always)] pub const fn bs13 (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 13"] # [inline (always)] pub const fn set_bs13 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Port x Set bit 14"] # [must_use] # [inline (always)] pub const fn bs14 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 14"] # [inline (always)] pub const fn set_bs14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Port x Set bit 15"] # [must_use] # [inline (always)] pub const fn bs15 (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Port x Set bit 15"] # [inline (always)] pub const fn set_bs15 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "Port x Reset bit 0"] # [must_use] # [inline (always)] pub const fn br0 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 0"] # [inline (always)] pub const fn set_br0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Port x Reset bit 1"] # [must_use] # [inline (always)] pub const fn br1 (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 1"] # [inline (always)] pub const fn set_br1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "Port x Reset bit 2"] # [must_use] # [inline (always)] pub const fn br2 (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 2"] # [inline (always)] pub const fn set_br2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "Port x Reset bit 3"] # [must_use] # [inline (always)] pub const fn br3 (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 3"] # [inline (always)] pub const fn set_br3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "Port x Reset bit 4"] # [must_use] # [inline (always)] pub const fn br4 (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 4"] # [inline (always)] pub const fn set_br4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Port x Reset bit 5"] # [must_use] # [inline (always)] pub const fn br5 (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 5"] # [inline (always)] pub const fn set_br5 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } # [doc = "Port x Reset bit 6"] # [must_use] # [inline (always)] pub const fn br6 (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 6"] # [inline (always)] pub const fn set_br6 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "Port x Reset bit 7"] # [must_use] # [inline (always)] pub const fn br7 (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 7"] # [inline (always)] pub const fn set_br7 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } # [doc = "Port x Reset bit 8"] # [must_use] # [inline (always)] pub const fn br8 (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 8"] # [inline (always)] pub const fn set_br8 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } # [doc = "Port x Reset bit 9"] # [must_use] # [inline (always)] pub const fn br9 (& self) -> bool { let val = (self . 0 >> 25usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 9"] # [inline (always)] pub const fn set_br9 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize) ; } # [doc = "Port x Reset bit 10"] # [must_use] # [inline (always)] pub const fn br10 (& self) -> bool { let val = (self . 0 >> 26usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 10"] # [inline (always)] pub const fn set_br10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize) ; } # [doc = "Port x Reset bit 11"] # [must_use] # [inline (always)] pub const fn br11 (& self) -> bool { let val = (self . 0 >> 27usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 11"] # [inline (always)] pub const fn set_br11 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize) ; } # [doc = "Port x Reset bit 12"] # [must_use] # [inline (always)] pub const fn br12 (& self) -> bool { let val = (self . 0 >> 28usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 12"] # [inline (always)] pub const fn set_br12 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize) ; } # [doc = "Port x Reset bit 13"] # [must_use] # [inline (always)] pub const fn br13 (& self) -> bool { let val = (self . 0 >> 29usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 13"] # [inline (always)] pub const fn set_br13 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize) ; } # [doc = "Port x Reset bit 14"] # [must_use] # [inline (always)] pub const fn br14 (& self) -> bool { let val = (self . 0 >> 30usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 14"] # [inline (always)] pub const fn set_br14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize) ; } # [doc = "Port x Reset bit 15"] # [must_use] # [inline (always)] pub const fn br15 (& self) -> bool { let val = (self . 0 >> 31usize) & 0x01 ; val != 0 } # [doc = "Port x Reset bit 15"] # [inline (always)] pub const fn set_br15 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize) ; } } impl Default for Bsrr { # [inline (always)] fn default () -> Bsrr { Bsrr (0) } } impl core :: fmt :: Debug for Bsrr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Bsrr") . field ("bs0" , & self . bs0 ()) . field ("bs1" , & self . bs1 ()) . field ("bs2" , & self . bs2 ()) . field ("bs3" , & self . bs3 ()) . field ("bs4" , & self . bs4 ()) . field ("bs5" , & self . bs5 ()) . field ("bs6" , & self . bs6 ()) . field ("bs7" , & self . bs7 ()) . field ("bs8" , & self . bs8 ()) . field ("bs9" , & self . bs9 ()) . field ("bs10" , & self . bs10 ()) . field ("bs11" , & self . bs11 ()) . field ("bs12" , & self . bs12 ()) . field ("bs13" , & self . bs13 ()) . field ("bs14" , & self . bs14 ()) . field ("bs15" , & self . bs15 ()) . field ("br0" , & self . br0 ()) . field ("br1" , & self . br1 ()) . field ("br2" , & self . br2 ()) . field ("br3" , & self . br3 ()) . field ("br4" , & self . br4 ()) . field ("br5" , & self . br5 ()) . field ("br6" , & self . br6 ()) . field ("br7" , & self . br7 ()) . field ("br8" , & self . br8 ()) . field ("br9" , & self . br9 ()) . field ("br10" , & self . br10 ()) . field ("br11" , & self . br11 ()) . field ("br12" , & self . br12 ()) . field ("br13" , & self . br13 ()) . field ("br14" , & self . br14 ()) . field ("br15" , & self . br15 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Bsrr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Bsrr {{ bs0: {=bool:?}, bs1: {=bool:?}, bs2: {=bool:?}, bs3: {=bool:?}, bs4: {=bool:?}, bs5: {=bool:?}, bs6: {=bool:?}, bs7: {=bool:?}, bs8: {=bool:?}, bs9: {=bool:?}, bs10: {=bool:?}, bs11: {=bool:?}, bs12: {=bool:?}, bs13: {=bool:?}, bs14: {=bool:?}, bs15: {=bool:?}, br0: {=bool:?}, br1: {=bool:?}, br2: {=bool:?}, br3: {=bool:?}, br4: {=bool:?}, br5: {=bool:?}, br6: {=bool:?}, br7: {=bool:?}, br8: {=bool:?}, br9: {=bool:?}, br10: {=bool:?}, br11: {=bool:?}, br12: {=bool:?}, br13: {=bool:?}, br14: {=bool:?}, br15: {=bool:?} }}" , self . bs0 () , self . bs1 () , self . bs2 () , self . bs3 () , self . bs4 () , self . bs5 () , self . bs6 () , self . bs7 () , self . bs8 () , self . bs9 () , self . bs10 () , self . bs11 () , self . bs12 () , self . bs13 () , self . bs14 () , self . bs15 () , self . br0 () , self . br1 () , self . br2 () , self . br3 () , self . br4 () , self . br5 () , self . br6 () , self . br7 () , self . br8 () , self . br9 () , self . br10 () , self . br11 () , self . br12 () , self . br13 () , self . br14 () , self . br15 ()) } } # [doc = "configuration high register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Crh (pub u32) ; impl Crh { # [doc = "Port 8 mode bits"] # [must_use] # [inline (always)] pub const fn mode8 (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Port 8 mode bits"] # [inline (always)] pub const fn set_mode8 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Port 8 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf8 (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Port 8 configuration bits"] # [inline (always)] pub const fn set_cnf8 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Port 9 mode bits"] # [must_use] # [inline (always)] pub const fn mode9 (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x03 ; val as u8 } # [doc = "Port 9 mode bits"] # [inline (always)] pub const fn set_mode9 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize) ; } # [doc = "Port 9 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf9 (& self) -> u8 { let val = (self . 0 >> 6usize) & 0x03 ; val as u8 } # [doc = "Port 9 configuration bits"] # [inline (always)] pub const fn set_cnf9 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 6usize)) | (((val as u32) & 0x03) << 6usize) ; } # [doc = "Port 10 mode bits"] # [must_use] # [inline (always)] pub const fn mode10 (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Port 10 mode bits"] # [inline (always)] pub const fn set_mode10 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Port 10 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf10 (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Port 10 configuration bits"] # [inline (always)] pub const fn set_cnf10 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Port 11 mode bits"] # [must_use] # [inline (always)] pub const fn mode11 (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "Port 11 mode bits"] # [inline (always)] pub const fn set_mode11 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "Port 11 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf11 (& self) -> u8 { let val = (self . 0 >> 14usize) & 0x03 ; val as u8 } # [doc = "Port 11 configuration bits"] # [inline (always)] pub const fn set_cnf11 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 14usize)) | (((val as u32) & 0x03) << 14usize) ; } # [doc = "Port 12 mode bits"] # [must_use] # [inline (always)] pub const fn mode12 (& self) -> u8 { let val = (self . 0 >> 16usize) & 0x03 ; val as u8 } # [doc = "Port 12 mode bits"] # [inline (always)] pub const fn set_mode12 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize) ; } # [doc = "Port 12 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf12 (& self) -> u8 { let val = (self . 0 >> 18usize) & 0x03 ; val as u8 } # [doc = "Port 12 configuration bits"] # [inline (always)] pub const fn set_cnf12 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 18usize)) | (((val as u32) & 0x03) << 18usize) ; } # [doc = "Port 13 mode bits"] # [must_use] # [inline (always)] pub const fn mode13 (& self) -> u8 { let val = (self . 0 >> 20usize) & 0x03 ; val as u8 } # [doc = "Port 13 mode bits"] # [inline (always)] pub const fn set_mode13 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 20usize)) | (((val as u32) & 0x03) << 20usize) ; } # [doc = "Port 13 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf13 (& self) -> u8 { let val = (self . 0 >> 22usize) & 0x03 ; val as u8 } # [doc = "Port 13 configuration bits"] # [inline (always)] pub const fn set_cnf13 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize) ; } # [doc = "Port 14 mode bits"] # [must_use] # [inline (always)] pub const fn mode14 (& self) -> u8 { let val = (self . 0 >> 24usize) & 0x03 ; val as u8 } # [doc = "Port 14 mode bits"] # [inline (always)] pub const fn set_mode14 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize) ; } # [doc = "Port 14 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf14 (& self) -> u8 { let val = (self . 0 >> 26usize) & 0x03 ; val as u8 } # [doc = "Port 14 configuration bits"] # [inline (always)] pub const fn set_cnf14 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 26usize)) | (((val as u32) & 0x03) << 26usize) ; } # [doc = "Port 15 mode bits"] # [must_use] # [inline (always)] pub const fn mode15 (& self) -> u8 { let val = (self . 0 >> 28usize) & 0x03 ; val as u8 } # [doc = "Port 15 mode bits"] # [inline (always)] pub const fn set_mode15 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 28usize)) | (((val as u32) & 0x03) << 28usize) ; } # [doc = "Port 15 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf15 (& self) -> u8 { let val = (self . 0 >> 30usize) & 0x03 ; val as u8 } # [doc = "Port 15 configuration bits"] # [inline (always)] pub const fn set_cnf15 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 30usize)) | (((val as u32) & 0x03) << 30usize) ; } } impl Default for Crh { # [inline (always)] fn default () -> Crh { Crh (0) } } impl core :: fmt :: Debug for Crh { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crh") . field ("mode8" , & self . mode8 ()) . field ("cnf8" , & self . cnf8 ()) . field ("mode9" , & self . mode9 ()) . field ("cnf9" , & self . cnf9 ()) . field ("mode10" , & self . mode10 ()) . field ("cnf10" , & self . cnf10 ()) . field ("mode11" , & self . mode11 ()) . field ("cnf11" , & self . cnf11 ()) . field ("mode12" , & self . mode12 ()) . field ("cnf12" , & self . cnf12 ()) . field ("mode13" , & self . mode13 ()) . field ("cnf13" , & self . cnf13 ()) . field ("mode14" , & self . mode14 ()) . field ("cnf14" , & self . cnf14 ()) . field ("mode15" , & self . mode15 ()) . field ("cnf15" , & self . cnf15 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Crh { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Crh {{ mode8: {=u8:?}, cnf8: {=u8:?}, mode9: {=u8:?}, cnf9: {=u8:?}, mode10: {=u8:?}, cnf10: {=u8:?}, mode11: {=u8:?}, cnf11: {=u8:?}, mode12: {=u8:?}, cnf12: {=u8:?}, mode13: {=u8:?}, cnf13: {=u8:?}, mode14: {=u8:?}, cnf14: {=u8:?}, mode15: {=u8:?}, cnf15: {=u8:?} }}" , self . mode8 () , self . cnf8 () , self . mode9 () , self . cnf9 () , self . mode10 () , self . cnf10 () , self . mode11 () , self . cnf11 () , self . mode12 () , self . cnf12 () , self . mode13 () , self . cnf13 () , self . mode14 () , self . cnf14 () , self . mode15 () , self . cnf15 ()) } } # [doc = "configuration low register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Crl (pub u32) ; impl Crl { # [doc = "Port 0 mode bits"] # [must_use] # [inline (always)] pub const fn mode0 (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Port 0 mode bits"] # [inline (always)] pub const fn set_mode0 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Port 0 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf0 (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Port 0 configuration bits"] # [inline (always)] pub const fn set_cnf0 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Port 1 mode bits"] # [must_use] # [inline (always)] pub const fn mode1 (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x03 ; val as u8 } # [doc = "Port 1 mode bits"] # [inline (always)] pub const fn set_mode1 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize) ; } # [doc = "Port 1 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf1 (& self) -> u8 { let val = (self . 0 >> 6usize) & 0x03 ; val as u8 } # [doc = "Port 1 configuration bits"] # [inline (always)] pub const fn set_cnf1 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 6usize)) | (((val as u32) & 0x03) << 6usize) ; } # [doc = "Port 2 mode bits"] # [must_use] # [inline (always)] pub const fn mode2 (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Port 2 mode bits"] # [inline (always)] pub const fn set_mode2 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Port 2 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf2 (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Port 2 configuration bits"] # [inline (always)] pub const fn set_cnf2 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Port 3 mode bits"] # [must_use] # [inline (always)] pub const fn mode3 (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "Port 3 mode bits"] # [inline (always)] pub const fn set_mode3 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "Port 3 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf3 (& self) -> u8 { let val = (self . 0 >> 14usize) & 0x03 ; val as u8 } # [doc = "Port 3 configuration bits"] # [inline (always)] pub const fn set_cnf3 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 14usize)) | (((val as u32) & 0x03) << 14usize) ; } # [doc = "Port 4 mode bits"] # [must_use] # [inline (always)] pub const fn mode4 (& self) -> u8 { let val = (self . 0 >> 16usize) & 0x03 ; val as u8 } # [doc = "Port 4 mode bits"] # [inline (always)] pub const fn set_mode4 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize) ; } # [doc = "Port 4 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf4 (& self) -> u8 { let val = (self . 0 >> 18usize) & 0x03 ; val as u8 } # [doc = "Port 4 configuration bits"] # [inline (always)] pub const fn set_cnf4 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 18usize)) | (((val as u32) & 0x03) << 18usize) ; } # [doc = "Port 5 mode bits"] # [must_use] # [inline (always)] pub const fn mode5 (& self) -> u8 { let val = (self . 0 >> 20usize) & 0x03 ; val as u8 } # [doc = "Port 5 mode bits"] # [inline (always)] pub const fn set_mode5 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 20usize)) | (((val as u32) & 0x03) << 20usize) ; } # [doc = "Port 5 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf5 (& self) -> u8 { let val = (self . 0 >> 22usize) & 0x03 ; val as u8 } # [doc = "Port 5 configuration bits"] # [inline (always)] pub const fn set_cnf5 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize) ; } # [doc = "Port 6 mode bits"] # [must_use] # [inline (always)] pub const fn mode6 (& self) -> u8 { let val = (self . 0 >> 24usize) & 0x03 ; val as u8 } # [doc = "Port 6 mode bits"] # [inline (always)] pub const fn set_mode6 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 24usize)) | (((val as u32) & 0x03) << 24usize) ; } # [doc = "Port 6 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf6 (& self) -> u8 { let val = (self . 0 >> 26usize) & 0x03 ; val as u8 } # [doc = "Port 6 configuration bits"] # [inline (always)] pub const fn set_cnf6 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 26usize)) | (((val as u32) & 0x03) << 26usize) ; } # [doc = "Port 7 mode bits"] # [must_use] # [inline (always)] pub const fn mode7 (& self) -> u8 { let val = (self . 0 >> 28usize) & 0x03 ; val as u8 } # [doc = "Port 7 mode bits"] # [inline (always)] pub const fn set_mode7 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 28usize)) | (((val as u32) & 0x03) << 28usize) ; } # [doc = "Port 7 configuration bits"] # [must_use] # [inline (always)] pub const fn cnf7 (& self) -> u8 { let val = (self . 0 >> 30usize) & 0x03 ; val as u8 } # [doc = "Port 7 configuration bits"] # [inline (always)] pub const fn set_cnf7 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 30usize)) | (((val as u32) & 0x03) << 30usize) ; } } impl Default for Crl { # [inline (always)] fn default () -> Crl { Crl (0) } } impl core :: fmt :: Debug for Crl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crl") . field ("mode0" , & self . mode0 ()) . field ("cnf0" , & self . cnf0 ()) . field ("mode1" , & self . mode1 ()) . field ("cnf1" , & self . cnf1 ()) . field ("mode2" , & self . mode2 ()) . field ("cnf2" , & self . cnf2 ()) . field ("mode3" , & self . mode3 ()) . field ("cnf3" , & self . cnf3 ()) . field ("mode4" , & self . mode4 ()) . field ("cnf4" , & self . cnf4 ()) . field ("mode5" , & self . mode5 ()) . field ("cnf5" , & self . cnf5 ()) . field ("mode6" , & self . mode6 ()) . field ("cnf6" , & self . cnf6 ()) . field ("mode7" , & self . mode7 ()) . field ("cnf7" , & self . cnf7 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Crl { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Crl {{ mode0: {=u8:?}, cnf0: {=u8:?}, mode1: {=u8:?}, cnf1: {=u8:?}, mode2: {=u8:?}, cnf2: {=u8:?}, mode3: {=u8:?}, cnf3: {=u8:?}, mode4: {=u8:?}, cnf4: {=u8:?}, mode5: {=u8:?}, cnf5: {=u8:?}, mode6: {=u8:?}, cnf6: {=u8:?}, mode7: {=u8:?}, cnf7: {=u8:?} }}" , self . mode0 () , self . cnf0 () , self . mode1 () , self . cnf1 () , self . mode2 () , self . cnf2 () , self . mode3 () , self . cnf3 () , self . mode4 () , self . cnf4 () , self . mode5 () , self . cnf5 () , self . mode6 () , self . cnf6 () , self . mode7 () , self . cnf7 ()) } } # [doc = "input data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Idr (pub u32) ; impl Idr { # [doc = "Port input data"] # [must_use] # [inline (always)] pub const fn idr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Port input data"] # [inline (always)] pub const fn set_idr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Idr { # [inline (always)] fn default () -> Idr { Idr (0) } } impl core :: fmt :: Debug for Idr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Idr") . field ("idr" , & self . idr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Idr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Idr {{ idr: {=u16:?} }}" , self . idr ()) } } # [doc = "Port configuration lock register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Lckr (pub u32) ; impl Lckr { # [doc = "Port x Lock bit y"] # [must_use] # [inline (always)] pub const fn lck (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Port x Lock bit y"] # [inline (always)] pub const fn set_lck (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Lock key"] # [must_use] # [inline (always)] pub const fn lckk (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Lock key"] # [inline (always)] pub const fn set_lckk (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } } impl Default for Lckr { # [inline (always)] fn default () -> Lckr { Lckr (0) } } impl core :: fmt :: Debug for Lckr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lckr") . field ("lck" , & self . lck ()) . field ("lckk" , & self . lckk ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Lckr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Lckr {{ lck: {=u16:?}, lckk: {=bool:?} }}" , self . lck () , self . lckk ()) } } # [doc = "output data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Odr (pub u32) ; impl Odr { # [doc = "Port output data"] # [must_use] # [inline (always)] pub const fn odr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Port output data"] # [inline (always)] pub const fn set_odr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Odr { # [inline (always)] fn default () -> Odr { Odr (0) } } impl core :: fmt :: Debug for Odr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Odr") . field ("odr" , & self . odr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Odr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Odr {{ odr: {=u16:?} }}" , self . odr ()) } } } } pub mod i2c1 { # [doc = "Inter integrated circuit"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct I2c1 { ptr : * mut u8 } unsafe impl Send for I2c1 { } unsafe impl Sync for I2c1 { } impl I2c1 { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Control Register"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Target Register"] # [inline (always)] pub const fn tar (self) -> crate :: common :: Reg < regs :: Tar , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Slave Address Register"] # [inline (always)] pub const fn sar (self) -> crate :: common :: Reg < regs :: Sar , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "Data Command Register"] # [inline (always)] pub const fn dr (self) -> crate :: common :: Reg < regs :: Dr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "SCL High Period Count for Std. Speed Register"] # [inline (always)] pub const fn sshr (self) -> crate :: common :: Reg < regs :: Sshr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "SCL Low Period Count for Std. Speed Register"] # [inline (always)] pub const fn sslr (self) -> crate :: common :: Reg < regs :: Sslr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "SCL High Period Count for Fast Speed Register"] # [inline (always)] pub const fn fshr (self) -> crate :: common :: Reg < regs :: Fshr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "SCL Low Period Count for Fast Speed Register"] # [inline (always)] pub const fn fslr (self) -> crate :: common :: Reg < regs :: Fslr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "Interrupt Status Register"] # [inline (always)] pub const fn isr (self) -> crate :: common :: Reg < regs :: Isr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x2cusize) as _) } } # [doc = "Interrupt Mask Register"] # [inline (always)] pub const fn imr (self) -> crate :: common :: Reg < regs :: Imr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x30usize) as _) } } # [doc = "RAW Interrupt Status Register"] # [inline (always)] pub const fn rawisr (self) -> crate :: common :: Reg < regs :: Rawisr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x34usize) as _) } } # [doc = "Receive FIFO Threshold Level Register"] # [inline (always)] pub const fn rxtlr (self) -> crate :: common :: Reg < regs :: Rxtlr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x38usize) as _) } } # [doc = "Transmit FIFO Threshold Level Register"] # [inline (always)] pub const fn txtlr (self) -> crate :: common :: Reg < regs :: Txtlr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x3cusize) as _) } } # [doc = "Clear All Interrupt Register"] # [inline (always)] pub const fn icr (self) -> crate :: common :: Reg < regs :: Icr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x40usize) as _) } } # [doc = "Clear RX_UNDER Interrupt Register"] # [inline (always)] pub const fn rx_under (self) -> crate :: common :: Reg < regs :: RxUnder , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x44usize) as _) } } # [doc = "Clear RX_OVER Interrupt Register"] # [inline (always)] pub const fn rx_over (self) -> crate :: common :: Reg < regs :: RxOver , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x48usize) as _) } } # [doc = "Clear TX_OVER Interrupt Register"] # [inline (always)] pub const fn tx_over (self) -> crate :: common :: Reg < regs :: TxOver , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x4cusize) as _) } } # [doc = "Clear RD_REQ Interrupt Register"] # [inline (always)] pub const fn rd_req (self) -> crate :: common :: Reg < regs :: RdReq , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x50usize) as _) } } # [doc = "Clear TX_ABRT Interrupt Register"] # [inline (always)] pub const fn tx_abrt (self) -> crate :: common :: Reg < regs :: TxAbrt , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x54usize) as _) } } # [doc = "Clear RX_DONE Interrupt Register"] # [inline (always)] pub const fn rx_done (self) -> crate :: common :: Reg < regs :: RxDone , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x58usize) as _) } } # [doc = "Clear ACTIVITY Interrupt Register"] # [inline (always)] pub const fn activ (self) -> crate :: common :: Reg < regs :: Activ , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x5cusize) as _) } } # [doc = "Clear STOP_DET Interrupt Register"] # [inline (always)] pub const fn stop (self) -> crate :: common :: Reg < regs :: Stop , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x60usize) as _) } } # [doc = "Clear START_DET Interrupt Register"] # [inline (always)] pub const fn start (self) -> crate :: common :: Reg < regs :: Start , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x64usize) as _) } } # [doc = "Clear GEN_CALL Interrupt Register"] # [inline (always)] pub const fn gc (self) -> crate :: common :: Reg < regs :: Gc , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x68usize) as _) } } # [doc = "Enable Register"] # [inline (always)] pub const fn enr (self) -> crate :: common :: Reg < regs :: Enr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x6cusize) as _) } } # [doc = "Status Register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x70usize) as _) } } # [doc = "Transmit FIFO Level Register"] # [inline (always)] pub const fn txflr (self) -> crate :: common :: Reg < regs :: Txflr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x74usize) as _) } } # [doc = "Receive FIFO Level Register"] # [inline (always)] pub const fn rxflr (self) -> crate :: common :: Reg < regs :: Rxflr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x78usize) as _) } } # [doc = "SDA Hold Time Register"] # [inline (always)] pub const fn hold (self) -> crate :: common :: Reg < regs :: Hold , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x7cusize) as _) } } # [doc = "DMA Control Register"] # [inline (always)] pub const fn dma (self) -> crate :: common :: Reg < regs :: Dma , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x88usize) as _) } } # [doc = "SDA Setup Time Register"] # [inline (always)] pub const fn setup (self) -> crate :: common :: Reg < regs :: Setup , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x94usize) as _) } } # [doc = "ACK General Call Register"] # [inline (always)] pub const fn gcr (self) -> crate :: common :: Reg < regs :: Gcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x98usize) as _) } } } pub mod regs { # [doc = "Clear ACTIVITY Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Activ (pub u32) ; impl Activ { # [doc = "Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore"] # [must_use] # [inline (always)] pub const fn activ (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore"] # [inline (always)] pub const fn set_activ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Activ { # [inline (always)] fn default () -> Activ { Activ (0) } } impl core :: fmt :: Debug for Activ { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Activ") . field ("activ" , & self . activ ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Activ { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Activ {{ activ: {=bool:?} }}" , self . activ ()) } } # [doc = "Control Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "This bit controls whether the DW_apb_i2c master is enabled"] # [must_use] # [inline (always)] pub const fn master (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "This bit controls whether the DW_apb_i2c master is enabled"] # [inline (always)] pub const fn set_master (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "These bits control at which speed the DW_apb_i2c operates"] # [must_use] # [inline (always)] pub const fn speed (& self) -> u8 { let val = (self . 0 >> 1usize) & 0x03 ; val as u8 } # [doc = "These bits control at which speed the DW_apb_i2c operates"] # [inline (always)] pub const fn set_speed (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 1usize)) | (((val as u32) & 0x03) << 1usize) ; } # [doc = "When acting as a alsve"] # [must_use] # [inline (always)] pub const fn slave10 (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "When acting as a alsve"] # [inline (always)] pub const fn set_slave10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Address mode when acting as a master"] # [must_use] # [inline (always)] pub const fn master10 (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Address mode when acting as a master"] # [inline (always)] pub const fn set_master10 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Determines whether RESTART comdtions may be sent when acting as a master"] # [must_use] # [inline (always)] pub const fn repen (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Determines whether RESTART comdtions may be sent when acting as a master"] # [inline (always)] pub const fn set_repen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "This bit controls whether I2C has its slave diabled"] # [must_use] # [inline (always)] pub const fn disslave (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "This bit controls whether I2C has its slave diabled"] # [inline (always)] pub const fn set_disslave (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "STOP_DET_IFADDRESSED"] # [must_use] # [inline (always)] pub const fn stopint (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "STOP_DET_IFADDRESSED"] # [inline (always)] pub const fn set_stopint (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "This bit controls the generation of the TX_EMPTY interrupt"] # [must_use] # [inline (always)] pub const fn empint (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "This bit controls the generation of the TX_EMPTY interrupt"] # [inline (always)] pub const fn set_empint (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Whether to generate a STOP signal after sending or receiving"] # [must_use] # [inline (always)] pub const fn stop (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Whether to generate a STOP signal after sending or receiving"] # [inline (always)] pub const fn set_stop (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Whether to generate a RESTART signal after sending or receiving"] # [must_use] # [inline (always)] pub const fn restart (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Whether to generate a RESTART signal after sending or receiving"] # [inline (always)] pub const fn set_restart (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("master" , & self . master ()) . field ("speed" , & self . speed ()) . field ("slave10" , & self . slave10 ()) . field ("master10" , & self . master10 ()) . field ("repen" , & self . repen ()) . field ("disslave" , & self . disslave ()) . field ("stopint" , & self . stopint ()) . field ("empint" , & self . empint ()) . field ("stop" , & self . stop ()) . field ("restart" , & self . restart ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ master: {=bool:?}, speed: {=u8:?}, slave10: {=bool:?}, master10: {=bool:?}, repen: {=bool:?}, disslave: {=bool:?}, stopint: {=bool:?}, empint: {=bool:?}, stop: {=bool:?}, restart: {=bool:?} }}" , self . master () , self . speed () , self . slave10 () , self . master10 () , self . repen () , self . disslave () , self . stopint () , self . empint () , self . stop () , self . restart ()) } } # [doc = "DMA Control Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dma (pub u32) ; impl Dma { # [doc = "Receive DMA enable"] # [must_use] # [inline (always)] pub const fn rxen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Receive DMA enable"] # [inline (always)] pub const fn set_rxen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Transmit DMA enable"] # [must_use] # [inline (always)] pub const fn txen (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Transmit DMA enable"] # [inline (always)] pub const fn set_txen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } } impl Default for Dma { # [inline (always)] fn default () -> Dma { Dma (0) } } impl core :: fmt :: Debug for Dma { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma") . field ("rxen" , & self . rxen ()) . field ("txen" , & self . txen ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dma { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dma {{ rxen: {=bool:?}, txen: {=bool:?} }}" , self . rxen () , self . txen ()) } } # [doc = "Data Command Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dr (pub u32) ; impl Dr { # [doc = "This register contains the data to be transimitted or received on the i2c bus."] # [must_use] # [inline (always)] pub const fn dat (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "This register contains the data to be transimitted or received on the i2c bus."] # [inline (always)] pub const fn set_dat (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } # [doc = "This bit controls whether a read or a write is perormed"] # [must_use] # [inline (always)] pub const fn cmd (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "This bit controls whether a read or a write is perormed"] # [inline (always)] pub const fn set_cmd (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } } impl Default for Dr { # [inline (always)] fn default () -> Dr { Dr (0) } } impl core :: fmt :: Debug for Dr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dr") . field ("dat" , & self . dat ()) . field ("cmd" , & self . cmd ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dr {{ dat: {=u8:?}, cmd: {=bool:?} }}" , self . dat () , self . cmd ()) } } # [doc = "Enable Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Enr (pub u32) ; impl Enr { # [doc = "I2C mode enable"] # [must_use] # [inline (always)] pub const fn enable (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "I2C mode enable"] # [inline (always)] pub const fn set_enable (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "I2C transfer abort"] # [must_use] # [inline (always)] pub const fn abort (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "I2C transfer abort"] # [inline (always)] pub const fn set_abort (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } } impl Default for Enr { # [inline (always)] fn default () -> Enr { Enr (0) } } impl core :: fmt :: Debug for Enr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Enr") . field ("enable" , & self . enable ()) . field ("abort" , & self . abort ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Enr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Enr {{ enable: {=bool:?}, abort: {=bool:?} }}" , self . enable () , self . abort ()) } } # [doc = "SCL High Period Count for Fast Speed Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Fshr (pub u32) ; impl Fshr { # [doc = "This register sets the SCL clock high_period count for standard speed"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "This register sets the SCL clock high_period count for standard speed"] # [inline (always)] pub const fn set_cnt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Fshr { # [inline (always)] fn default () -> Fshr { Fshr (0) } } impl core :: fmt :: Debug for Fshr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fshr") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Fshr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Fshr {{ cnt: {=u16:?} }}" , self . cnt ()) } } # [doc = "SCL Low Period Count for Fast Speed Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Fslr (pub u32) ; impl Fslr { # [doc = "This register sets the SCL clock low period count for standard speed"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "This register sets the SCL clock low period count for standard speed"] # [inline (always)] pub const fn set_cnt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Fslr { # [inline (always)] fn default () -> Fslr { Fslr (0) } } impl core :: fmt :: Debug for Fslr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fslr") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Fslr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Fslr {{ cnt: {=u16:?} }}" , self . cnt ()) } } # [doc = "Clear GEN_CALL Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Gc (pub u32) ; impl Gc { # [doc = "Read this register to clear the GEN_CALL interrupt(bit 11)of the RAWISR register"] # [must_use] # [inline (always)] pub const fn gc (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the GEN_CALL interrupt(bit 11)of the RAWISR register"] # [inline (always)] pub const fn set_gc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Gc { # [inline (always)] fn default () -> Gc { Gc (0) } } impl core :: fmt :: Debug for Gc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gc") . field ("gc" , & self . gc ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Gc { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Gc {{ gc: {=bool:?} }}" , self . gc ()) } } # [doc = "ACK General Call Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Gcr (pub u32) ; impl Gcr { # [doc = "ACK general call"] # [must_use] # [inline (always)] pub const fn gc (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "ACK general call"] # [inline (always)] pub const fn set_gc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Gcr { # [inline (always)] fn default () -> Gcr { Gcr (0) } } impl core :: fmt :: Debug for Gcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gcr") . field ("gc" , & self . gc ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Gcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Gcr {{ gc: {=bool:?} }}" , self . gc ()) } } # [doc = "SDA Hold Time Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Hold (pub u32) ; impl Hold { # [doc = "Sets the required SDA hold time in units of ic_clk period"] # [must_use] # [inline (always)] pub const fn tx_hold (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Sets the required SDA hold time in units of ic_clk period"] # [inline (always)] pub const fn set_tx_hold (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } # [doc = "Sets the required SDA hold time in units of ic_clk period"] # [must_use] # [inline (always)] pub const fn rx_hold (& self) -> u8 { let val = (self . 0 >> 16usize) & 0xff ; val as u8 } # [doc = "Sets the required SDA hold time in units of ic_clk period"] # [inline (always)] pub const fn set_rx_hold (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 16usize)) | (((val as u32) & 0xff) << 16usize) ; } } impl Default for Hold { # [inline (always)] fn default () -> Hold { Hold (0) } } impl core :: fmt :: Debug for Hold { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Hold") . field ("tx_hold" , & self . tx_hold ()) . field ("rx_hold" , & self . rx_hold ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Hold { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Hold {{ tx_hold: {=u16:?}, rx_hold: {=u8:?} }}" , self . tx_hold () , self . rx_hold ()) } } # [doc = "Clear All Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Icr (pub u32) ; impl Icr { # [doc = "Read this register to clear the combined interrupt"] # [must_use] # [inline (always)] pub const fn icr (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the combined interrupt"] # [inline (always)] pub const fn set_icr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Icr { # [inline (always)] fn default () -> Icr { Icr (0) } } impl core :: fmt :: Debug for Icr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Icr") . field ("icr" , & self . icr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Icr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Icr {{ icr: {=bool:?} }}" , self . icr ()) } } # [doc = "Interrupt Mask Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Imr (pub u32) ; impl Imr { # [doc = "Specific bit description shield RAWISR"] # [must_use] # [inline (always)] pub const fn imr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x07ff ; val as u16 } # [doc = "Specific bit description shield RAWISR"] # [inline (always)] pub const fn set_imr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize) ; } } impl Default for Imr { # [inline (always)] fn default () -> Imr { Imr (0) } } impl core :: fmt :: Debug for Imr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Imr") . field ("imr" , & self . imr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Imr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Imr {{ imr: {=u16:?} }}" , self . imr ()) } } # [doc = "Interrupt Status Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Isr (pub u32) ; impl Isr { # [doc = "Specific bit description refer to RAWISR"] # [must_use] # [inline (always)] pub const fn isr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x07ff ; val as u16 } # [doc = "Specific bit description refer to RAWISR"] # [inline (always)] pub const fn set_isr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize) ; } } impl Default for Isr { # [inline (always)] fn default () -> Isr { Isr (0) } } impl core :: fmt :: Debug for Isr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Isr") . field ("isr" , & self . isr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Isr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Isr {{ isr: {=u16:?} }}" , self . isr ()) } } # [doc = "RAW Interrupt Status Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rawisr (pub u32) ; impl Rawisr { # [doc = "Receive buffer under"] # [must_use] # [inline (always)] pub const fn rx_under (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Receive buffer under"] # [inline (always)] pub const fn set_rx_under (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Receive buffer over"] # [must_use] # [inline (always)] pub const fn rx_over (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Receive buffer over"] # [inline (always)] pub const fn set_rx_over (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Receive buffer not empty"] # [must_use] # [inline (always)] pub const fn rx_full (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Receive buffer not empty"] # [inline (always)] pub const fn set_rx_full (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Transmit buffer over"] # [must_use] # [inline (always)] pub const fn tx_over (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Transmit buffer over"] # [inline (always)] pub const fn set_tx_over (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Transmit buffer empty"] # [must_use] # [inline (always)] pub const fn tx_empty (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Transmit buffer empty"] # [inline (always)] pub const fn set_tx_empty (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Read request"] # [must_use] # [inline (always)] pub const fn rd_req (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Read request"] # [inline (always)] pub const fn set_rd_req (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Transmit abort"] # [must_use] # [inline (always)] pub const fn tx_abrt (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Transmit abort"] # [inline (always)] pub const fn set_tx_abrt (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Transmit done"] # [must_use] # [inline (always)] pub const fn rx_done (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Transmit done"] # [inline (always)] pub const fn set_rx_done (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "This bit captures DW_spb_i2c acticity and stays set until it is cleared"] # [must_use] # [inline (always)] pub const fn activ (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "This bit captures DW_spb_i2c acticity and stays set until it is cleared"] # [inline (always)] pub const fn set_activ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Stop condition detection"] # [must_use] # [inline (always)] pub const fn stop (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Stop condition detection"] # [inline (always)] pub const fn set_stop (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Start condition detection"] # [must_use] # [inline (always)] pub const fn start (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Start condition detection"] # [inline (always)] pub const fn set_start (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "General call"] # [must_use] # [inline (always)] pub const fn gc (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "General call"] # [inline (always)] pub const fn set_gc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "RESTART_DET interrupt status"] # [must_use] # [inline (always)] pub const fn restart (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "RESTART_DET interrupt status"] # [inline (always)] pub const fn set_restart (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "MST_ON_HOLD interrupt status"] # [must_use] # [inline (always)] pub const fn hold (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "MST_ON_HOLD interrupt status"] # [inline (always)] pub const fn set_hold (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } } impl Default for Rawisr { # [inline (always)] fn default () -> Rawisr { Rawisr (0) } } impl core :: fmt :: Debug for Rawisr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rawisr") . field ("rx_under" , & self . rx_under ()) . field ("rx_over" , & self . rx_over ()) . field ("rx_full" , & self . rx_full ()) . field ("tx_over" , & self . tx_over ()) . field ("tx_empty" , & self . tx_empty ()) . field ("rd_req" , & self . rd_req ()) . field ("tx_abrt" , & self . tx_abrt ()) . field ("rx_done" , & self . rx_done ()) . field ("activ" , & self . activ ()) . field ("stop" , & self . stop ()) . field ("start" , & self . start ()) . field ("gc" , & self . gc ()) . field ("restart" , & self . restart ()) . field ("hold" , & self . hold ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rawisr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rawisr {{ rx_under: {=bool:?}, rx_over: {=bool:?}, rx_full: {=bool:?}, tx_over: {=bool:?}, tx_empty: {=bool:?}, rd_req: {=bool:?}, tx_abrt: {=bool:?}, rx_done: {=bool:?}, activ: {=bool:?}, stop: {=bool:?}, start: {=bool:?}, gc: {=bool:?}, restart: {=bool:?}, hold: {=bool:?} }}" , self . rx_under () , self . rx_over () , self . rx_full () , self . tx_over () , self . tx_empty () , self . rd_req () , self . tx_abrt () , self . rx_done () , self . activ () , self . stop () , self . start () , self . gc () , self . restart () , self . hold ()) } } # [doc = "Clear RD_REQ Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct RdReq (pub u32) ; impl RdReq { # [doc = "Read this register to clear the RX_UNDER interrupt(bit 5)of the RAWISR register"] # [must_use] # [inline (always)] pub const fn rd_req (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the RX_UNDER interrupt(bit 5)of the RAWISR register"] # [inline (always)] pub const fn set_rd_req (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for RdReq { # [inline (always)] fn default () -> RdReq { RdReq (0) } } impl core :: fmt :: Debug for RdReq { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RdReq") . field ("rd_req" , & self . rd_req ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for RdReq { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "RdReq {{ rd_req: {=bool:?} }}" , self . rd_req ()) } } # [doc = "Clear RX_DONE Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct RxDone (pub u32) ; impl RxDone { # [doc = "Read this register to clear the RX_UNDER interrupt(bit 7)of the RAWISR register"] # [must_use] # [inline (always)] pub const fn rx_done (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the RX_UNDER interrupt(bit 7)of the RAWISR register"] # [inline (always)] pub const fn set_rx_done (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for RxDone { # [inline (always)] fn default () -> RxDone { RxDone (0) } } impl core :: fmt :: Debug for RxDone { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RxDone") . field ("rx_done" , & self . rx_done ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for RxDone { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "RxDone {{ rx_done: {=bool:?} }}" , self . rx_done ()) } } # [doc = "Clear RX_OVER Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct RxOver (pub u32) ; impl RxOver { # [doc = "Read this register to clear the RX_UNDER interrupt(bit 1)of the RAWISR register"] # [must_use] # [inline (always)] pub const fn rx_over (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the RX_UNDER interrupt(bit 1)of the RAWISR register"] # [inline (always)] pub const fn set_rx_over (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for RxOver { # [inline (always)] fn default () -> RxOver { RxOver (0) } } impl core :: fmt :: Debug for RxOver { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RxOver") . field ("rx_over" , & self . rx_over ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for RxOver { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "RxOver {{ rx_over: {=bool:?} }}" , self . rx_over ()) } } # [doc = "Clear RX_UNDER Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct RxUnder (pub u32) ; impl RxUnder { # [doc = "Read this register to clear the RX_UNDER interrupt(bit 0)of the RAWISR register"] # [must_use] # [inline (always)] pub const fn rx_under (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the RX_UNDER interrupt(bit 0)of the RAWISR register"] # [inline (always)] pub const fn set_rx_under (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for RxUnder { # [inline (always)] fn default () -> RxUnder { RxUnder (0) } } impl core :: fmt :: Debug for RxUnder { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RxUnder") . field ("rx_under" , & self . rx_under ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for RxUnder { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "RxUnder {{ rx_under: {=bool:?} }}" , self . rx_under ()) } } # [doc = "Receive FIFO Level Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rxflr (pub u32) ; impl Rxflr { # [doc = "Receive FIFO level. Contains the number of valid data entires in the receive FIFO"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Receive FIFO level. Contains the number of valid data entires in the receive FIFO"] # [inline (always)] pub const fn set_cnt (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } } impl Default for Rxflr { # [inline (always)] fn default () -> Rxflr { Rxflr (0) } } impl core :: fmt :: Debug for Rxflr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rxflr") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rxflr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rxflr {{ cnt: {=u8:?} }}" , self . cnt ()) } } # [doc = "Receive FIFO Threshold Level Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rxtlr (pub u32) ; impl Rxtlr { # [doc = "Receive FIFO threshold level"] # [must_use] # [inline (always)] pub const fn tl (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Receive FIFO threshold level"] # [inline (always)] pub const fn set_tl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Rxtlr { # [inline (always)] fn default () -> Rxtlr { Rxtlr (0) } } impl core :: fmt :: Debug for Rxtlr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rxtlr") . field ("tl" , & self . tl ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rxtlr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rxtlr {{ tl: {=u8:?} }}" , self . tl ()) } } # [doc = "Slave Address Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sar (pub u32) ; impl Sar { # [doc = "The SAR holds the slave address when the i2c is operation as a slave"] # [must_use] # [inline (always)] pub const fn addr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x03ff ; val as u16 } # [doc = "The SAR holds the slave address when the i2c is operation as a slave"] # [inline (always)] pub const fn set_addr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize) ; } } impl Default for Sar { # [inline (always)] fn default () -> Sar { Sar (0) } } impl core :: fmt :: Debug for Sar { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sar") . field ("addr" , & self . addr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sar { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sar {{ addr: {=u16:?} }}" , self . addr ()) } } # [doc = "SDA Setup Time Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Setup (pub u32) ; impl Setup { # [doc = "SDA setup"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "SDA setup"] # [inline (always)] pub const fn set_cnt (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Setup { # [inline (always)] fn default () -> Setup { Setup (0) } } impl core :: fmt :: Debug for Setup { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Setup") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Setup { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Setup {{ cnt: {=u8:?} }}" , self . cnt ()) } } # [doc = "Status Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "I2C activity status"] # [must_use] # [inline (always)] pub const fn activ (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "I2C activity status"] # [inline (always)] pub const fn set_activ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Transmit FIFO not full"] # [must_use] # [inline (always)] pub const fn tfnf (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Transmit FIFO not full"] # [inline (always)] pub const fn set_tfnf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Transmit FIFO completely empty"] # [must_use] # [inline (always)] pub const fn tfe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Transmit FIFO completely empty"] # [inline (always)] pub const fn set_tfe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Receive FIFO not empty"] # [must_use] # [inline (always)] pub const fn rfne (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Receive FIFO not empty"] # [inline (always)] pub const fn set_rfne (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Receive FIFO completely full"] # [must_use] # [inline (always)] pub const fn rff (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Receive FIFO completely full"] # [inline (always)] pub const fn set_rff (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Master FSM activity status"] # [must_use] # [inline (always)] pub const fn mst_activ (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Master FSM activity status"] # [inline (always)] pub const fn set_mst_activ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Slave FSM activity status"] # [must_use] # [inline (always)] pub const fn slv_activ (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Slave FSM activity status"] # [inline (always)] pub const fn set_slv_activ (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("activ" , & self . activ ()) . field ("tfnf" , & self . tfnf ()) . field ("tfe" , & self . tfe ()) . field ("rfne" , & self . rfne ()) . field ("rff" , & self . rff ()) . field ("mst_activ" , & self . mst_activ ()) . field ("slv_activ" , & self . slv_activ ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ activ: {=bool:?}, tfnf: {=bool:?}, tfe: {=bool:?}, rfne: {=bool:?}, rff: {=bool:?}, mst_activ: {=bool:?}, slv_activ: {=bool:?} }}" , self . activ () , self . tfnf () , self . tfe () , self . rfne () , self . rff () , self . mst_activ () , self . slv_activ ()) } } # [doc = "SCL High Period Count for Std. Speed Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sshr (pub u32) ; impl Sshr { # [doc = "This register sets the SCL clock high period count for standard speed"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "This register sets the SCL clock high period count for standard speed"] # [inline (always)] pub const fn set_cnt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Sshr { # [inline (always)] fn default () -> Sshr { Sshr (0) } } impl core :: fmt :: Debug for Sshr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sshr") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sshr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sshr {{ cnt: {=u16:?} }}" , self . cnt ()) } } # [doc = "SCL Low Period Count for Std. Speed Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sslr (pub u32) ; impl Sslr { # [doc = "This register sets the SCL clock low period count for standard speed"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "This register sets the SCL clock low period count for standard speed"] # [inline (always)] pub const fn set_cnt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Sslr { # [inline (always)] fn default () -> Sslr { Sslr (0) } } impl core :: fmt :: Debug for Sslr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sslr") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sslr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sslr {{ cnt: {=u16:?} }}" , self . cnt ()) } } # [doc = "Clear START_DET Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Start (pub u32) ; impl Start { # [doc = "Read this register to clear the START_DET interrupt(bit 10)of the RAWISR register"] # [must_use] # [inline (always)] pub const fn start (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the START_DET interrupt(bit 10)of the RAWISR register"] # [inline (always)] pub const fn set_start (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Start { # [inline (always)] fn default () -> Start { Start (0) } } impl core :: fmt :: Debug for Start { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Start") . field ("start" , & self . start ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Start { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Start {{ start: {=bool:?} }}" , self . start ()) } } # [doc = "Clear STOP_DET Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Stop (pub u32) ; impl Stop { # [doc = "Read this register to clear the STOP_DET interrupt(bit 9)of the RAWISR register"] # [must_use] # [inline (always)] pub const fn stop (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the STOP_DET interrupt(bit 9)of the RAWISR register"] # [inline (always)] pub const fn set_stop (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Stop { # [inline (always)] fn default () -> Stop { Stop (0) } } impl core :: fmt :: Debug for Stop { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Stop") . field ("stop" , & self . stop ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Stop { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Stop {{ stop: {=bool:?} }}" , self . stop ()) } } # [doc = "Target Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Tar (pub u32) ; impl Tar { # [doc = "This is the target address for any master transaction"] # [must_use] # [inline (always)] pub const fn addr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x03ff ; val as u16 } # [doc = "This is the target address for any master transaction"] # [inline (always)] pub const fn set_addr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize) ; } # [doc = "If bit 11(SPECIAL)is set to 1"] # [must_use] # [inline (always)] pub const fn gc (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "If bit 11(SPECIAL)is set to 1"] # [inline (always)] pub const fn set_gc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "This bit indicates whether software performs a General Call or START BYTE conmmend"] # [must_use] # [inline (always)] pub const fn special (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "This bit indicates whether software performs a General Call or START BYTE conmmend"] # [inline (always)] pub const fn set_special (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } } impl Default for Tar { # [inline (always)] fn default () -> Tar { Tar (0) } } impl core :: fmt :: Debug for Tar { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tar") . field ("addr" , & self . addr ()) . field ("gc" , & self . gc ()) . field ("special" , & self . special ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Tar { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Tar {{ addr: {=u16:?}, gc: {=bool:?}, special: {=bool:?} }}" , self . addr () , self . gc () , self . special ()) } } # [doc = "Clear TX_ABRT Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct TxAbrt (pub u32) ; impl TxAbrt { # [doc = "Read this register to clear the RX_UNDER interrupt(bit 6)of the RAWISR register"] # [must_use] # [inline (always)] pub const fn tx_abrt (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the RX_UNDER interrupt(bit 6)of the RAWISR register"] # [inline (always)] pub const fn set_tx_abrt (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for TxAbrt { # [inline (always)] fn default () -> TxAbrt { TxAbrt (0) } } impl core :: fmt :: Debug for TxAbrt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TxAbrt") . field ("tx_abrt" , & self . tx_abrt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for TxAbrt { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "TxAbrt {{ tx_abrt: {=bool:?} }}" , self . tx_abrt ()) } } # [doc = "Clear TX_OVER Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct TxOver (pub u32) ; impl TxOver { # [doc = "Read this register to clear the RX_UNDER interrupt(bit 3)of the RAWISR register"] # [must_use] # [inline (always)] pub const fn tx_over (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Read this register to clear the RX_UNDER interrupt(bit 3)of the RAWISR register"] # [inline (always)] pub const fn set_tx_over (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for TxOver { # [inline (always)] fn default () -> TxOver { TxOver (0) } } impl core :: fmt :: Debug for TxOver { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TxOver") . field ("tx_over" , & self . tx_over ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for TxOver { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "TxOver {{ tx_over: {=bool:?} }}" , self . tx_over ()) } } # [doc = "Transmit FIFO Level Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Txflr (pub u32) ; impl Txflr { # [doc = "Transmit FIFO level.Contains the number of valid data entires in the transmit FIFO"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Transmit FIFO level.Contains the number of valid data entires in the transmit FIFO"] # [inline (always)] pub const fn set_cnt (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } } impl Default for Txflr { # [inline (always)] fn default () -> Txflr { Txflr (0) } } impl core :: fmt :: Debug for Txflr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Txflr") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Txflr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Txflr {{ cnt: {=u8:?} }}" , self . cnt ()) } } # [doc = "Transmit FIFO Threshold Level Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Txtlr (pub u32) ; impl Txtlr { # [doc = "Transmit FIFO threshold level"] # [must_use] # [inline (always)] pub const fn tl (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Transmit FIFO threshold level"] # [inline (always)] pub const fn set_tl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Txtlr { # [inline (always)] fn default () -> Txtlr { Txtlr (0) } } impl core :: fmt :: Debug for Txtlr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Txtlr") . field ("tl" , & self . tl ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Txtlr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Txtlr {{ tl: {=u8:?} }}" , self . tl ()) } } } } pub mod iwdg { # [doc = "Independent watchdog"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Iwdg { ptr : * mut u8 } unsafe impl Send for Iwdg { } unsafe impl Sync for Iwdg { } impl Iwdg { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Key register"] # [inline (always)] pub const fn kr (self) -> crate :: common :: Reg < regs :: Kr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Prescaler register"] # [inline (always)] pub const fn pr (self) -> crate :: common :: Reg < regs :: Pr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Reload register"] # [inline (always)] pub const fn rlr (self) -> crate :: common :: Reg < regs :: Rlr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "Status register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "Control register"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } } pub mod regs { # [doc = "Control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "Interruput select"] # [must_use] # [inline (always)] pub const fn irq_sel (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Interruput select"] # [inline (always)] pub const fn set_irq_sel (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Interruput clear"] # [must_use] # [inline (always)] pub const fn irq_clr (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Interruput clear"] # [inline (always)] pub const fn set_irq_clr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("irq_sel" , & self . irq_sel ()) . field ("irq_clr" , & self . irq_clr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ irq_sel: {=bool:?}, irq_clr: {=bool:?} }}" , self . irq_sel () , self . irq_clr ()) } } # [doc = "Key register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Kr (pub u32) ; impl Kr { # [doc = "Key value"] # [must_use] # [inline (always)] pub const fn key (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Key value"] # [inline (always)] pub const fn set_key (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Kr { # [inline (always)] fn default () -> Kr { Kr (0) } } impl core :: fmt :: Debug for Kr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Kr") . field ("key" , & self . key ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Kr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Kr {{ key: {=u16:?} }}" , self . key ()) } } # [doc = "Prescaler register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Pr (pub u32) ; impl Pr { # [doc = "Prescaler divider"] # [must_use] # [inline (always)] pub const fn pr (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x07 ; val as u8 } # [doc = "Prescaler divider"] # [inline (always)] pub const fn set_pr (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize) ; } } impl Default for Pr { # [inline (always)] fn default () -> Pr { Pr (0) } } impl core :: fmt :: Debug for Pr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pr") . field ("pr" , & self . pr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Pr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Pr {{ pr: {=u8:?} }}" , self . pr ()) } } # [doc = "Reload register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rlr (pub u32) ; impl Rlr { # [doc = "Watchdog counter reload value"] # [must_use] # [inline (always)] pub const fn rl (& self) -> u16 { let val = (self . 0 >> 0usize) & 0x0fff ; val as u16 } # [doc = "Watchdog counter reload value"] # [inline (always)] pub const fn set_rl (& mut self , val : u16) { self . 0 = (self . 0 & ! (0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize) ; } } impl Default for Rlr { # [inline (always)] fn default () -> Rlr { Rlr (0) } } impl core :: fmt :: Debug for Rlr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rlr") . field ("rl" , & self . rl ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rlr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rlr {{ rl: {=u16:?} }}" , self . rl ()) } } # [doc = "Status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "Watchdog prescaler value update"] # [must_use] # [inline (always)] pub const fn pvu (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Watchdog prescaler value update"] # [inline (always)] pub const fn set_pvu (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Watchdog counter reload value update"] # [must_use] # [inline (always)] pub const fn rvu (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Watchdog counter reload value update"] # [inline (always)] pub const fn set_rvu (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("pvu" , & self . pvu ()) . field ("rvu" , & self . rvu ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ pvu: {=bool:?}, rvu: {=bool:?} }}" , self . pvu () , self . rvu ()) } } } } pub mod pwm { # [doc = "PWM Control"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Pwm { ptr : * mut u8 } unsafe impl Send for Pwm { } unsafe impl Sync for Pwm { } impl Pwm { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Control PWM output status register"] # [inline (always)] pub const fn csr (self) -> crate :: common :: Reg < regs :: Csr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Auto phase mask register"] # [inline (always)] pub const fn apmskr (self) -> crate :: common :: Reg < regs :: Apmskr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Auto phase mask dalay register"] # [inline (always)] pub const fn apmdlr (self) -> crate :: common :: Reg < regs :: Apmdlr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } } pub mod regs { # [doc = "Auto phase mask dalay register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Apmdlr (pub u32) ; impl Apmdlr { # [doc = "*D0"] # [must_use] # [inline (always)] pub const fn apmdlr (& self) -> u32 { let val = (self . 0 >> 0usize) & 0x03ff_ffff ; val as u32 } # [doc = "*D0"] # [inline (always)] pub const fn set_apmdlr (& mut self , val : u32) { self . 0 = (self . 0 & ! (0x03ff_ffff << 0usize)) | (((val as u32) & 0x03ff_ffff) << 0usize) ; } } impl Default for Apmdlr { # [inline (always)] fn default () -> Apmdlr { Apmdlr (0) } } impl core :: fmt :: Debug for Apmdlr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Apmdlr") . field ("apmdlr" , & self . apmdlr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Apmdlr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Apmdlr {{ apmdlr: {=u32:?} }}" , self . apmdlr ()) } } # [doc = "Auto phase mask register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Apmskr (pub u32) ; impl Apmskr { # [doc = "PWM Mask Data"] # [must_use] # [inline (always)] pub const fn mskdat (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x3f ; val as u8 } # [doc = "PWM Mask Data"] # [inline (always)] pub const fn set_mskdat (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize) ; } # [doc = "PWM Mask Function Enable"] # [must_use] # [inline (always)] pub const fn msken (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x3f ; val as u8 } # [doc = "PWM Mask Function Enable"] # [inline (always)] pub const fn set_msken (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize) ; } # [doc = "Auto Phase Mask Tigger Selection"] # [must_use] # [inline (always)] pub const fn apm_trigsel (& self) -> u8 { let val = (self . 0 >> 16usize) & 0x03 ; val as u8 } # [doc = "Auto Phase Mask Tigger Selection"] # [inline (always)] pub const fn set_apm_trigsel (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize) ; } # [doc = "Auto Phase Mask Software Trigger"] # [must_use] # [inline (always)] pub const fn apm_strg (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "Auto Phase Mask Software Trigger"] # [inline (always)] pub const fn set_apm_strg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "Expect Next Trigger Input"] # [must_use] # [inline (always)] pub const fn entrgi (& self) -> u8 { let val = (self . 0 >> 20usize) & 0x07 ; val as u8 } # [doc = "Expect Next Trigger Input"] # [inline (always)] pub const fn set_entrgi (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 20usize)) | (((val as u32) & 0x07) << 20usize) ; } # [doc = "Current Trigger Input"] # [must_use] # [inline (always)] pub const fn ctrgi (& self) -> u8 { let val = (self . 0 >> 23usize) & 0x07 ; val as u8 } # [doc = "Current Trigger Input"] # [inline (always)] pub const fn set_ctrgi (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 23usize)) | (((val as u32) & 0x07) << 23usize) ; } } impl Default for Apmskr { # [inline (always)] fn default () -> Apmskr { Apmskr (0) } } impl core :: fmt :: Debug for Apmskr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Apmskr") . field ("mskdat" , & self . mskdat ()) . field ("msken" , & self . msken ()) . field ("apm_trigsel" , & self . apm_trigsel ()) . field ("apm_strg" , & self . apm_strg ()) . field ("entrgi" , & self . entrgi ()) . field ("ctrgi" , & self . ctrgi ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Apmskr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Apmskr {{ mskdat: {=u8:?}, msken: {=u8:?}, apm_trigsel: {=u8:?}, apm_strg: {=bool:?}, entrgi: {=u8:?}, ctrgi: {=u8:?} }}" , self . mskdat () , self . msken () , self . apm_trigsel () , self . apm_strg () , self . entrgi () , self . ctrgi ()) } } # [doc = "Control PWM output status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Csr (pub u32) ; impl Csr { # [doc = "Current Compensation Enable"] # [must_use] # [inline (always)] pub const fn cce (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Current Compensation Enable"] # [inline (always)] pub const fn set_cce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Current Protection Enable"] # [must_use] # [inline (always)] pub const fn cpe (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Current Protection Enable"] # [inline (always)] pub const fn set_cpe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Auto Phase Mask Trigger Interrupt Enable"] # [must_use] # [inline (always)] pub const fn apmtie (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Auto Phase Mask Trigger Interrupt Enable"] # [inline (always)] pub const fn set_apmtie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Trigger Error Interrupt Enable"] # [must_use] # [inline (always)] pub const fn terrie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Trigger Error Interrupt Enable"] # [inline (always)] pub const fn set_terrie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Current Protection Trigger Selection"] # [must_use] # [inline (always)] pub const fn cc_trgsel (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x03 ; val as u8 } # [doc = "Current Protection Trigger Selection"] # [inline (always)] pub const fn set_cc_trgsel (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize) ; } # [doc = "Current Compensation Software Trigger"] # [must_use] # [inline (always)] pub const fn cc_strg (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Current Compensation Software Trigger"] # [inline (always)] pub const fn set_cc_strg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Current Protection Mode Selection"] # [must_use] # [inline (always)] pub const fn cp_mdsel (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Current Protection Mode Selection"] # [inline (always)] pub const fn set_cp_mdsel (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Auto Phase Mask Trigger Flag"] # [must_use] # [inline (always)] pub const fn apmtif (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Auto Phase Mask Trigger Flag"] # [inline (always)] pub const fn set_apmtif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Trigger Error Flag"] # [must_use] # [inline (always)] pub const fn terrif (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Trigger Error Flag"] # [inline (always)] pub const fn set_terrif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "GPIO Input Filter"] # [must_use] # [inline (always)] pub const fn ioflt (& self) -> u8 { let val = (self . 0 >> 13usize) & 0x07 ; val as u8 } # [doc = "GPIO Input Filter"] # [inline (always)] pub const fn set_ioflt (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 13usize)) | (((val as u32) & 0x07) << 13usize) ; } # [doc = "Hall Sensor Trigger 3-channel select"] # [must_use] # [inline (always)] pub const fn hall_trgsel (& self) -> u8 { let val = (self . 0 >> 16usize) & 0x03 ; val as u8 } # [doc = "Hall Sensor Trigger 3-channel select"] # [inline (always)] pub const fn set_hall_trgsel (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 16usize)) | (((val as u32) & 0x03) << 16usize) ; } # [doc = "Enable Current Input Status Value"] # [must_use] # [inline (always)] pub const fn curen (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "Enable Current Input Status Value"] # [inline (always)] pub const fn set_curen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "Immediate Output of The Port when PWM is Masked"] # [must_use] # [inline (always)] pub const fn mskdat (& self) -> u8 { let val = (self . 0 >> 19usize) & 0x3f ; val as u8 } # [doc = "Immediate Output of The Port when PWM is Masked"] # [inline (always)] pub const fn set_mskdat (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x3f << 19usize)) | (((val as u32) & 0x3f) << 19usize) ; } # [doc = "PWM Output Mask Immediately Enable"] # [must_use] # [inline (always)] pub const fn msken_curr (& self) -> u8 { let val = (self . 0 >> 25usize) & 0x3f ; val as u8 } # [doc = "PWM Output Mask Immediately Enable"] # [inline (always)] pub const fn set_msken_curr (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x3f << 25usize)) | (((val as u32) & 0x3f) << 25usize) ; } } impl Default for Csr { # [inline (always)] fn default () -> Csr { Csr (0) } } impl core :: fmt :: Debug for Csr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Csr") . field ("cce" , & self . cce ()) . field ("cpe" , & self . cpe ()) . field ("apmtie" , & self . apmtie ()) . field ("terrie" , & self . terrie ()) . field ("cc_trgsel" , & self . cc_trgsel ()) . field ("cc_strg" , & self . cc_strg ()) . field ("cp_mdsel" , & self . cp_mdsel ()) . field ("apmtif" , & self . apmtif ()) . field ("terrif" , & self . terrif ()) . field ("ioflt" , & self . ioflt ()) . field ("hall_trgsel" , & self . hall_trgsel ()) . field ("curen" , & self . curen ()) . field ("mskdat" , & self . mskdat ()) . field ("msken_curr" , & self . msken_curr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Csr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Csr {{ cce: {=bool:?}, cpe: {=bool:?}, apmtie: {=bool:?}, terrie: {=bool:?}, cc_trgsel: {=u8:?}, cc_strg: {=bool:?}, cp_mdsel: {=bool:?}, apmtif: {=bool:?}, terrif: {=bool:?}, ioflt: {=u8:?}, hall_trgsel: {=u8:?}, curen: {=bool:?}, mskdat: {=u8:?}, msken_curr: {=u8:?} }}" , self . cce () , self . cpe () , self . apmtie () , self . terrie () , self . cc_trgsel () , self . cc_strg () , self . cp_mdsel () , self . apmtif () , self . terrif () , self . ioflt () , self . hall_trgsel () , self . curen () , self . mskdat () , self . msken_curr ()) } } } } pub mod pwr { # [doc = "Power control"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Pwr { ptr : * mut u8 } unsafe impl Send for Pwr { } unsafe impl Sync for Pwr { } impl Pwr { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "CR"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "CSR"] # [inline (always)] pub const fn csr (self) -> crate :: common :: Reg < regs :: Csr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } } pub mod regs { # [doc = "CR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "Auto Phase Mask delay load register"] # [must_use] # [inline (always)] pub const fn lpds (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Auto Phase Mask delay load register"] # [inline (always)] pub const fn set_lpds (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Power down deepsleep"] # [must_use] # [inline (always)] pub const fn pdds (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Power down deepsleep"] # [inline (always)] pub const fn set_pdds (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Clear wakeup flag"] # [must_use] # [inline (always)] pub const fn cwuf (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Clear wakeup flag"] # [inline (always)] pub const fn set_cwuf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Clear standby flag"] # [must_use] # [inline (always)] pub const fn csbf (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Clear standby flag"] # [inline (always)] pub const fn set_csbf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Power voltage detector enable"] # [must_use] # [inline (always)] pub const fn pvde (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Power voltage detector enable"] # [inline (always)] pub const fn set_pvde (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "PVD level selection"] # [must_use] # [inline (always)] pub const fn pls (& self) -> u8 { let val = (self . 0 >> 9usize) & 0x0f ; val as u8 } # [doc = "PVD level selection"] # [inline (always)] pub const fn set_pls (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 9usize)) | (((val as u32) & 0x0f) << 9usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("lpds" , & self . lpds ()) . field ("pdds" , & self . pdds ()) . field ("cwuf" , & self . cwuf ()) . field ("csbf" , & self . csbf ()) . field ("pvde" , & self . pvde ()) . field ("pls" , & self . pls ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ lpds: {=bool:?}, pdds: {=bool:?}, cwuf: {=bool:?}, csbf: {=bool:?}, pvde: {=bool:?}, pls: {=u8:?} }}" , self . lpds () , self . pdds () , self . cwuf () , self . csbf () , self . pvde () , self . pls ()) } } # [doc = "CSR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Csr (pub u32) ; impl Csr { # [doc = "Wakeup flag"] # [must_use] # [inline (always)] pub const fn wuf (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Wakeup flag"] # [inline (always)] pub const fn set_wuf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Standby flag"] # [must_use] # [inline (always)] pub const fn sbf (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Standby flag"] # [inline (always)] pub const fn set_sbf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "PVD output"] # [must_use] # [inline (always)] pub const fn pvdo (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "PVD output"] # [inline (always)] pub const fn set_pvdo (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Enable WKUP pin"] # [must_use] # [inline (always)] pub const fn ewup (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Enable WKUP pin"] # [inline (always)] pub const fn set_ewup (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } } impl Default for Csr { # [inline (always)] fn default () -> Csr { Csr (0) } } impl core :: fmt :: Debug for Csr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Csr") . field ("wuf" , & self . wuf ()) . field ("sbf" , & self . sbf ()) . field ("pvdo" , & self . pvdo ()) . field ("ewup" , & self . ewup ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Csr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Csr {{ wuf: {=bool:?}, sbf: {=bool:?}, pvdo: {=bool:?}, ewup: {=bool:?} }}" , self . wuf () , self . sbf () , self . pvdo () , self . ewup ()) } } } } pub mod rcc { # [doc = "Reset and clock control"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rcc { ptr : * mut u8 } unsafe impl Send for Rcc { } unsafe impl Sync for Rcc { } impl Rcc { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Control Register"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Configuration Register"] # [inline (always)] pub const fn cfgr (self) -> crate :: common :: Reg < regs :: Cfgr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Clock Interrupt Register"] # [inline (always)] pub const fn cir (self) -> crate :: common :: Reg < regs :: Cir , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "Advanced Peripheral Bus 2 Reset Register"] # [inline (always)] pub const fn apb2rstr (self) -> crate :: common :: Reg < regs :: Apb2rstr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "Advanced Peripheral Bus 1 Reset Register"] # [inline (always)] pub const fn apb1rstr (self) -> crate :: common :: Reg < regs :: Apb1rstr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "Advanced High Performance Bus Enable Register"] # [inline (always)] pub const fn ahbenr (self) -> crate :: common :: Reg < regs :: Ahbenr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "Advanced Peripheral Bus 2 Enable Register"] # [inline (always)] pub const fn apb2enr (self) -> crate :: common :: Reg < regs :: Apb2enr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "Advanced Peripheral Bus 1 Enable Register"] # [inline (always)] pub const fn apb1enr (self) -> crate :: common :: Reg < regs :: Apb1enr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "Control Status Register"] # [inline (always)] pub const fn csr (self) -> crate :: common :: Reg < regs :: Csr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "Advanced High Performance Bus Reset Register"] # [inline (always)] pub const fn ahbrstr (self) -> crate :: common :: Reg < regs :: Ahbrstr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "System Configuration Register"] # [inline (always)] pub const fn config (self) -> crate :: common :: Reg < regs :: Config , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x40usize) as _) } } } pub mod regs { # [doc = "Advanced High Performance Bus Enable Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ahbenr (pub u32) ; impl Ahbenr { # [doc = "DMA1 clock enable"] # [must_use] # [inline (always)] pub const fn dma1 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "DMA1 clock enable"] # [inline (always)] pub const fn set_dma1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "SRAM interface clock enable"] # [must_use] # [inline (always)] pub const fn sram (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "SRAM interface clock enable"] # [inline (always)] pub const fn set_sram (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "FLITF clock enable"] # [must_use] # [inline (always)] pub const fn flitf (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "FLITF clock enable"] # [inline (always)] pub const fn set_flitf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "CRC clock enable"] # [must_use] # [inline (always)] pub const fn crc (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "CRC clock enable"] # [inline (always)] pub const fn set_crc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "I/O port A clock enable"] # [must_use] # [inline (always)] pub const fn gpioa (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "I/O port A clock enable"] # [inline (always)] pub const fn set_gpioa (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "I/O port B clock enable"] # [must_use] # [inline (always)] pub const fn gpiob (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "I/O port B clock enable"] # [inline (always)] pub const fn set_gpiob (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "I/O port C clock enable"] # [must_use] # [inline (always)] pub const fn gpioc (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "I/O port C clock enable"] # [inline (always)] pub const fn set_gpioc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "I/O port D clock enable"] # [must_use] # [inline (always)] pub const fn gpiod (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "I/O port D clock enable"] # [inline (always)] pub const fn set_gpiod (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "HWDIV clock enable"] # [must_use] # [inline (always)] pub const fn hwdiv (& self) -> bool { let val = (self . 0 >> 26usize) & 0x01 ; val != 0 } # [doc = "HWDIV clock enable"] # [inline (always)] pub const fn set_hwdiv (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize) ; } } impl Default for Ahbenr { # [inline (always)] fn default () -> Ahbenr { Ahbenr (0) } } impl core :: fmt :: Debug for Ahbenr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ahbenr") . field ("dma1" , & self . dma1 ()) . field ("sram" , & self . sram ()) . field ("flitf" , & self . flitf ()) . field ("crc" , & self . crc ()) . field ("gpioa" , & self . gpioa ()) . field ("gpiob" , & self . gpiob ()) . field ("gpioc" , & self . gpioc ()) . field ("gpiod" , & self . gpiod ()) . field ("hwdiv" , & self . hwdiv ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ahbenr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ahbenr {{ dma1: {=bool:?}, sram: {=bool:?}, flitf: {=bool:?}, crc: {=bool:?}, gpioa: {=bool:?}, gpiob: {=bool:?}, gpioc: {=bool:?}, gpiod: {=bool:?}, hwdiv: {=bool:?} }}" , self . dma1 () , self . sram () , self . flitf () , self . crc () , self . gpioa () , self . gpiob () , self . gpioc () , self . gpiod () , self . hwdiv ()) } } # [doc = "Advanced High Performance Bus Reset Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ahbrstr (pub u32) ; impl Ahbrstr { # [doc = "DMA1 clock reset"] # [must_use] # [inline (always)] pub const fn dma1 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "DMA1 clock reset"] # [inline (always)] pub const fn set_dma1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "SRAM interface clock reset"] # [must_use] # [inline (always)] pub const fn sram (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "SRAM interface clock reset"] # [inline (always)] pub const fn set_sram (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "FLITF clock reset"] # [must_use] # [inline (always)] pub const fn flitf (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "FLITF clock reset"] # [inline (always)] pub const fn set_flitf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "CRC clock reset"] # [must_use] # [inline (always)] pub const fn crc (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "CRC clock reset"] # [inline (always)] pub const fn set_crc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "I/O port A clock reset"] # [must_use] # [inline (always)] pub const fn gpioa (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "I/O port A clock reset"] # [inline (always)] pub const fn set_gpioa (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "I/O port B clock reset"] # [must_use] # [inline (always)] pub const fn gpiob (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "I/O port B clock reset"] # [inline (always)] pub const fn set_gpiob (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "I/O port C clock reset"] # [must_use] # [inline (always)] pub const fn gpioc (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "I/O port C clock reset"] # [inline (always)] pub const fn set_gpioc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "I/O port D clock reset"] # [must_use] # [inline (always)] pub const fn gpiod (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "I/O port D clock reset"] # [inline (always)] pub const fn set_gpiod (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "HWDIV clock reset"] # [must_use] # [inline (always)] pub const fn hwdiv (& self) -> bool { let val = (self . 0 >> 26usize) & 0x01 ; val != 0 } # [doc = "HWDIV clock reset"] # [inline (always)] pub const fn set_hwdiv (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize) ; } } impl Default for Ahbrstr { # [inline (always)] fn default () -> Ahbrstr { Ahbrstr (0) } } impl core :: fmt :: Debug for Ahbrstr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ahbrstr") . field ("dma1" , & self . dma1 ()) . field ("sram" , & self . sram ()) . field ("flitf" , & self . flitf ()) . field ("crc" , & self . crc ()) . field ("gpioa" , & self . gpioa ()) . field ("gpiob" , & self . gpiob ()) . field ("gpioc" , & self . gpioc ()) . field ("gpiod" , & self . gpiod ()) . field ("hwdiv" , & self . hwdiv ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ahbrstr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ahbrstr {{ dma1: {=bool:?}, sram: {=bool:?}, flitf: {=bool:?}, crc: {=bool:?}, gpioa: {=bool:?}, gpiob: {=bool:?}, gpioc: {=bool:?}, gpiod: {=bool:?}, hwdiv: {=bool:?} }}" , self . dma1 () , self . sram () , self . flitf () , self . crc () , self . gpioa () , self . gpiob () , self . gpioc () , self . gpiod () , self . hwdiv ()) } } # [doc = "Advanced Peripheral Bus 1 Enable Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Apb1enr (pub u32) ; impl Apb1enr { # [doc = "TIM2 clock enable"] # [must_use] # [inline (always)] pub const fn tim2 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "TIM2 clock enable"] # [inline (always)] pub const fn set_tim2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "TIM3 clock enable"] # [must_use] # [inline (always)] pub const fn tim3 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "TIM3 clock enable"] # [inline (always)] pub const fn set_tim3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Window watchdog clock enable"] # [must_use] # [inline (always)] pub const fn wwdg (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Window watchdog clock enable"] # [inline (always)] pub const fn set_wwdg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "SPI2 clock enable"] # [must_use] # [inline (always)] pub const fn spi2 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "SPI2 clock enable"] # [inline (always)] pub const fn set_spi2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "UART2 clock enable"] # [must_use] # [inline (always)] pub const fn uart2 (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "UART2 clock enable"] # [inline (always)] pub const fn set_uart2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "I2C1 clock enable"] # [must_use] # [inline (always)] pub const fn i2c1 (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "I2C1 clock enable"] # [inline (always)] pub const fn set_i2c1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } # [doc = "Power interface clock enable"] # [must_use] # [inline (always)] pub const fn pwr (& self) -> bool { let val = (self . 0 >> 28usize) & 0x01 ; val != 0 } # [doc = "Power interface clock enable"] # [inline (always)] pub const fn set_pwr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize) ; } } impl Default for Apb1enr { # [inline (always)] fn default () -> Apb1enr { Apb1enr (0) } } impl core :: fmt :: Debug for Apb1enr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Apb1enr") . field ("tim2" , & self . tim2 ()) . field ("tim3" , & self . tim3 ()) . field ("wwdg" , & self . wwdg ()) . field ("spi2" , & self . spi2 ()) . field ("uart2" , & self . uart2 ()) . field ("i2c1" , & self . i2c1 ()) . field ("pwr" , & self . pwr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Apb1enr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Apb1enr {{ tim2: {=bool:?}, tim3: {=bool:?}, wwdg: {=bool:?}, spi2: {=bool:?}, uart2: {=bool:?}, i2c1: {=bool:?}, pwr: {=bool:?} }}" , self . tim2 () , self . tim3 () , self . wwdg () , self . spi2 () , self . uart2 () , self . i2c1 () , self . pwr ()) } } # [doc = "Advanced Peripheral Bus 1 Reset Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Apb1rstr (pub u32) ; impl Apb1rstr { # [doc = "TIM2 reset"] # [must_use] # [inline (always)] pub const fn tim2 (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "TIM2 reset"] # [inline (always)] pub const fn set_tim2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "TIM3 reset"] # [must_use] # [inline (always)] pub const fn tim3 (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "TIM3 reset"] # [inline (always)] pub const fn set_tim3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Window watchdog reset"] # [must_use] # [inline (always)] pub const fn wwdg (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Window watchdog reset"] # [inline (always)] pub const fn set_wwdg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "SPI2 reset"] # [must_use] # [inline (always)] pub const fn spi2 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "SPI2 reset"] # [inline (always)] pub const fn set_spi2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "UART2 reset"] # [must_use] # [inline (always)] pub const fn uart2 (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "UART2 reset"] # [inline (always)] pub const fn set_uart2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "I2C1 reset"] # [must_use] # [inline (always)] pub const fn i2c1 (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "I2C1 reset"] # [inline (always)] pub const fn set_i2c1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } # [doc = "Power interface reset"] # [must_use] # [inline (always)] pub const fn pwr (& self) -> bool { let val = (self . 0 >> 28usize) & 0x01 ; val != 0 } # [doc = "Power interface reset"] # [inline (always)] pub const fn set_pwr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize) ; } } impl Default for Apb1rstr { # [inline (always)] fn default () -> Apb1rstr { Apb1rstr (0) } } impl core :: fmt :: Debug for Apb1rstr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Apb1rstr") . field ("tim2" , & self . tim2 ()) . field ("tim3" , & self . tim3 ()) . field ("wwdg" , & self . wwdg ()) . field ("spi2" , & self . spi2 ()) . field ("uart2" , & self . uart2 ()) . field ("i2c1" , & self . i2c1 ()) . field ("pwr" , & self . pwr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Apb1rstr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Apb1rstr {{ tim2: {=bool:?}, tim3: {=bool:?}, wwdg: {=bool:?}, spi2: {=bool:?}, uart2: {=bool:?}, i2c1: {=bool:?}, pwr: {=bool:?} }}" , self . tim2 () , self . tim3 () , self . wwdg () , self . spi2 () , self . uart2 () , self . i2c1 () , self . pwr ()) } } # [doc = "Advanced Peripheral Bus 2 Enable Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Apb2enr (pub u32) ; impl Apb2enr { # [doc = "External Interrupt"] # [must_use] # [inline (always)] pub const fn exti (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "External Interrupt"] # [inline (always)] pub const fn set_exti (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "ADC1 interface enable"] # [must_use] # [inline (always)] pub const fn adc1 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "ADC1 interface enable"] # [inline (always)] pub const fn set_adc1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "TIM1 enable"] # [must_use] # [inline (always)] pub const fn tim1 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "TIM1 enable"] # [inline (always)] pub const fn set_tim1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "SPI1 enable"] # [must_use] # [inline (always)] pub const fn spi1 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "SPI1 enable"] # [inline (always)] pub const fn set_spi1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "UART1 enable"] # [must_use] # [inline (always)] pub const fn uart1 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "UART1 enable"] # [inline (always)] pub const fn set_uart1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "COMP interface enable"] # [must_use] # [inline (always)] pub const fn comp (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "COMP interface enable"] # [inline (always)] pub const fn set_comp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "TIM14 enable"] # [must_use] # [inline (always)] pub const fn tim14 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "TIM14 enable"] # [inline (always)] pub const fn set_tim14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "TIM16 enable"] # [must_use] # [inline (always)] pub const fn tim16 (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "TIM16 enable"] # [inline (always)] pub const fn set_tim16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "TIM17 enable"] # [must_use] # [inline (always)] pub const fn tim17 (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "TIM17 enable"] # [inline (always)] pub const fn set_tim17 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "DBGMCU enable"] # [must_use] # [inline (always)] pub const fn dbgmcu (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "DBGMCU enable"] # [inline (always)] pub const fn set_dbgmcu (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "*D23"] # [must_use] # [inline (always)] pub const fn pwm (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "*D23"] # [inline (always)] pub const fn set_pwm (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } } impl Default for Apb2enr { # [inline (always)] fn default () -> Apb2enr { Apb2enr (0) } } impl core :: fmt :: Debug for Apb2enr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Apb2enr") . field ("exti" , & self . exti ()) . field ("adc1" , & self . adc1 ()) . field ("tim1" , & self . tim1 ()) . field ("spi1" , & self . spi1 ()) . field ("uart1" , & self . uart1 ()) . field ("comp" , & self . comp ()) . field ("tim14" , & self . tim14 ()) . field ("tim16" , & self . tim16 ()) . field ("tim17" , & self . tim17 ()) . field ("dbgmcu" , & self . dbgmcu ()) . field ("pwm" , & self . pwm ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Apb2enr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Apb2enr {{ exti: {=bool:?}, adc1: {=bool:?}, tim1: {=bool:?}, spi1: {=bool:?}, uart1: {=bool:?}, comp: {=bool:?}, tim14: {=bool:?}, tim16: {=bool:?}, tim17: {=bool:?}, dbgmcu: {=bool:?}, pwm: {=bool:?} }}" , self . exti () , self . adc1 () , self . tim1 () , self . spi1 () , self . uart1 () , self . comp () , self . tim14 () , self . tim16 () , self . tim17 () , self . dbgmcu () , self . pwm ()) } } # [doc = "Advanced Peripheral Bus 2 Reset Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Apb2rstr (pub u32) ; impl Apb2rstr { # [doc = "External Interrupt"] # [must_use] # [inline (always)] pub const fn exti (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "External Interrupt"] # [inline (always)] pub const fn set_exti (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "ADC1 interface reset"] # [must_use] # [inline (always)] pub const fn adc1 (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "ADC1 interface reset"] # [inline (always)] pub const fn set_adc1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "TIM1 reset"] # [must_use] # [inline (always)] pub const fn tim1 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "TIM1 reset"] # [inline (always)] pub const fn set_tim1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "SPI1 reset"] # [must_use] # [inline (always)] pub const fn spi1 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "SPI1 reset"] # [inline (always)] pub const fn set_spi1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "UART1 reset"] # [must_use] # [inline (always)] pub const fn uart1 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "UART1 reset"] # [inline (always)] pub const fn set_uart1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "COMP interface reset"] # [must_use] # [inline (always)] pub const fn comp (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "COMP interface reset"] # [inline (always)] pub const fn set_comp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "TIM14 reset"] # [must_use] # [inline (always)] pub const fn tim14 (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "TIM14 reset"] # [inline (always)] pub const fn set_tim14 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "TIM16 reset"] # [must_use] # [inline (always)] pub const fn tim16 (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "TIM16 reset"] # [inline (always)] pub const fn set_tim16 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "TIM17 reset"] # [must_use] # [inline (always)] pub const fn tim17 (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "TIM17 reset"] # [inline (always)] pub const fn set_tim17 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "DBGMCU reset"] # [must_use] # [inline (always)] pub const fn dbgmcu (& self) -> bool { let val = (self . 0 >> 22usize) & 0x01 ; val != 0 } # [doc = "DBGMCU reset"] # [inline (always)] pub const fn set_dbgmcu (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize) ; } # [doc = "PWM reset"] # [must_use] # [inline (always)] pub const fn pwm (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "PWM reset"] # [inline (always)] pub const fn set_pwm (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } } impl Default for Apb2rstr { # [inline (always)] fn default () -> Apb2rstr { Apb2rstr (0) } } impl core :: fmt :: Debug for Apb2rstr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Apb2rstr") . field ("exti" , & self . exti ()) . field ("adc1" , & self . adc1 ()) . field ("tim1" , & self . tim1 ()) . field ("spi1" , & self . spi1 ()) . field ("uart1" , & self . uart1 ()) . field ("comp" , & self . comp ()) . field ("tim14" , & self . tim14 ()) . field ("tim16" , & self . tim16 ()) . field ("tim17" , & self . tim17 ()) . field ("dbgmcu" , & self . dbgmcu ()) . field ("pwm" , & self . pwm ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Apb2rstr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Apb2rstr {{ exti: {=bool:?}, adc1: {=bool:?}, tim1: {=bool:?}, spi1: {=bool:?}, uart1: {=bool:?}, comp: {=bool:?}, tim14: {=bool:?}, tim16: {=bool:?}, tim17: {=bool:?}, dbgmcu: {=bool:?}, pwm: {=bool:?} }}" , self . exti () , self . adc1 () , self . tim1 () , self . spi1 () , self . uart1 () , self . comp () , self . tim14 () , self . tim16 () , self . tim17 () , self . dbgmcu () , self . pwm ()) } } # [doc = "Configuration Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cfgr (pub u32) ; impl Cfgr { # [doc = "System clock switch"] # [must_use] # [inline (always)] pub const fn sw (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "System clock switch"] # [inline (always)] pub const fn set_sw (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "System clock switch status"] # [must_use] # [inline (always)] pub const fn sws (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "System clock switch status"] # [inline (always)] pub const fn set_sws (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "AHB Prescaler"] # [must_use] # [inline (always)] pub const fn hpre (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "AHB Prescaler"] # [inline (always)] pub const fn set_hpre (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "APB low-speed prescaler(APB1)"] # [must_use] # [inline (always)] pub const fn ppre1 (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x07 ; val as u8 } # [doc = "APB low-speed prescaler(APB1)"] # [inline (always)] pub const fn set_ppre1 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize) ; } # [doc = "APB high-speed prescaler(APB2)"] # [must_use] # [inline (always)] pub const fn ppre2 (& self) -> u8 { let val = (self . 0 >> 11usize) & 0x07 ; val as u8 } # [doc = "APB high-speed prescaler(APB2)"] # [inline (always)] pub const fn set_ppre2 (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 11usize)) | (((val as u32) & 0x07) << 11usize) ; } # [doc = "Microcontroller clock output"] # [must_use] # [inline (always)] pub const fn mco (& self) -> u8 { let val = (self . 0 >> 24usize) & 0x07 ; val as u8 } # [doc = "Microcontroller clock output"] # [inline (always)] pub const fn set_mco (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 24usize)) | (((val as u32) & 0x07) << 24usize) ; } } impl Default for Cfgr { # [inline (always)] fn default () -> Cfgr { Cfgr (0) } } impl core :: fmt :: Debug for Cfgr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cfgr") . field ("sw" , & self . sw ()) . field ("sws" , & self . sws ()) . field ("hpre" , & self . hpre ()) . field ("ppre1" , & self . ppre1 ()) . field ("ppre2" , & self . ppre2 ()) . field ("mco" , & self . mco ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cfgr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cfgr {{ sw: {=u8:?}, sws: {=u8:?}, hpre: {=u8:?}, ppre1: {=u8:?}, ppre2: {=u8:?}, mco: {=u8:?} }}" , self . sw () , self . sws () , self . hpre () , self . ppre1 () , self . ppre2 () , self . mco ()) } } # [doc = "Clock Interrupt Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cir (pub u32) ; impl Cir { # [doc = "LSI ready interrupt flag"] # [must_use] # [inline (always)] pub const fn lsirdyf (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "LSI ready interrupt flag"] # [inline (always)] pub const fn set_lsirdyf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "HSI ready interrupt flag"] # [must_use] # [inline (always)] pub const fn hsirdyf (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "HSI ready interrupt flag"] # [inline (always)] pub const fn set_hsirdyf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "HSE ready interrupt flag"] # [must_use] # [inline (always)] pub const fn hserdyf (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "HSE ready interrupt flag"] # [inline (always)] pub const fn set_hserdyf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Clock security system interrupt flag"] # [must_use] # [inline (always)] pub const fn cssf (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Clock security system interrupt flag"] # [inline (always)] pub const fn set_cssf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "LSI ready interrupt enable"] # [must_use] # [inline (always)] pub const fn lsirdyie (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "LSI ready interrupt enable"] # [inline (always)] pub const fn set_lsirdyie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "HSI ready interrupt enable"] # [must_use] # [inline (always)] pub const fn hsirdyie (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "HSI ready interrupt enable"] # [inline (always)] pub const fn set_hsirdyie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "HSE ready interrupt enable"] # [must_use] # [inline (always)] pub const fn hserdyie (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "HSE ready interrupt enable"] # [inline (always)] pub const fn set_hserdyie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "LSI ready interrupt clear"] # [must_use] # [inline (always)] pub const fn lsirdyc (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "LSI ready interrupt clear"] # [inline (always)] pub const fn set_lsirdyc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "HSI ready interrupt clear"] # [must_use] # [inline (always)] pub const fn hsirdyc (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "HSI ready interrupt clear"] # [inline (always)] pub const fn set_hsirdyc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "HSE ready interrupt clear"] # [must_use] # [inline (always)] pub const fn hserdyc (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "HSE ready interrupt clear"] # [inline (always)] pub const fn set_hserdyc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "Clock security system interrupt clear"] # [must_use] # [inline (always)] pub const fn cssc (& self) -> bool { let val = (self . 0 >> 23usize) & 0x01 ; val != 0 } # [doc = "Clock security system interrupt clear"] # [inline (always)] pub const fn set_cssc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize) ; } } impl Default for Cir { # [inline (always)] fn default () -> Cir { Cir (0) } } impl core :: fmt :: Debug for Cir { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cir") . field ("lsirdyf" , & self . lsirdyf ()) . field ("hsirdyf" , & self . hsirdyf ()) . field ("hserdyf" , & self . hserdyf ()) . field ("cssf" , & self . cssf ()) . field ("lsirdyie" , & self . lsirdyie ()) . field ("hsirdyie" , & self . hsirdyie ()) . field ("hserdyie" , & self . hserdyie ()) . field ("lsirdyc" , & self . lsirdyc ()) . field ("hsirdyc" , & self . hsirdyc ()) . field ("hserdyc" , & self . hserdyc ()) . field ("cssc" , & self . cssc ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cir { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cir {{ lsirdyf: {=bool:?}, hsirdyf: {=bool:?}, hserdyf: {=bool:?}, cssf: {=bool:?}, lsirdyie: {=bool:?}, hsirdyie: {=bool:?}, hserdyie: {=bool:?}, lsirdyc: {=bool:?}, hsirdyc: {=bool:?}, hserdyc: {=bool:?}, cssc: {=bool:?} }}" , self . lsirdyf () , self . hsirdyf () , self . hserdyf () , self . cssf () , self . lsirdyie () , self . hsirdyie () , self . hserdyie () , self . lsirdyc () , self . hsirdyc () , self . hserdyc () , self . cssc ()) } } # [doc = "System Configuration Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Config (pub u32) ; impl Config { # [doc = "Flash Page size"] # [must_use] # [inline (always)] pub const fn pagesize (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Flash Page size"] # [inline (always)] pub const fn set_pagesize (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Oscillator feedback resistance trimming"] # [must_use] # [inline (always)] pub const fn osc_rtrim (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x07 ; val as u8 } # [doc = "Oscillator feedback resistance trimming"] # [inline (always)] pub const fn set_osc_rtrim (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 8usize)) | (((val as u32) & 0x07) << 8usize) ; } # [doc = "Oscillator drive current trimming"] # [must_use] # [inline (always)] pub const fn osc_itrim (& self) -> u8 { let val = (self . 0 >> 11usize) & 0x03 ; val as u8 } # [doc = "Oscillator drive current trimming"] # [inline (always)] pub const fn set_osc_itrim (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 11usize)) | (((val as u32) & 0x03) << 11usize) ; } # [doc = "Oscillator low pass filtering enable"] # [must_use] # [inline (always)] pub const fn osc_lpfen (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Oscillator low pass filtering enable"] # [inline (always)] pub const fn set_osc_lpfen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } } impl Default for Config { # [inline (always)] fn default () -> Config { Config (0) } } impl core :: fmt :: Debug for Config { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Config") . field ("pagesize" , & self . pagesize ()) . field ("osc_rtrim" , & self . osc_rtrim ()) . field ("osc_itrim" , & self . osc_itrim ()) . field ("osc_lpfen" , & self . osc_lpfen ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Config { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Config {{ pagesize: {=bool:?}, osc_rtrim: {=u8:?}, osc_itrim: {=u8:?}, osc_lpfen: {=bool:?} }}" , self . pagesize () , self . osc_rtrim () , self . osc_itrim () , self . osc_lpfen ()) } } # [doc = "Control Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "Internal high-speed clock enable"] # [must_use] # [inline (always)] pub const fn hsion (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Internal high-speed clock enable"] # [inline (always)] pub const fn set_hsion (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Internal high-speed clock ready flag"] # [must_use] # [inline (always)] pub const fn hsirdy (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Internal high-speed clock ready flag"] # [inline (always)] pub const fn set_hsirdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Internal high-speed clock temperature enable"] # [must_use] # [inline (always)] pub const fn hsiten (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Internal high-speed clock temperature enable"] # [inline (always)] pub const fn set_hsiten (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Internal high-speed clock calibration"] # [must_use] # [inline (always)] pub const fn hsical (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x3f ; val as u8 } # [doc = "Internal high-speed clock calibration"] # [inline (always)] pub const fn set_hsical (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize) ; } # [doc = "External high-speed clock enable"] # [must_use] # [inline (always)] pub const fn hseon (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "External high-speed clock enable"] # [inline (always)] pub const fn set_hseon (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "External high-speed clock ready flag"] # [must_use] # [inline (always)] pub const fn hserdy (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "External high-speed clock ready flag"] # [inline (always)] pub const fn set_hserdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } # [doc = "External high-speed clock bypass"] # [must_use] # [inline (always)] pub const fn hsebyp (& self) -> bool { let val = (self . 0 >> 18usize) & 0x01 ; val != 0 } # [doc = "External high-speed clock bypass"] # [inline (always)] pub const fn set_hsebyp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize) ; } # [doc = "Clock security system enable"] # [must_use] # [inline (always)] pub const fn ccson (& self) -> bool { let val = (self . 0 >> 19usize) & 0x01 ; val != 0 } # [doc = "Clock security system enable"] # [inline (always)] pub const fn set_ccson (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize) ; } # [doc = "HSI output 72M"] # [must_use] # [inline (always)] pub const fn hsi_72m (& self) -> bool { let val = (self . 0 >> 20usize) & 0x01 ; val != 0 } # [doc = "HSI output 72M"] # [inline (always)] pub const fn set_hsi_72m (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize) ; } # [doc = "Quickly wake-up standby mode selection"] # [must_use] # [inline (always)] pub const fn stdby_fs_wk (& self) -> bool { let val = (self . 0 >> 21usize) & 0x01 ; val != 0 } # [doc = "Quickly wake-up standby mode selection"] # [inline (always)] pub const fn set_stdby_fs_wk (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("hsion" , & self . hsion ()) . field ("hsirdy" , & self . hsirdy ()) . field ("hsiten" , & self . hsiten ()) . field ("hsical" , & self . hsical ()) . field ("hseon" , & self . hseon ()) . field ("hserdy" , & self . hserdy ()) . field ("hsebyp" , & self . hsebyp ()) . field ("ccson" , & self . ccson ()) . field ("hsi_72m" , & self . hsi_72m ()) . field ("stdby_fs_wk" , & self . stdby_fs_wk ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ hsion: {=bool:?}, hsirdy: {=bool:?}, hsiten: {=bool:?}, hsical: {=u8:?}, hseon: {=bool:?}, hserdy: {=bool:?}, hsebyp: {=bool:?}, ccson: {=bool:?}, hsi_72m: {=bool:?}, stdby_fs_wk: {=bool:?} }}" , self . hsion () , self . hsirdy () , self . hsiten () , self . hsical () , self . hseon () , self . hserdy () , self . hsebyp () , self . ccson () , self . hsi_72m () , self . stdby_fs_wk ()) } } # [doc = "Control Status Register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Csr (pub u32) ; impl Csr { # [doc = "Internal low-speed oscillator enable"] # [must_use] # [inline (always)] pub const fn lsion (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Internal low-speed oscillator enable"] # [inline (always)] pub const fn set_lsion (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Internal low-speed oscillator ready"] # [must_use] # [inline (always)] pub const fn lsirdy (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Internal low-speed oscillator ready"] # [inline (always)] pub const fn set_lsirdy (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Remove reset flag"] # [must_use] # [inline (always)] pub const fn rmvf (& self) -> bool { let val = (self . 0 >> 24usize) & 0x01 ; val != 0 } # [doc = "Remove reset flag"] # [inline (always)] pub const fn set_rmvf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize) ; } # [doc = "PIN reset flag"] # [must_use] # [inline (always)] pub const fn pinrstf (& self) -> bool { let val = (self . 0 >> 26usize) & 0x01 ; val != 0 } # [doc = "PIN reset flag"] # [inline (always)] pub const fn set_pinrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize) ; } # [doc = "POR/PDR reset flag"] # [must_use] # [inline (always)] pub const fn porrstf (& self) -> bool { let val = (self . 0 >> 27usize) & 0x01 ; val != 0 } # [doc = "POR/PDR reset flag"] # [inline (always)] pub const fn set_porrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize) ; } # [doc = "Software reset flag"] # [must_use] # [inline (always)] pub const fn sftrstf (& self) -> bool { let val = (self . 0 >> 28usize) & 0x01 ; val != 0 } # [doc = "Software reset flag"] # [inline (always)] pub const fn set_sftrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize) ; } # [doc = "Independent watchdog reset flag"] # [must_use] # [inline (always)] pub const fn iwdgrstf (& self) -> bool { let val = (self . 0 >> 29usize) & 0x01 ; val != 0 } # [doc = "Independent watchdog reset flag"] # [inline (always)] pub const fn set_iwdgrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize) ; } # [doc = "Window watchdog reset flag"] # [must_use] # [inline (always)] pub const fn wwdgrstf (& self) -> bool { let val = (self . 0 >> 30usize) & 0x01 ; val != 0 } # [doc = "Window watchdog reset flag"] # [inline (always)] pub const fn set_wwdgrstf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize) ; } } impl Default for Csr { # [inline (always)] fn default () -> Csr { Csr (0) } } impl core :: fmt :: Debug for Csr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Csr") . field ("lsion" , & self . lsion ()) . field ("lsirdy" , & self . lsirdy ()) . field ("rmvf" , & self . rmvf ()) . field ("pinrstf" , & self . pinrstf ()) . field ("porrstf" , & self . porrstf ()) . field ("sftrstf" , & self . sftrstf ()) . field ("iwdgrstf" , & self . iwdgrstf ()) . field ("wwdgrstf" , & self . wwdgrstf ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Csr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Csr {{ lsion: {=bool:?}, lsirdy: {=bool:?}, rmvf: {=bool:?}, pinrstf: {=bool:?}, porrstf: {=bool:?}, sftrstf: {=bool:?}, iwdgrstf: {=bool:?}, wwdgrstf: {=bool:?} }}" , self . lsion () , self . lsirdy () , self . rmvf () , self . pinrstf () , self . porrstf () , self . sftrstf () , self . iwdgrstf () , self . wwdgrstf ()) } } } } pub mod spi1 { # [doc = "Serial peripheral interface"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Spi1 { ptr : * mut u8 } unsafe impl Send for Spi1 { } unsafe impl Sync for Spi1 { } impl Spi1 { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "TXREG"] # [inline (always)] pub const fn txreg (self) -> crate :: common :: Reg < regs :: Txreg , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "RXREG"] # [inline (always)] pub const fn rxreg (self) -> crate :: common :: Reg < regs :: Rxreg , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "CSTAT"] # [inline (always)] pub const fn cstat (self) -> crate :: common :: Reg < regs :: Cstat , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "INTSTAT"] # [inline (always)] pub const fn intstat (self) -> crate :: common :: Reg < regs :: Intstat , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "INTEN"] # [inline (always)] pub const fn inten (self) -> crate :: common :: Reg < regs :: Inten , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "INTCLR"] # [inline (always)] pub const fn intclr (self) -> crate :: common :: Reg < regs :: Intclr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "GCTL"] # [inline (always)] pub const fn gctl (self) -> crate :: common :: Reg < regs :: Gctl , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "CCTL"] # [inline (always)] pub const fn cctl (self) -> crate :: common :: Reg < regs :: Cctl , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "SPBRG"] # [inline (always)] pub const fn spbrg (self) -> crate :: common :: Reg < regs :: Spbrg , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "RXDNR"] # [inline (always)] pub const fn rxdnr (self) -> crate :: common :: Reg < regs :: Rxdnr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "NSSR"] # [inline (always)] pub const fn nssr (self) -> crate :: common :: Reg < regs :: Nssr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "EXTCTL"] # [inline (always)] pub const fn extctl (self) -> crate :: common :: Reg < regs :: Extctl , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x2cusize) as _) } } } pub mod regs { # [doc = "CCTL"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cctl (pub u32) ; impl Cctl { # [doc = "Clock phase select bit"] # [must_use] # [inline (always)] pub const fn cpha (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Clock phase select bit"] # [inline (always)] pub const fn set_cpha (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Clock polarity select bit"] # [must_use] # [inline (always)] pub const fn cpol (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Clock polarity select bit"] # [inline (always)] pub const fn set_cpol (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "LSI first enable bit"] # [must_use] # [inline (always)] pub const fn lsbfe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "LSI first enable bit"] # [inline (always)] pub const fn set_lsbfe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "SPI character length bit"] # [must_use] # [inline (always)] pub const fn spilen (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "SPI character length bit"] # [inline (always)] pub const fn set_spilen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Receive data edge select"] # [must_use] # [inline (always)] pub const fn rxedge (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Receive data edge select"] # [inline (always)] pub const fn set_rxedge (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Transmit data edge select"] # [must_use] # [inline (always)] pub const fn txedge (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Transmit data edge select"] # [inline (always)] pub const fn set_txedge (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "CPHA polarity select"] # [must_use] # [inline (always)] pub const fn cphasel (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "CPHA polarity select"] # [inline (always)] pub const fn set_cphasel (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "High speed slave mode"] # [must_use] # [inline (always)] pub const fn hispd (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "High speed slave mode"] # [inline (always)] pub const fn set_hispd (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } } impl Default for Cctl { # [inline (always)] fn default () -> Cctl { Cctl (0) } } impl core :: fmt :: Debug for Cctl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cctl") . field ("cpha" , & self . cpha ()) . field ("cpol" , & self . cpol ()) . field ("lsbfe" , & self . lsbfe ()) . field ("spilen" , & self . spilen ()) . field ("rxedge" , & self . rxedge ()) . field ("txedge" , & self . txedge ()) . field ("cphasel" , & self . cphasel ()) . field ("hispd" , & self . hispd ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cctl { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cctl {{ cpha: {=bool:?}, cpol: {=bool:?}, lsbfe: {=bool:?}, spilen: {=bool:?}, rxedge: {=bool:?}, txedge: {=bool:?}, cphasel: {=bool:?}, hispd: {=bool:?} }}" , self . cpha () , self . cpol () , self . lsbfe () , self . spilen () , self . rxedge () , self . txedge () , self . cphasel () , self . hispd ()) } } # [doc = "CSTAT"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cstat (pub u32) ; impl Cstat { # [doc = "Transmitter empty bit"] # [must_use] # [inline (always)] pub const fn txept (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Transmitter empty bit"] # [inline (always)] pub const fn set_txept (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Receive available byte data message"] # [must_use] # [inline (always)] pub const fn rxavl (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Receive available byte data message"] # [inline (always)] pub const fn set_rxavl (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Transmitter FIFO full status bit"] # [must_use] # [inline (always)] pub const fn txfull (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Transmitter FIFO full status bit"] # [inline (always)] pub const fn set_txfull (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Receive available 4 byte data message"] # [must_use] # [inline (always)] pub const fn rxavl_4byte (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Receive available 4 byte data message"] # [inline (always)] pub const fn set_rxavl_4byte (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Receive FIFO address"] # [must_use] # [inline (always)] pub const fn txfaddr (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Receive FIFO address"] # [inline (always)] pub const fn set_txfaddr (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Transmit FIFO address"] # [must_use] # [inline (always)] pub const fn rxfaddr (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "Transmit FIFO address"] # [inline (always)] pub const fn set_rxfaddr (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } } impl Default for Cstat { # [inline (always)] fn default () -> Cstat { Cstat (0) } } impl core :: fmt :: Debug for Cstat { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cstat") . field ("txept" , & self . txept ()) . field ("rxavl" , & self . rxavl ()) . field ("txfull" , & self . txfull ()) . field ("rxavl_4byte" , & self . rxavl_4byte ()) . field ("txfaddr" , & self . txfaddr ()) . field ("rxfaddr" , & self . rxfaddr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cstat { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cstat {{ txept: {=bool:?}, rxavl: {=bool:?}, txfull: {=bool:?}, rxavl_4byte: {=bool:?}, txfaddr: {=u8:?}, rxfaddr: {=u8:?} }}" , self . txept () , self . rxavl () , self . txfull () , self . rxavl_4byte () , self . txfaddr () , self . rxfaddr ()) } } # [doc = "EXTCTL"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Extctl (pub u32) ; impl Extctl { # [doc = "Control SPI data length"] # [must_use] # [inline (always)] pub const fn extlen (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x1f ; val as u8 } # [doc = "Control SPI data length"] # [inline (always)] pub const fn set_extlen (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize) ; } } impl Default for Extctl { # [inline (always)] fn default () -> Extctl { Extctl (0) } } impl core :: fmt :: Debug for Extctl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Extctl") . field ("extlen" , & self . extlen ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Extctl { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Extctl {{ extlen: {=u8:?} }}" , self . extlen ()) } } # [doc = "GCTL"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Gctl (pub u32) ; impl Gctl { # [doc = "SPI select bit"] # [must_use] # [inline (always)] pub const fn spien (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "SPI select bit"] # [inline (always)] pub const fn set_spien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "SPI interrupt enable bit"] # [must_use] # [inline (always)] pub const fn int_en (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "SPI interrupt enable bit"] # [inline (always)] pub const fn set_int_en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Master mode bit"] # [must_use] # [inline (always)] pub const fn mode (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Master mode bit"] # [inline (always)] pub const fn set_mode (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Transmit enable bit"] # [must_use] # [inline (always)] pub const fn txen (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Transmit enable bit"] # [inline (always)] pub const fn set_txen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Receive enable bit"] # [must_use] # [inline (always)] pub const fn rxen (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Receive enable bit"] # [inline (always)] pub const fn set_rxen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "RX FIFO trigger level bit"] # [must_use] # [inline (always)] pub const fn rxtlf (& self) -> u8 { let val = (self . 0 >> 5usize) & 0x03 ; val as u8 } # [doc = "RX FIFO trigger level bit"] # [inline (always)] pub const fn set_rxtlf (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize) ; } # [doc = "TX FIFO trigger level bit"] # [must_use] # [inline (always)] pub const fn txtlf (& self) -> u8 { let val = (self . 0 >> 7usize) & 0x03 ; val as u8 } # [doc = "TX FIFO trigger level bit"] # [inline (always)] pub const fn set_txtlf (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 7usize)) | (((val as u32) & 0x03) << 7usize) ; } # [doc = "DMA access mode enable"] # [must_use] # [inline (always)] pub const fn dmaen (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "DMA access mode enable"] # [inline (always)] pub const fn set_dmaen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "NSS select signal that from software and hardware"] # [must_use] # [inline (always)] pub const fn nss_sel (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "NSS select signal that from software and hardware"] # [inline (always)] pub const fn set_nss_sel (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Valid byte or double-word data select signal"] # [must_use] # [inline (always)] pub const fn dw8_32 (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Valid byte or double-word data select signal"] # [inline (always)] pub const fn set_dw8_32 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "NSS selection signal is automatically flipped"] # [must_use] # [inline (always)] pub const fn nsstog (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "NSS selection signal is automatically flipped"] # [inline (always)] pub const fn set_nsstog (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Gctl { # [inline (always)] fn default () -> Gctl { Gctl (0) } } impl core :: fmt :: Debug for Gctl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gctl") . field ("spien" , & self . spien ()) . field ("int_en" , & self . int_en ()) . field ("mode" , & self . mode ()) . field ("txen" , & self . txen ()) . field ("rxen" , & self . rxen ()) . field ("rxtlf" , & self . rxtlf ()) . field ("txtlf" , & self . txtlf ()) . field ("dmaen" , & self . dmaen ()) . field ("nss_sel" , & self . nss_sel ()) . field ("dw8_32" , & self . dw8_32 ()) . field ("nsstog" , & self . nsstog ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Gctl { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Gctl {{ spien: {=bool:?}, int_en: {=bool:?}, mode: {=bool:?}, txen: {=bool:?}, rxen: {=bool:?}, rxtlf: {=u8:?}, txtlf: {=u8:?}, dmaen: {=bool:?}, nss_sel: {=bool:?}, dw8_32: {=bool:?}, nsstog: {=bool:?} }}" , self . spien () , self . int_en () , self . mode () , self . txen () , self . rxen () , self . rxtlf () , self . txtlf () , self . dmaen () , self . nss_sel () , self . dw8_32 () , self . nsstog ()) } } # [doc = "INTCLR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Intclr (pub u32) ; impl Intclr { # [doc = "Transmitter FIFO empty interrupt clear bit"] # [must_use] # [inline (always)] pub const fn tx_iclr (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Transmitter FIFO empty interrupt clear bit"] # [inline (always)] pub const fn set_tx_iclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Receive interrupt clear bit"] # [must_use] # [inline (always)] pub const fn rx_iclr (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Receive interrupt clear bit"] # [inline (always)] pub const fn set_rx_iclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Transmitter underrun interrupt clear bit(SPI slave mode only)"] # [must_use] # [inline (always)] pub const fn underrun_iclr (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Transmitter underrun interrupt clear bit(SPI slave mode only)"] # [inline (always)] pub const fn set_underrun_iclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Overrun error interrupt clear bit"] # [must_use] # [inline (always)] pub const fn rxoerr_iclr (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Overrun error interrupt clear bit"] # [inline (always)] pub const fn set_rxoerr_iclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Receive completed interrupt clear bit"] # [must_use] # [inline (always)] pub const fn rxmatch_iclr (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Receive completed interrupt clear bit"] # [inline (always)] pub const fn set_rxmatch_iclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Receiver buffer full interrupt clear bit"] # [must_use] # [inline (always)] pub const fn rxfull_iclr (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Receiver buffer full interrupt clear bit"] # [inline (always)] pub const fn set_rxfull_iclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Transmitter empty interrupt clear bit"] # [must_use] # [inline (always)] pub const fn txept_iclr (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Transmitter empty interrupt clear bit"] # [inline (always)] pub const fn set_txept_iclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } } impl Default for Intclr { # [inline (always)] fn default () -> Intclr { Intclr (0) } } impl core :: fmt :: Debug for Intclr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Intclr") . field ("tx_iclr" , & self . tx_iclr ()) . field ("rx_iclr" , & self . rx_iclr ()) . field ("underrun_iclr" , & self . underrun_iclr ()) . field ("rxoerr_iclr" , & self . rxoerr_iclr ()) . field ("rxmatch_iclr" , & self . rxmatch_iclr ()) . field ("rxfull_iclr" , & self . rxfull_iclr ()) . field ("txept_iclr" , & self . txept_iclr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Intclr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Intclr {{ tx_iclr: {=bool:?}, rx_iclr: {=bool:?}, underrun_iclr: {=bool:?}, rxoerr_iclr: {=bool:?}, rxmatch_iclr: {=bool:?}, rxfull_iclr: {=bool:?}, txept_iclr: {=bool:?} }}" , self . tx_iclr () , self . rx_iclr () , self . underrun_iclr () , self . rxoerr_iclr () , self . rxmatch_iclr () , self . rxfull_iclr () , self . txept_iclr ()) } } # [doc = "INTEN"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Inten (pub u32) ; impl Inten { # [doc = "Transmit FIFO empty interrupt enable bit"] # [must_use] # [inline (always)] pub const fn tx_ien (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Transmit FIFO empty interrupt enable bit"] # [inline (always)] pub const fn set_tx_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Receive FIFO interrupt enable bit"] # [must_use] # [inline (always)] pub const fn rx_ien (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Receive FIFO interrupt enable bit"] # [inline (always)] pub const fn set_rx_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Transmitter underrun interrupt enable bit(SPI slave mode only)"] # [must_use] # [inline (always)] pub const fn underrun_ien (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Transmitter underrun interrupt enable bit(SPI slave mode only)"] # [inline (always)] pub const fn set_underrun_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Overrun error interrupt enable bit"] # [must_use] # [inline (always)] pub const fn rxoerr_ien (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Overrun error interrupt enable bit"] # [inline (always)] pub const fn set_rxoerr_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Receive data complete interrupt enable bit"] # [must_use] # [inline (always)] pub const fn rxmatch_ien (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Receive data complete interrupt enable bit"] # [inline (always)] pub const fn set_rxmatch_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Receive FIFO full interrupt enable bit"] # [must_use] # [inline (always)] pub const fn rxfull_ien (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Receive FIFO full interrupt enable bit"] # [inline (always)] pub const fn set_rxfull_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Transmit empty interrupt enable bit"] # [must_use] # [inline (always)] pub const fn txept_ien (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Transmit empty interrupt enable bit"] # [inline (always)] pub const fn set_txept_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } } impl Default for Inten { # [inline (always)] fn default () -> Inten { Inten (0) } } impl core :: fmt :: Debug for Inten { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Inten") . field ("tx_ien" , & self . tx_ien ()) . field ("rx_ien" , & self . rx_ien ()) . field ("underrun_ien" , & self . underrun_ien ()) . field ("rxoerr_ien" , & self . rxoerr_ien ()) . field ("rxmatch_ien" , & self . rxmatch_ien ()) . field ("rxfull_ien" , & self . rxfull_ien ()) . field ("txept_ien" , & self . txept_ien ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Inten { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Inten {{ tx_ien: {=bool:?}, rx_ien: {=bool:?}, underrun_ien: {=bool:?}, rxoerr_ien: {=bool:?}, rxmatch_ien: {=bool:?}, rxfull_ien: {=bool:?}, txept_ien: {=bool:?} }}" , self . tx_ien () , self . rx_ien () , self . underrun_ien () , self . rxoerr_ien () , self . rxmatch_ien () , self . rxfull_ien () , self . txept_ien ()) } } # [doc = "INTSTAT"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Intstat (pub u32) ; impl Intstat { # [doc = "Transmit FIFO avialable interrupt flag bit"] # [must_use] # [inline (always)] pub const fn tx_intf (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Transmit FIFO avialable interrupt flag bit"] # [inline (always)] pub const fn set_tx_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Receive data available interrupt flag bit"] # [must_use] # [inline (always)] pub const fn rx_intf (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Receive data available interrupt flag bit"] # [inline (always)] pub const fn set_rx_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "SPI underrun interrupt flag bit"] # [must_use] # [inline (always)] pub const fn underrun_intf (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "SPI underrun interrupt flag bit"] # [inline (always)] pub const fn set_underrun_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Receive overrun error interrupt flag bit"] # [must_use] # [inline (always)] pub const fn rxoerr_intf (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Receive overrun error interrupt flag bit"] # [inline (always)] pub const fn set_rxoerr_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Receive data match the RXDNR number"] # [must_use] # [inline (always)] pub const fn rxmatch_intf (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Receive data match the RXDNR number"] # [inline (always)] pub const fn set_rxmatch_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "RX FIFO full interrupt flag bit"] # [must_use] # [inline (always)] pub const fn rxfull_intf (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "RX FIFO full interrupt flag bit"] # [inline (always)] pub const fn set_rxfull_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Transmitter empty interrupt flag bit"] # [must_use] # [inline (always)] pub const fn txept_intf (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Transmitter empty interrupt flag bit"] # [inline (always)] pub const fn set_txept_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } } impl Default for Intstat { # [inline (always)] fn default () -> Intstat { Intstat (0) } } impl core :: fmt :: Debug for Intstat { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Intstat") . field ("tx_intf" , & self . tx_intf ()) . field ("rx_intf" , & self . rx_intf ()) . field ("underrun_intf" , & self . underrun_intf ()) . field ("rxoerr_intf" , & self . rxoerr_intf ()) . field ("rxmatch_intf" , & self . rxmatch_intf ()) . field ("rxfull_intf" , & self . rxfull_intf ()) . field ("txept_intf" , & self . txept_intf ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Intstat { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Intstat {{ tx_intf: {=bool:?}, rx_intf: {=bool:?}, underrun_intf: {=bool:?}, rxoerr_intf: {=bool:?}, rxmatch_intf: {=bool:?}, rxfull_intf: {=bool:?}, txept_intf: {=bool:?} }}" , self . tx_intf () , self . rx_intf () , self . underrun_intf () , self . rxoerr_intf () , self . rxmatch_intf () , self . rxfull_intf () , self . txept_intf ()) } } # [doc = "NSSR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Nssr (pub u32) ; impl Nssr { # [doc = "Chip select output signal in Master mode"] # [must_use] # [inline (always)] pub const fn nss (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Chip select output signal in Master mode"] # [inline (always)] pub const fn set_nss (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Nssr { # [inline (always)] fn default () -> Nssr { Nssr (0) } } impl core :: fmt :: Debug for Nssr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Nssr") . field ("nss" , & self . nss ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Nssr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Nssr {{ nss: {=bool:?} }}" , self . nss ()) } } # [doc = "RXDNR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rxdnr (pub u32) ; impl Rxdnr { # [doc = "The register is used to hold a count of to be received bytes in next receive process"] # [must_use] # [inline (always)] pub const fn rxdnr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "The register is used to hold a count of to be received bytes in next receive process"] # [inline (always)] pub const fn set_rxdnr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Rxdnr { # [inline (always)] fn default () -> Rxdnr { Rxdnr (0) } } impl core :: fmt :: Debug for Rxdnr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rxdnr") . field ("rxdnr" , & self . rxdnr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rxdnr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rxdnr {{ rxdnr: {=u16:?} }}" , self . rxdnr ()) } } # [doc = "RXREG"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rxreg (pub u32) ; impl Rxreg { # [doc = "Receive data register"] # [must_use] # [inline (always)] pub const fn rxreg (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Receive data register"] # [inline (always)] pub const fn set_rxreg (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Rxreg { # [inline (always)] fn default () -> Rxreg { Rxreg (0) } } impl core :: fmt :: Debug for Rxreg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rxreg") . field ("rxreg" , & self . rxreg ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rxreg { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rxreg {{ rxreg: {=u32:?} }}" , self . rxreg ()) } } # [doc = "SPBRG"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Spbrg (pub u32) ; impl Spbrg { # [doc = "SPI baud rate control register for baud rate"] # [must_use] # [inline (always)] pub const fn spbrg (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "SPI baud rate control register for baud rate"] # [inline (always)] pub const fn set_spbrg (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Spbrg { # [inline (always)] fn default () -> Spbrg { Spbrg (0) } } impl core :: fmt :: Debug for Spbrg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spbrg") . field ("spbrg" , & self . spbrg ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Spbrg { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Spbrg {{ spbrg: {=u16:?} }}" , self . spbrg ()) } } # [doc = "TXREG"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Txreg (pub u32) ; impl Txreg { # [doc = "Transmit data register"] # [must_use] # [inline (always)] pub const fn txreg (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Transmit data register"] # [inline (always)] pub const fn set_txreg (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Txreg { # [inline (always)] fn default () -> Txreg { Txreg (0) } } impl core :: fmt :: Debug for Txreg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Txreg") . field ("txreg" , & self . txreg ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Txreg { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Txreg {{ txreg: {=u32:?} }}" , self . txreg ()) } } } } pub mod tim1 { # [doc = "Advanced timer"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Tim1 { ptr : * mut u8 } unsafe impl Send for Tim1 { } unsafe impl Sync for Tim1 { } impl Tim1 { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "control register 1"] # [inline (always)] pub const fn cr1 (self) -> crate :: common :: Reg < regs :: Cr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "control register 2"] # [inline (always)] pub const fn cr2 (self) -> crate :: common :: Reg < regs :: Cr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "slave mode control register 1"] # [inline (always)] pub const fn smcr (self) -> crate :: common :: Reg < regs :: Smcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "DMA/Interrupt enable register"] # [inline (always)] pub const fn dier (self) -> crate :: common :: Reg < regs :: Dier , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "status register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "event generation register"] # [inline (always)] pub const fn egr (self) -> crate :: common :: Reg < regs :: Egr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "capture/compare mode register 1 (input mode)"] # [inline (always)] pub const fn ccmr1_input (self) -> crate :: common :: Reg < regs :: Ccmr1Input , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare mode register 1 (output mode)"] # [inline (always)] pub const fn ccmr1_output (self) -> crate :: common :: Reg < regs :: Ccmr1Output , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare mode register 2 (input mode)"] # [inline (always)] pub const fn ccmr2_input (self) -> crate :: common :: Reg < regs :: Ccmr2Input , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "capture/compare mode register 2(output mode)"] # [inline (always)] pub const fn ccmr2_output (self) -> crate :: common :: Reg < regs :: Ccmr2Output , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "capture/compare enable register"] # [inline (always)] pub const fn ccer (self) -> crate :: common :: Reg < regs :: Ccer , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "counter"] # [inline (always)] pub const fn cnt (self) -> crate :: common :: Reg < regs :: Cnt , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "prescaler"] # [inline (always)] pub const fn psc (self) -> crate :: common :: Reg < regs :: Psc , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "auto-reload register"] # [inline (always)] pub const fn arr (self) -> crate :: common :: Reg < regs :: Arr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x2cusize) as _) } } # [doc = "repetition counter register"] # [inline (always)] pub const fn rcr (self) -> crate :: common :: Reg < regs :: Rcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x30usize) as _) } } # [doc = "capture/compare register 1"] # [inline (always)] pub const fn ccr1 (self) -> crate :: common :: Reg < regs :: Ccr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x34usize) as _) } } # [doc = "capture/compare register 2"] # [inline (always)] pub const fn ccr2 (self) -> crate :: common :: Reg < regs :: Ccr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x38usize) as _) } } # [doc = "capture/compare register 3"] # [inline (always)] pub const fn ccr3 (self) -> crate :: common :: Reg < regs :: Ccr3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x3cusize) as _) } } # [doc = "capture/compare register 4"] # [inline (always)] pub const fn ccr4 (self) -> crate :: common :: Reg < regs :: Ccr4 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x40usize) as _) } } # [doc = "break and dead-time register"] # [inline (always)] pub const fn bdtr (self) -> crate :: common :: Reg < regs :: Bdtr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x44usize) as _) } } # [doc = "DMA control register"] # [inline (always)] pub const fn dcr (self) -> crate :: common :: Reg < regs :: Dcr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x48usize) as _) } } # [doc = "DMA address for full transfer"] # [inline (always)] pub const fn dmar (self) -> crate :: common :: Reg < regs :: Dmar , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x4cusize) as _) } } # [doc = "capture/compare mode register 3 (output mode)"] # [inline (always)] pub const fn ccmr3_output (self) -> crate :: common :: Reg < regs :: Ccmr3Output , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x54usize) as _) } } # [doc = "capture/compare register 5"] # [inline (always)] pub const fn ccr5 (self) -> crate :: common :: Reg < regs :: Ccr5 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x58usize) as _) } } } pub mod regs { # [doc = "auto-reload register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Arr (pub u32) ; impl Arr { # [doc = "Auto reload value"] # [must_use] # [inline (always)] pub const fn arr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Auto reload value"] # [inline (always)] pub const fn set_arr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Arr { # [inline (always)] fn default () -> Arr { Arr (0) } } impl core :: fmt :: Debug for Arr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Arr") . field ("arr" , & self . arr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Arr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Arr {{ arr: {=u16:?} }}" , self . arr ()) } } # [doc = "break and dead-time register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Bdtr (pub u32) ; impl Bdtr { # [doc = "Dead-time generator setup"] # [must_use] # [inline (always)] pub const fn dtg (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Dead-time generator setup"] # [inline (always)] pub const fn set_dtg (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } # [doc = "Lock configuration"] # [must_use] # [inline (always)] pub const fn lock (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Lock configuration"] # [inline (always)] pub const fn set_lock (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Off-state selection for Idle mode"] # [must_use] # [inline (always)] pub const fn ossi (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Off-state selection for Idle mode"] # [inline (always)] pub const fn set_ossi (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Off-state selection for Run mode"] # [must_use] # [inline (always)] pub const fn ossr (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Off-state selection for Run mode"] # [inline (always)] pub const fn set_ossr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Break enable"] # [must_use] # [inline (always)] pub const fn bke (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Break enable"] # [inline (always)] pub const fn set_bke (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Break polarity"] # [must_use] # [inline (always)] pub const fn bkp (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Break polarity"] # [inline (always)] pub const fn set_bkp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Automatic output enable"] # [must_use] # [inline (always)] pub const fn aoe (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Automatic output enable"] # [inline (always)] pub const fn set_aoe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Main output enable"] # [must_use] # [inline (always)] pub const fn moe (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Main output enable"] # [inline (always)] pub const fn set_moe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } # [doc = "Direct output enable"] # [must_use] # [inline (always)] pub const fn doe (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Direct output enable"] # [inline (always)] pub const fn set_doe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } } impl Default for Bdtr { # [inline (always)] fn default () -> Bdtr { Bdtr (0) } } impl core :: fmt :: Debug for Bdtr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Bdtr") . field ("dtg" , & self . dtg ()) . field ("lock" , & self . lock ()) . field ("ossi" , & self . ossi ()) . field ("ossr" , & self . ossr ()) . field ("bke" , & self . bke ()) . field ("bkp" , & self . bkp ()) . field ("aoe" , & self . aoe ()) . field ("moe" , & self . moe ()) . field ("doe" , & self . doe ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Bdtr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Bdtr {{ dtg: {=u8:?}, lock: {=u8:?}, ossi: {=bool:?}, ossr: {=bool:?}, bke: {=bool:?}, bkp: {=bool:?}, aoe: {=bool:?}, moe: {=bool:?}, doe: {=bool:?} }}" , self . dtg () , self . lock () , self . ossi () , self . ossr () , self . bke () , self . bkp () , self . aoe () , self . moe () , self . doe ()) } } # [doc = "capture/compare enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccer (pub u32) ; impl Ccer { # [doc = "Capture/Compare 1 output enable"] # [must_use] # [inline (always)] pub const fn cc1e (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output enable"] # [inline (always)] pub const fn set_cc1e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 output polarity"] # [must_use] # [inline (always)] pub const fn cc1p (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output polarity"] # [inline (always)] pub const fn set_cc1p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 1 complementary output enable"] # [must_use] # [inline (always)] pub const fn cc1ne (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 complementary output enable"] # [inline (always)] pub const fn set_cc1ne (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare 1 complementary output polarity"] # [must_use] # [inline (always)] pub const fn cc1np (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 complementary output polarity"] # [inline (always)] pub const fn set_cc1np (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/Compare 2 output enable"] # [must_use] # [inline (always)] pub const fn cc2e (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 output enable"] # [inline (always)] pub const fn set_cc2e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Capture/Compare 2 output polarity"] # [must_use] # [inline (always)] pub const fn cc2p (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 output polarity"] # [inline (always)] pub const fn set_cc2p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Capture/Compare 2 complementary output enable"] # [must_use] # [inline (always)] pub const fn cc2ne (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 complementary output enable"] # [inline (always)] pub const fn set_cc2ne (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Capture/Compare 2 complementary output polarity"] # [must_use] # [inline (always)] pub const fn cc2np (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 complementary output polarity"] # [inline (always)] pub const fn set_cc2np (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capture/Compare 3 output enable"] # [must_use] # [inline (always)] pub const fn cc3e (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 output enable"] # [inline (always)] pub const fn set_cc3e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Capture/Compare 3 output polarity"] # [must_use] # [inline (always)] pub const fn cc3p (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 output polarity"] # [inline (always)] pub const fn set_cc3p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Capture/Compare 3 complementary output enable"] # [must_use] # [inline (always)] pub const fn cc3ne (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 complementary output enable"] # [inline (always)] pub const fn set_cc3ne (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Capture/Compare 3 complementary output polarity"] # [must_use] # [inline (always)] pub const fn cc3np (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 complementary output polarity"] # [inline (always)] pub const fn set_cc3np (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Capture/Compare 4 output enable"] # [must_use] # [inline (always)] pub const fn cc4e (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 output enable"] # [inline (always)] pub const fn set_cc4e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Capture/Compare 4 output polarity"] # [must_use] # [inline (always)] pub const fn cc4p (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 output polarity"] # [inline (always)] pub const fn set_cc4p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Capture/Compare 5 output enable"] # [must_use] # [inline (always)] pub const fn cc5e (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 5 output enable"] # [inline (always)] pub const fn set_cc5e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Capture/Compare 5 output polarity"] # [must_use] # [inline (always)] pub const fn cc5p (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 5 output polarity"] # [inline (always)] pub const fn set_cc5p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } } impl Default for Ccer { # [inline (always)] fn default () -> Ccer { Ccer (0) } } impl core :: fmt :: Debug for Ccer { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccer") . field ("cc1e" , & self . cc1e ()) . field ("cc1p" , & self . cc1p ()) . field ("cc1ne" , & self . cc1ne ()) . field ("cc1np" , & self . cc1np ()) . field ("cc2e" , & self . cc2e ()) . field ("cc2p" , & self . cc2p ()) . field ("cc2ne" , & self . cc2ne ()) . field ("cc2np" , & self . cc2np ()) . field ("cc3e" , & self . cc3e ()) . field ("cc3p" , & self . cc3p ()) . field ("cc3ne" , & self . cc3ne ()) . field ("cc3np" , & self . cc3np ()) . field ("cc4e" , & self . cc4e ()) . field ("cc4p" , & self . cc4p ()) . field ("cc5e" , & self . cc5e ()) . field ("cc5p" , & self . cc5p ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccer { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccer {{ cc1e: {=bool:?}, cc1p: {=bool:?}, cc1ne: {=bool:?}, cc1np: {=bool:?}, cc2e: {=bool:?}, cc2p: {=bool:?}, cc2ne: {=bool:?}, cc2np: {=bool:?}, cc3e: {=bool:?}, cc3p: {=bool:?}, cc3ne: {=bool:?}, cc3np: {=bool:?}, cc4e: {=bool:?}, cc4p: {=bool:?}, cc5e: {=bool:?}, cc5p: {=bool:?} }}" , self . cc1e () , self . cc1p () , self . cc1ne () , self . cc1np () , self . cc2e () , self . cc2p () , self . cc2ne () , self . cc2np () , self . cc3e () , self . cc3p () , self . cc3ne () , self . cc3np () , self . cc4e () , self . cc4p () , self . cc5e () , self . cc5p ()) } } # [doc = "capture/compare mode register 1 (input mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Input (pub u32) ; impl Ccmr1Input { # [doc = "Capture/compare 1 selection"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/compare 1 selection"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Input capture 1 prescaler"] # [must_use] # [inline (always)] pub const fn ic1psc (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Input capture 1 prescaler"] # [inline (always)] pub const fn set_ic1psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Input capture 1 filter"] # [must_use] # [inline (always)] pub const fn ic1f (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Input capture 1 filter"] # [inline (always)] pub const fn set_ic1f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Capture/Compare 2 selection"] # [must_use] # [inline (always)] pub const fn cc2s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 2 selection"] # [inline (always)] pub const fn set_cc2s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Input capture 2 prescaler"] # [must_use] # [inline (always)] pub const fn ic2psc (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Input capture 2 prescaler"] # [inline (always)] pub const fn set_ic2psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Input capture 2 filter"] # [must_use] # [inline (always)] pub const fn ic2f (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "Input capture 2 filter"] # [inline (always)] pub const fn set_ic2f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Ccmr1Input { # [inline (always)] fn default () -> Ccmr1Input { Ccmr1Input (0) } } impl core :: fmt :: Debug for Ccmr1Input { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Input") . field ("cc1s" , & self . cc1s ()) . field ("ic1psc" , & self . ic1psc ()) . field ("ic1f" , & self . ic1f ()) . field ("cc2s" , & self . cc2s ()) . field ("ic2psc" , & self . ic2psc ()) . field ("ic2f" , & self . ic2f ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Input { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Input {{ cc1s: {=u8:?}, ic1psc: {=u8:?}, ic1f: {=u8:?}, cc2s: {=u8:?}, ic2psc: {=u8:?}, ic2f: {=u8:?} }}" , self . cc1s () , self . ic1psc () , self . ic1f () , self . cc2s () , self . ic2psc () , self . ic2f ()) } } # [doc = "capture/compare mode register 1 (output mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Output (pub u32) ; impl Ccmr1Output { # [doc = "Capture/Compare 2 output enable"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 2 output enable"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Output compare 1 fast enable"] # [must_use] # [inline (always)] pub const fn oc1fe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 fast enable"] # [inline (always)] pub const fn set_oc1fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Output compare 1 preload enable"] # [must_use] # [inline (always)] pub const fn oc1pe (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 preload enable"] # [inline (always)] pub const fn set_oc1pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output compare 1 mode"] # [must_use] # [inline (always)] pub const fn oc1m (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Output compare 1 mode"] # [inline (always)] pub const fn set_oc1m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Output compare 1 clear enable"] # [must_use] # [inline (always)] pub const fn oc1ce (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 clear enable"] # [inline (always)] pub const fn set_oc1ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capure/Compare 2 selection"] # [must_use] # [inline (always)] pub const fn cc2s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capure/Compare 2 selection"] # [inline (always)] pub const fn set_cc2s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Output compare 4 fast enable"] # [must_use] # [inline (always)] pub const fn oc2fe (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 fast enable"] # [inline (always)] pub const fn set_oc2fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Output compare 2 preload enable"] # [must_use] # [inline (always)] pub const fn oc2pe (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Output compare 2 preload enable"] # [inline (always)] pub const fn set_oc2pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Output compare 2 mode"] # [must_use] # [inline (always)] pub const fn oc2m (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x07 ; val as u8 } # [doc = "Output compare 2 mode"] # [inline (always)] pub const fn set_oc2m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize) ; } # [doc = "Output compare 2 clear enable"] # [must_use] # [inline (always)] pub const fn oc2ce (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Output compare 2 clear enable"] # [inline (always)] pub const fn set_oc2ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccmr1Output { # [inline (always)] fn default () -> Ccmr1Output { Ccmr1Output (0) } } impl core :: fmt :: Debug for Ccmr1Output { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Output") . field ("cc1s" , & self . cc1s ()) . field ("oc1fe" , & self . oc1fe ()) . field ("oc1pe" , & self . oc1pe ()) . field ("oc1m" , & self . oc1m ()) . field ("oc1ce" , & self . oc1ce ()) . field ("cc2s" , & self . cc2s ()) . field ("oc2fe" , & self . oc2fe ()) . field ("oc2pe" , & self . oc2pe ()) . field ("oc2m" , & self . oc2m ()) . field ("oc2ce" , & self . oc2ce ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Output { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Output {{ cc1s: {=u8:?}, oc1fe: {=bool:?}, oc1pe: {=bool:?}, oc1m: {=u8:?}, oc1ce: {=bool:?}, cc2s: {=u8:?}, oc2fe: {=bool:?}, oc2pe: {=bool:?}, oc2m: {=u8:?}, oc2ce: {=bool:?} }}" , self . cc1s () , self . oc1fe () , self . oc1pe () , self . oc1m () , self . oc1ce () , self . cc2s () , self . oc2fe () , self . oc2pe () , self . oc2m () , self . oc2ce ()) } } # [doc = "capture/compare mode register 2 (input mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr2Input (pub u32) ; impl Ccmr2Input { # [doc = "Capture/compare 3 selection"] # [must_use] # [inline (always)] pub const fn cc3s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/compare 3 selection"] # [inline (always)] pub const fn set_cc3s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Input capture 3 prescaler"] # [must_use] # [inline (always)] pub const fn ic3psc (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Input capture 3 prescaler"] # [inline (always)] pub const fn set_ic3psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Input capture 3 filter"] # [must_use] # [inline (always)] pub const fn ic3f (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Input capture 3 filter"] # [inline (always)] pub const fn set_ic3f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Capture/Compare 4 selection"] # [must_use] # [inline (always)] pub const fn cc4s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 4 selection"] # [inline (always)] pub const fn set_cc4s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Input capture 4 prescaler"] # [must_use] # [inline (always)] pub const fn ic4psc (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Input capture 4 prescaler"] # [inline (always)] pub const fn set_ic4psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Input capture 4 filter"] # [must_use] # [inline (always)] pub const fn ic4f (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "Input capture 4 filter"] # [inline (always)] pub const fn set_ic4f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Ccmr2Input { # [inline (always)] fn default () -> Ccmr2Input { Ccmr2Input (0) } } impl core :: fmt :: Debug for Ccmr2Input { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr2Input") . field ("cc3s" , & self . cc3s ()) . field ("ic3psc" , & self . ic3psc ()) . field ("ic3f" , & self . ic3f ()) . field ("cc4s" , & self . cc4s ()) . field ("ic4psc" , & self . ic4psc ()) . field ("ic4f" , & self . ic4f ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr2Input { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr2Input {{ cc3s: {=u8:?}, ic3psc: {=u8:?}, ic3f: {=u8:?}, cc4s: {=u8:?}, ic4psc: {=u8:?}, ic4f: {=u8:?} }}" , self . cc3s () , self . ic3psc () , self . ic3f () , self . cc4s () , self . ic4psc () , self . ic4f ()) } } # [doc = "capture/compare mode register 2(output mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr2Output (pub u32) ; impl Ccmr2Output { # [doc = "Capture/Compare 3 selection"] # [must_use] # [inline (always)] pub const fn cc3s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 3 selection"] # [inline (always)] pub const fn set_cc3s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Output compare 3 fast enable"] # [must_use] # [inline (always)] pub const fn oc3fe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Output compare 3 fast enable"] # [inline (always)] pub const fn set_oc3fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Output compare 3 preload enable"] # [must_use] # [inline (always)] pub const fn oc3pe (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare 3 preload enable"] # [inline (always)] pub const fn set_oc3pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output compare 3 mode"] # [must_use] # [inline (always)] pub const fn oc3m (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Output compare 3 mode"] # [inline (always)] pub const fn set_oc3m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Output compare 3 clear enable"] # [must_use] # [inline (always)] pub const fn oc3ce (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Output compare 3 clear enable"] # [inline (always)] pub const fn set_oc3ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capture/Compare 4 selection"] # [must_use] # [inline (always)] pub const fn cc4s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 4 selection"] # [inline (always)] pub const fn set_cc4s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Output compare 4 fast enable"] # [must_use] # [inline (always)] pub const fn oc4fe (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 fast enable"] # [inline (always)] pub const fn set_oc4fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Output compare 4 preload enable"] # [must_use] # [inline (always)] pub const fn oc4pe (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 preload enable"] # [inline (always)] pub const fn set_oc4pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Output compare 4 mode"] # [must_use] # [inline (always)] pub const fn oc4m (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x07 ; val as u8 } # [doc = "Output compare 4 mode"] # [inline (always)] pub const fn set_oc4m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize) ; } # [doc = "Output compare 4 clear enable"] # [must_use] # [inline (always)] pub const fn oc4ce (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 clear enable"] # [inline (always)] pub const fn set_oc4ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccmr2Output { # [inline (always)] fn default () -> Ccmr2Output { Ccmr2Output (0) } } impl core :: fmt :: Debug for Ccmr2Output { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr2Output") . field ("cc3s" , & self . cc3s ()) . field ("oc3fe" , & self . oc3fe ()) . field ("oc3pe" , & self . oc3pe ()) . field ("oc3m" , & self . oc3m ()) . field ("oc3ce" , & self . oc3ce ()) . field ("cc4s" , & self . cc4s ()) . field ("oc4fe" , & self . oc4fe ()) . field ("oc4pe" , & self . oc4pe ()) . field ("oc4m" , & self . oc4m ()) . field ("oc4ce" , & self . oc4ce ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr2Output { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr2Output {{ cc3s: {=u8:?}, oc3fe: {=bool:?}, oc3pe: {=bool:?}, oc3m: {=u8:?}, oc3ce: {=bool:?}, cc4s: {=u8:?}, oc4fe: {=bool:?}, oc4pe: {=bool:?}, oc4m: {=u8:?}, oc4ce: {=bool:?} }}" , self . cc3s () , self . oc3fe () , self . oc3pe () , self . oc3m () , self . oc3ce () , self . cc4s () , self . oc4fe () , self . oc4pe () , self . oc4m () , self . oc4ce ()) } } # [doc = "capture/compare mode register 3 (output mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr3Output (pub u32) ; impl Ccmr3Output { # [doc = "Output compare 5 fast enable"] # [must_use] # [inline (always)] pub const fn oc5fe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Output compare 5 fast enable"] # [inline (always)] pub const fn set_oc5fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Output compare 5 preload enable"] # [must_use] # [inline (always)] pub const fn oc5pe (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare 5 preload enable"] # [inline (always)] pub const fn set_oc5pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output compare 5 mode"] # [must_use] # [inline (always)] pub const fn oc5m (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Output compare 5 mode"] # [inline (always)] pub const fn set_oc5m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Output compare 5 clear enable"] # [must_use] # [inline (always)] pub const fn oc5ce (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Output compare 5 clear enable"] # [inline (always)] pub const fn set_oc5ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } } impl Default for Ccmr3Output { # [inline (always)] fn default () -> Ccmr3Output { Ccmr3Output (0) } } impl core :: fmt :: Debug for Ccmr3Output { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr3Output") . field ("oc5fe" , & self . oc5fe ()) . field ("oc5pe" , & self . oc5pe ()) . field ("oc5m" , & self . oc5m ()) . field ("oc5ce" , & self . oc5ce ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr3Output { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr3Output {{ oc5fe: {=bool:?}, oc5pe: {=bool:?}, oc5m: {=u8:?}, oc5ce: {=bool:?} }}" , self . oc5fe () , self . oc5pe () , self . oc5m () , self . oc5ce ()) } } # [doc = "capture/compare register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr1 (pub u32) ; impl Ccr1 { # [doc = "Capture/Compare 1 value"] # [must_use] # [inline (always)] pub const fn ccr1 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 1 value"] # [inline (always)] pub const fn set_ccr1 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr1 { # [inline (always)] fn default () -> Ccr1 { Ccr1 (0) } } impl core :: fmt :: Debug for Ccr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr1") . field ("ccr1" , & self . ccr1 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr1 {{ ccr1: {=u16:?} }}" , self . ccr1 ()) } } # [doc = "capture/compare register 2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr2 (pub u32) ; impl Ccr2 { # [doc = "Capture/Compare 2 value"] # [must_use] # [inline (always)] pub const fn ccr2 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 2 value"] # [inline (always)] pub const fn set_ccr2 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr2 { # [inline (always)] fn default () -> Ccr2 { Ccr2 (0) } } impl core :: fmt :: Debug for Ccr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr2") . field ("ccr2" , & self . ccr2 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr2 {{ ccr2: {=u16:?} }}" , self . ccr2 ()) } } # [doc = "capture/compare register 3"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr3 (pub u32) ; impl Ccr3 { # [doc = "Capture/Compare 3 value"] # [must_use] # [inline (always)] pub const fn ccr3 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 3 value"] # [inline (always)] pub const fn set_ccr3 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr3 { # [inline (always)] fn default () -> Ccr3 { Ccr3 (0) } } impl core :: fmt :: Debug for Ccr3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr3") . field ("ccr3" , & self . ccr3 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr3 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr3 {{ ccr3: {=u16:?} }}" , self . ccr3 ()) } } # [doc = "capture/compare register 4"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr4 (pub u32) ; impl Ccr4 { # [doc = "Capture/Compare 4 value"] # [must_use] # [inline (always)] pub const fn ccr4 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 4 value"] # [inline (always)] pub const fn set_ccr4 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr4 { # [inline (always)] fn default () -> Ccr4 { Ccr4 (0) } } impl core :: fmt :: Debug for Ccr4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr4") . field ("ccr4" , & self . ccr4 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr4 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr4 {{ ccr4: {=u16:?} }}" , self . ccr4 ()) } } # [doc = "capture/compare register 5"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr5 (pub u32) ; impl Ccr5 { # [doc = "Capture/Compare 5 value"] # [must_use] # [inline (always)] pub const fn ccr5 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 5 value"] # [inline (always)] pub const fn set_ccr5 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr5 { # [inline (always)] fn default () -> Ccr5 { Ccr5 (0) } } impl core :: fmt :: Debug for Ccr5 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr5") . field ("ccr5" , & self . ccr5 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr5 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr5 {{ ccr5: {=u16:?} }}" , self . ccr5 ()) } } # [doc = "counter"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cnt (pub u32) ; impl Cnt { # [doc = "Counter value"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Counter value"] # [inline (always)] pub const fn set_cnt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Cnt { # [inline (always)] fn default () -> Cnt { Cnt (0) } } impl core :: fmt :: Debug for Cnt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cnt") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cnt { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cnt {{ cnt: {=u16:?} }}" , self . cnt ()) } } # [doc = "control register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr1 (pub u32) ; impl Cr1 { # [doc = "Counter enable"] # [must_use] # [inline (always)] pub const fn cen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Counter enable"] # [inline (always)] pub const fn set_cen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Update disable"] # [must_use] # [inline (always)] pub const fn udis (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Update disable"] # [inline (always)] pub const fn set_udis (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Update request source"] # [must_use] # [inline (always)] pub const fn urs (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Update request source"] # [inline (always)] pub const fn set_urs (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "One pulse mode"] # [must_use] # [inline (always)] pub const fn opm (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "One pulse mode"] # [inline (always)] pub const fn set_opm (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Direction"] # [must_use] # [inline (always)] pub const fn dir (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Direction"] # [inline (always)] pub const fn set_dir (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Center-aligned mode selection"] # [must_use] # [inline (always)] pub const fn cms (& self) -> u8 { let val = (self . 0 >> 5usize) & 0x03 ; val as u8 } # [doc = "Center-aligned mode selection"] # [inline (always)] pub const fn set_cms (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize) ; } # [doc = "Auto-reload preload enable"] # [must_use] # [inline (always)] pub const fn arpe (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Auto-reload preload enable"] # [inline (always)] pub const fn set_arpe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Clock division"] # [must_use] # [inline (always)] pub const fn ckd (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Clock division"] # [inline (always)] pub const fn set_ckd (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } } impl Default for Cr1 { # [inline (always)] fn default () -> Cr1 { Cr1 (0) } } impl core :: fmt :: Debug for Cr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr1") . field ("cen" , & self . cen ()) . field ("udis" , & self . udis ()) . field ("urs" , & self . urs ()) . field ("opm" , & self . opm ()) . field ("dir" , & self . dir ()) . field ("cms" , & self . cms ()) . field ("arpe" , & self . arpe ()) . field ("ckd" , & self . ckd ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr1 {{ cen: {=bool:?}, udis: {=bool:?}, urs: {=bool:?}, opm: {=bool:?}, dir: {=bool:?}, cms: {=u8:?}, arpe: {=bool:?}, ckd: {=u8:?} }}" , self . cen () , self . udis () , self . urs () , self . opm () , self . dir () , self . cms () , self . arpe () , self . ckd ()) } } # [doc = "control register 2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr2 (pub u32) ; impl Cr2 { # [doc = "Capture/compare preloaded control"] # [must_use] # [inline (always)] pub const fn ccpc (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Capture/compare preloaded control"] # [inline (always)] pub const fn set_ccpc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/compare control update selection"] # [must_use] # [inline (always)] pub const fn ccus (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/compare control update selection"] # [inline (always)] pub const fn set_ccus (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/compare DMA selection"] # [must_use] # [inline (always)] pub const fn ccds (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/compare DMA selection"] # [inline (always)] pub const fn set_ccds (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Master mode selection"] # [must_use] # [inline (always)] pub const fn mms (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Master mode selection"] # [inline (always)] pub const fn set_mms (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "TI1 selection"] # [must_use] # [inline (always)] pub const fn ti1s (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "TI1 selection"] # [inline (always)] pub const fn set_ti1s (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Output Idle state 1"] # [must_use] # [inline (always)] pub const fn ois1 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Output Idle state 1"] # [inline (always)] pub const fn set_ois1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Output Idle state 1"] # [must_use] # [inline (always)] pub const fn ois1n (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Output Idle state 1"] # [inline (always)] pub const fn set_ois1n (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "OIS2"] # [must_use] # [inline (always)] pub const fn ois2 (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "OIS2"] # [inline (always)] pub const fn set_ois2 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "OIS2N"] # [must_use] # [inline (always)] pub const fn ois2n (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "OIS2N"] # [inline (always)] pub const fn set_ois2n (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "OIS3"] # [must_use] # [inline (always)] pub const fn ois3 (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "OIS3"] # [inline (always)] pub const fn set_ois3 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "OIS3N"] # [must_use] # [inline (always)] pub const fn ois3n (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "OIS3N"] # [inline (always)] pub const fn set_ois3n (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "OIS4"] # [must_use] # [inline (always)] pub const fn ois4 (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "OIS4"] # [inline (always)] pub const fn set_ois4 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } } impl Default for Cr2 { # [inline (always)] fn default () -> Cr2 { Cr2 (0) } } impl core :: fmt :: Debug for Cr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr2") . field ("ccpc" , & self . ccpc ()) . field ("ccus" , & self . ccus ()) . field ("ccds" , & self . ccds ()) . field ("mms" , & self . mms ()) . field ("ti1s" , & self . ti1s ()) . field ("ois1" , & self . ois1 ()) . field ("ois1n" , & self . ois1n ()) . field ("ois2" , & self . ois2 ()) . field ("ois2n" , & self . ois2n ()) . field ("ois3" , & self . ois3 ()) . field ("ois3n" , & self . ois3n ()) . field ("ois4" , & self . ois4 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr2 {{ ccpc: {=bool:?}, ccus: {=bool:?}, ccds: {=bool:?}, mms: {=u8:?}, ti1s: {=bool:?}, ois1: {=bool:?}, ois1n: {=bool:?}, ois2: {=bool:?}, ois2n: {=bool:?}, ois3: {=bool:?}, ois3n: {=bool:?}, ois4: {=bool:?} }}" , self . ccpc () , self . ccus () , self . ccds () , self . mms () , self . ti1s () , self . ois1 () , self . ois1n () , self . ois2 () , self . ois2n () , self . ois3 () , self . ois3n () , self . ois4 ()) } } # [doc = "DMA control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dcr (pub u32) ; impl Dcr { # [doc = "DMA base address"] # [must_use] # [inline (always)] pub const fn dba (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x1f ; val as u8 } # [doc = "DMA base address"] # [inline (always)] pub const fn set_dba (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize) ; } # [doc = "DMA burst length"] # [must_use] # [inline (always)] pub const fn dbl (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x1f ; val as u8 } # [doc = "DMA burst length"] # [inline (always)] pub const fn set_dbl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize) ; } } impl Default for Dcr { # [inline (always)] fn default () -> Dcr { Dcr (0) } } impl core :: fmt :: Debug for Dcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dcr") . field ("dba" , & self . dba ()) . field ("dbl" , & self . dbl ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dcr {{ dba: {=u8:?}, dbl: {=u8:?} }}" , self . dba () , self . dbl ()) } } # [doc = "DMA/Interrupt enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dier (pub u32) ; impl Dier { # [doc = "Update interrupt enable"] # [must_use] # [inline (always)] pub const fn uie (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt enable"] # [inline (always)] pub const fn set_uie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc1ie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt enable"] # [inline (always)] pub const fn set_cc1ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 2 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc2ie (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 interrupt enable"] # [inline (always)] pub const fn set_cc2ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare 3 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc3ie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 interrupt enable"] # [inline (always)] pub const fn set_cc3ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/Compare 4 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc4ie (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 interrupt enable"] # [inline (always)] pub const fn set_cc4ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "COM interrupt enable"] # [must_use] # [inline (always)] pub const fn comie (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "COM interrupt enable"] # [inline (always)] pub const fn set_comie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Trigger interrupt enable"] # [must_use] # [inline (always)] pub const fn tie (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Trigger interrupt enable"] # [inline (always)] pub const fn set_tie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Break interrupt enable"] # [must_use] # [inline (always)] pub const fn bie (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Break interrupt enable"] # [inline (always)] pub const fn set_bie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Update DMA request enable"] # [must_use] # [inline (always)] pub const fn ude (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Update DMA request enable"] # [inline (always)] pub const fn set_ude (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Capture/Compare 1 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc1de (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 DMA request enable"] # [inline (always)] pub const fn set_cc1de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Capture/Compare 2 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc2de (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 DMA request enable"] # [inline (always)] pub const fn set_cc2de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Capture/Compare 3 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc3de (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 DMA request enable"] # [inline (always)] pub const fn set_cc3de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Capture/Compare 4 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc4de (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 DMA request enable"] # [inline (always)] pub const fn set_cc4de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "COM DMA request enable"] # [must_use] # [inline (always)] pub const fn comde (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "COM DMA request enable"] # [inline (always)] pub const fn set_comde (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Trigger DMA request enable"] # [must_use] # [inline (always)] pub const fn tde (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Trigger DMA request enable"] # [inline (always)] pub const fn set_tde (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Capture/Compare 5 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc5ie (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 5 interrupt enable"] # [inline (always)] pub const fn set_cc5ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } # [doc = "Capture/Compare 5 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc5de (& self) -> bool { let val = (self . 0 >> 17usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 5 DMA request enable"] # [inline (always)] pub const fn set_cc5de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize) ; } } impl Default for Dier { # [inline (always)] fn default () -> Dier { Dier (0) } } impl core :: fmt :: Debug for Dier { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dier") . field ("uie" , & self . uie ()) . field ("cc1ie" , & self . cc1ie ()) . field ("cc2ie" , & self . cc2ie ()) . field ("cc3ie" , & self . cc3ie ()) . field ("cc4ie" , & self . cc4ie ()) . field ("comie" , & self . comie ()) . field ("tie" , & self . tie ()) . field ("bie" , & self . bie ()) . field ("ude" , & self . ude ()) . field ("cc1de" , & self . cc1de ()) . field ("cc2de" , & self . cc2de ()) . field ("cc3de" , & self . cc3de ()) . field ("cc4de" , & self . cc4de ()) . field ("comde" , & self . comde ()) . field ("tde" , & self . tde ()) . field ("cc5ie" , & self . cc5ie ()) . field ("cc5de" , & self . cc5de ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dier { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dier {{ uie: {=bool:?}, cc1ie: {=bool:?}, cc2ie: {=bool:?}, cc3ie: {=bool:?}, cc4ie: {=bool:?}, comie: {=bool:?}, tie: {=bool:?}, bie: {=bool:?}, ude: {=bool:?}, cc1de: {=bool:?}, cc2de: {=bool:?}, cc3de: {=bool:?}, cc4de: {=bool:?}, comde: {=bool:?}, tde: {=bool:?}, cc5ie: {=bool:?}, cc5de: {=bool:?} }}" , self . uie () , self . cc1ie () , self . cc2ie () , self . cc3ie () , self . cc4ie () , self . comie () , self . tie () , self . bie () , self . ude () , self . cc1de () , self . cc2de () , self . cc3de () , self . cc4de () , self . comde () , self . tde () , self . cc5ie () , self . cc5de ()) } } # [doc = "DMA address for full transfer"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dmar (pub u32) ; impl Dmar { # [doc = "DMA register for burst accesses"] # [must_use] # [inline (always)] pub const fn dmab (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "DMA register for burst accesses"] # [inline (always)] pub const fn set_dmab (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Dmar { # [inline (always)] fn default () -> Dmar { Dmar (0) } } impl core :: fmt :: Debug for Dmar { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dmar") . field ("dmab" , & self . dmab ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dmar { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dmar {{ dmab: {=u16:?} }}" , self . dmab ()) } } # [doc = "event generation register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Egr (pub u32) ; impl Egr { # [doc = "Update generation"] # [must_use] # [inline (always)] pub const fn ug (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update generation"] # [inline (always)] pub const fn set_ug (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 generation"] # [must_use] # [inline (always)] pub const fn cc1g (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 generation"] # [inline (always)] pub const fn set_cc1g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 2 generation"] # [must_use] # [inline (always)] pub const fn cc2g (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 generation"] # [inline (always)] pub const fn set_cc2g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare 3 generation"] # [must_use] # [inline (always)] pub const fn cc3g (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 generation"] # [inline (always)] pub const fn set_cc3g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/Compare 4 generation"] # [must_use] # [inline (always)] pub const fn cc4g (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 generation"] # [inline (always)] pub const fn set_cc4g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Capture/Compare control update generation"] # [must_use] # [inline (always)] pub const fn comg (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare control update generation"] # [inline (always)] pub const fn set_comg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Trigger generation"] # [must_use] # [inline (always)] pub const fn tg (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Trigger generation"] # [inline (always)] pub const fn set_tg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Break generation"] # [must_use] # [inline (always)] pub const fn bg (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Break generation"] # [inline (always)] pub const fn set_bg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capture/Compare 5 generation"] # [must_use] # [inline (always)] pub const fn cc5g (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 5 generation"] # [inline (always)] pub const fn set_cc5g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } } impl Default for Egr { # [inline (always)] fn default () -> Egr { Egr (0) } } impl core :: fmt :: Debug for Egr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Egr") . field ("ug" , & self . ug ()) . field ("cc1g" , & self . cc1g ()) . field ("cc2g" , & self . cc2g ()) . field ("cc3g" , & self . cc3g ()) . field ("cc4g" , & self . cc4g ()) . field ("comg" , & self . comg ()) . field ("tg" , & self . tg ()) . field ("bg" , & self . bg ()) . field ("cc5g" , & self . cc5g ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Egr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Egr {{ ug: {=bool:?}, cc1g: {=bool:?}, cc2g: {=bool:?}, cc3g: {=bool:?}, cc4g: {=bool:?}, comg: {=bool:?}, tg: {=bool:?}, bg: {=bool:?}, cc5g: {=bool:?} }}" , self . ug () , self . cc1g () , self . cc2g () , self . cc3g () , self . cc4g () , self . comg () , self . tg () , self . bg () , self . cc5g ()) } } # [doc = "prescaler"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Psc (pub u32) ; impl Psc { # [doc = "Prescaler value"] # [must_use] # [inline (always)] pub const fn psc (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Prescaler value"] # [inline (always)] pub const fn set_psc (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Psc { # [inline (always)] fn default () -> Psc { Psc (0) } } impl core :: fmt :: Debug for Psc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Psc") . field ("psc" , & self . psc ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Psc { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Psc {{ psc: {=u16:?} }}" , self . psc ()) } } # [doc = "repetition counter register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rcr (pub u32) ; impl Rcr { # [doc = "Repetition counter value"] # [must_use] # [inline (always)] pub const fn rep (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Repetition counter value"] # [inline (always)] pub const fn set_rep (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Rcr { # [inline (always)] fn default () -> Rcr { Rcr (0) } } impl core :: fmt :: Debug for Rcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rcr") . field ("rep" , & self . rep ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rcr {{ rep: {=u8:?} }}" , self . rep ()) } } # [doc = "slave mode control register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Smcr (pub u32) ; impl Smcr { # [doc = "Slave mode selection"] # [must_use] # [inline (always)] pub const fn sms (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x07 ; val as u8 } # [doc = "Slave mode selection"] # [inline (always)] pub const fn set_sms (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize) ; } # [doc = "Output compare clear selection"] # [must_use] # [inline (always)] pub const fn occs (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare clear selection"] # [inline (always)] pub const fn set_occs (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Trigger selection"] # [must_use] # [inline (always)] pub const fn ts (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Trigger selection"] # [inline (always)] pub const fn set_ts (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Master/slave mode"] # [must_use] # [inline (always)] pub const fn msm (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Master/slave mode"] # [inline (always)] pub const fn set_msm (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "External trigger filter"] # [must_use] # [inline (always)] pub const fn etf (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "External trigger filter"] # [inline (always)] pub const fn set_etf (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "External trigger prescaler"] # [must_use] # [inline (always)] pub const fn etps (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "External trigger prescaler"] # [inline (always)] pub const fn set_etps (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "External clock enable"] # [must_use] # [inline (always)] pub const fn ece (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "External clock enable"] # [inline (always)] pub const fn set_ece (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "External trigger polarity"] # [must_use] # [inline (always)] pub const fn etp (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "External trigger polarity"] # [inline (always)] pub const fn set_etp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Smcr { # [inline (always)] fn default () -> Smcr { Smcr (0) } } impl core :: fmt :: Debug for Smcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Smcr") . field ("sms" , & self . sms ()) . field ("occs" , & self . occs ()) . field ("ts" , & self . ts ()) . field ("msm" , & self . msm ()) . field ("etf" , & self . etf ()) . field ("etps" , & self . etps ()) . field ("ece" , & self . ece ()) . field ("etp" , & self . etp ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Smcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Smcr {{ sms: {=u8:?}, occs: {=bool:?}, ts: {=u8:?}, msm: {=bool:?}, etf: {=u8:?}, etps: {=u8:?}, ece: {=bool:?}, etp: {=bool:?} }}" , self . sms () , self . occs () , self . ts () , self . msm () , self . etf () , self . etps () , self . ece () , self . etp ()) } } # [doc = "status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "Update interrupt flag"] # [must_use] # [inline (always)] pub const fn uif (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt flag"] # [inline (always)] pub const fn set_uif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc1if (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt flag"] # [inline (always)] pub const fn set_cc1if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 2 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc2if (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 interrupt flag"] # [inline (always)] pub const fn set_cc2if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare 3 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc3if (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 interrupt flag"] # [inline (always)] pub const fn set_cc3if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/Compare 4 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc4if (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 interrupt flag"] # [inline (always)] pub const fn set_cc4if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "COM interrupt flag"] # [must_use] # [inline (always)] pub const fn comif (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "COM interrupt flag"] # [inline (always)] pub const fn set_comif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Trigger interrupt flag"] # [must_use] # [inline (always)] pub const fn tif (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Trigger interrupt flag"] # [inline (always)] pub const fn set_tif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Break interrupt flag"] # [must_use] # [inline (always)] pub const fn bif (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Break interrupt flag"] # [inline (always)] pub const fn set_bif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capture/Compare 1 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc1of (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 overcapture flag"] # [inline (always)] pub const fn set_cc1of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Capture/Compare 2 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc2of (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 overcapture flag"] # [inline (always)] pub const fn set_cc2of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Capture/Compare 3 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc3of (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 overcapture flag"] # [inline (always)] pub const fn set_cc3of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Capture/Compare 4 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc4of (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 overcapture flag"] # [inline (always)] pub const fn set_cc4of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Capture/Compare 5 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc5if (& self) -> bool { let val = (self . 0 >> 16usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 5 interrupt flag"] # [inline (always)] pub const fn set_cc5if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("uif" , & self . uif ()) . field ("cc1if" , & self . cc1if ()) . field ("cc2if" , & self . cc2if ()) . field ("cc3if" , & self . cc3if ()) . field ("cc4if" , & self . cc4if ()) . field ("comif" , & self . comif ()) . field ("tif" , & self . tif ()) . field ("bif" , & self . bif ()) . field ("cc1of" , & self . cc1of ()) . field ("cc2of" , & self . cc2of ()) . field ("cc3of" , & self . cc3of ()) . field ("cc4of" , & self . cc4of ()) . field ("cc5if" , & self . cc5if ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ uif: {=bool:?}, cc1if: {=bool:?}, cc2if: {=bool:?}, cc3if: {=bool:?}, cc4if: {=bool:?}, comif: {=bool:?}, tif: {=bool:?}, bif: {=bool:?}, cc1of: {=bool:?}, cc2of: {=bool:?}, cc3of: {=bool:?}, cc4of: {=bool:?}, cc5if: {=bool:?} }}" , self . uif () , self . cc1if () , self . cc2if () , self . cc3if () , self . cc4if () , self . comif () , self . tif () , self . bif () , self . cc1of () , self . cc2of () , self . cc3of () , self . cc4of () , self . cc5if ()) } } } } pub mod tim14 { # [doc = "Basic purpose timer"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Tim14 { ptr : * mut u8 } unsafe impl Send for Tim14 { } unsafe impl Sync for Tim14 { } impl Tim14 { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "control register 1"] # [inline (always)] pub const fn cr1 (self) -> crate :: common :: Reg < regs :: Cr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "DMA/Interrupt enable register"] # [inline (always)] pub const fn dier (self) -> crate :: common :: Reg < regs :: Dier , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "status register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "event generation register"] # [inline (always)] pub const fn egr (self) -> crate :: common :: Reg < regs :: Egr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "capture/compare mode register 1 (input mode)"] # [inline (always)] pub const fn ccmr1_input (self) -> crate :: common :: Reg < regs :: Ccmr1Input , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare mode register 1 (output mode)"] # [inline (always)] pub const fn ccmr1_output (self) -> crate :: common :: Reg < regs :: Ccmr1Output , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare enable register"] # [inline (always)] pub const fn ccer (self) -> crate :: common :: Reg < regs :: Ccer , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "counter"] # [inline (always)] pub const fn cnt (self) -> crate :: common :: Reg < regs :: Cnt , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "prescaler"] # [inline (always)] pub const fn psc (self) -> crate :: common :: Reg < regs :: Psc , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "auto-reload register"] # [inline (always)] pub const fn arr (self) -> crate :: common :: Reg < regs :: Arr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x2cusize) as _) } } # [doc = "capture/compare register 1"] # [inline (always)] pub const fn ccr1 (self) -> crate :: common :: Reg < regs :: Ccr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x34usize) as _) } } } pub mod regs { # [doc = "auto-reload register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Arr (pub u32) ; impl Arr { # [doc = "auto-reload value"] # [must_use] # [inline (always)] pub const fn arr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "auto-reload value"] # [inline (always)] pub const fn set_arr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Arr { # [inline (always)] fn default () -> Arr { Arr (0) } } impl core :: fmt :: Debug for Arr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Arr") . field ("arr" , & self . arr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Arr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Arr {{ arr: {=u16:?} }}" , self . arr ()) } } # [doc = "capture/compare enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccer (pub u32) ; impl Ccer { # [doc = "Capture/Compare 1 output enable"] # [must_use] # [inline (always)] pub const fn cc1e (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output enable"] # [inline (always)] pub const fn set_cc1e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 output polarity"] # [must_use] # [inline (always)] pub const fn cc1p (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output polarity"] # [inline (always)] pub const fn set_cc1p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 1 complementary output polarity"] # [must_use] # [inline (always)] pub const fn cc1np (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 complementary output polarity"] # [inline (always)] pub const fn set_cc1np (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } } impl Default for Ccer { # [inline (always)] fn default () -> Ccer { Ccer (0) } } impl core :: fmt :: Debug for Ccer { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccer") . field ("cc1e" , & self . cc1e ()) . field ("cc1p" , & self . cc1p ()) . field ("cc1np" , & self . cc1np ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccer { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccer {{ cc1e: {=bool:?}, cc1p: {=bool:?}, cc1np: {=bool:?} }}" , self . cc1e () , self . cc1p () , self . cc1np ()) } } # [doc = "capture/compare mode register 1 (input mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Input (pub u32) ; impl Ccmr1Input { # [doc = "Capture/compare 1 selection"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/compare 1 selection"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Input capture 1 prescaler"] # [must_use] # [inline (always)] pub const fn ic1psc (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Input capture 1 prescaler"] # [inline (always)] pub const fn set_ic1psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Input capture 1 filter"] # [must_use] # [inline (always)] pub const fn ic1f (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Input capture 1 filter"] # [inline (always)] pub const fn set_ic1f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } } impl Default for Ccmr1Input { # [inline (always)] fn default () -> Ccmr1Input { Ccmr1Input (0) } } impl core :: fmt :: Debug for Ccmr1Input { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Input") . field ("cc1s" , & self . cc1s ()) . field ("ic1psc" , & self . ic1psc ()) . field ("ic1f" , & self . ic1f ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Input { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Input {{ cc1s: {=u8:?}, ic1psc: {=u8:?}, ic1f: {=u8:?} }}" , self . cc1s () , self . ic1psc () , self . ic1f ()) } } # [doc = "capture/compare mode register 1 (output mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Output (pub u32) ; impl Ccmr1Output { # [doc = "Capture/Compare 2 output enable"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 2 output enable"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Output compare 1 fast enable"] # [must_use] # [inline (always)] pub const fn oc1fe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 fast enable"] # [inline (always)] pub const fn set_oc1fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Output compare 1 preload enable"] # [must_use] # [inline (always)] pub const fn oc1pe (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 preload enable"] # [inline (always)] pub const fn set_oc1pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output compare 1 mode"] # [must_use] # [inline (always)] pub const fn oc1m (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Output compare 1 mode"] # [inline (always)] pub const fn set_oc1m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } } impl Default for Ccmr1Output { # [inline (always)] fn default () -> Ccmr1Output { Ccmr1Output (0) } } impl core :: fmt :: Debug for Ccmr1Output { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Output") . field ("cc1s" , & self . cc1s ()) . field ("oc1fe" , & self . oc1fe ()) . field ("oc1pe" , & self . oc1pe ()) . field ("oc1m" , & self . oc1m ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Output { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Output {{ cc1s: {=u8:?}, oc1fe: {=bool:?}, oc1pe: {=bool:?}, oc1m: {=u8:?} }}" , self . cc1s () , self . oc1fe () , self . oc1pe () , self . oc1m ()) } } # [doc = "capture/compare register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr1 (pub u32) ; impl Ccr1 { # [doc = "Capture/Compare 1 value"] # [must_use] # [inline (always)] pub const fn ccr1 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 1 value"] # [inline (always)] pub const fn set_ccr1 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr1 { # [inline (always)] fn default () -> Ccr1 { Ccr1 (0) } } impl core :: fmt :: Debug for Ccr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr1") . field ("ccr1" , & self . ccr1 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr1 {{ ccr1: {=u16:?} }}" , self . ccr1 ()) } } # [doc = "counter"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cnt (pub u32) ; impl Cnt { # [doc = "Counter value"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Counter value"] # [inline (always)] pub const fn set_cnt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Cnt { # [inline (always)] fn default () -> Cnt { Cnt (0) } } impl core :: fmt :: Debug for Cnt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cnt") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cnt { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cnt {{ cnt: {=u16:?} }}" , self . cnt ()) } } # [doc = "control register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr1 (pub u32) ; impl Cr1 { # [doc = "Counter enable"] # [must_use] # [inline (always)] pub const fn cen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Counter enable"] # [inline (always)] pub const fn set_cen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Update disable"] # [must_use] # [inline (always)] pub const fn udis (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Update disable"] # [inline (always)] pub const fn set_udis (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Update request source"] # [must_use] # [inline (always)] pub const fn urs (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Update request source"] # [inline (always)] pub const fn set_urs (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Auto-reload preload enable"] # [must_use] # [inline (always)] pub const fn arpe (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Auto-reload preload enable"] # [inline (always)] pub const fn set_arpe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Clock division"] # [must_use] # [inline (always)] pub const fn ckd (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Clock division"] # [inline (always)] pub const fn set_ckd (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } } impl Default for Cr1 { # [inline (always)] fn default () -> Cr1 { Cr1 (0) } } impl core :: fmt :: Debug for Cr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr1") . field ("cen" , & self . cen ()) . field ("udis" , & self . udis ()) . field ("urs" , & self . urs ()) . field ("arpe" , & self . arpe ()) . field ("ckd" , & self . ckd ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr1 {{ cen: {=bool:?}, udis: {=bool:?}, urs: {=bool:?}, arpe: {=bool:?}, ckd: {=u8:?} }}" , self . cen () , self . udis () , self . urs () , self . arpe () , self . ckd ()) } } # [doc = "DMA/Interrupt enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dier (pub u32) ; impl Dier { # [doc = "Update interrupt enable"] # [must_use] # [inline (always)] pub const fn uie (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt enable"] # [inline (always)] pub const fn set_uie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc1ie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt enable"] # [inline (always)] pub const fn set_cc1ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } } impl Default for Dier { # [inline (always)] fn default () -> Dier { Dier (0) } } impl core :: fmt :: Debug for Dier { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dier") . field ("uie" , & self . uie ()) . field ("cc1ie" , & self . cc1ie ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dier { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dier {{ uie: {=bool:?}, cc1ie: {=bool:?} }}" , self . uie () , self . cc1ie ()) } } # [doc = "event generation register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Egr (pub u32) ; impl Egr { # [doc = "Update generation"] # [must_use] # [inline (always)] pub const fn ug (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update generation"] # [inline (always)] pub const fn set_ug (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 generation"] # [must_use] # [inline (always)] pub const fn cc1g (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 generation"] # [inline (always)] pub const fn set_cc1g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } } impl Default for Egr { # [inline (always)] fn default () -> Egr { Egr (0) } } impl core :: fmt :: Debug for Egr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Egr") . field ("ug" , & self . ug ()) . field ("cc1g" , & self . cc1g ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Egr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Egr {{ ug: {=bool:?}, cc1g: {=bool:?} }}" , self . ug () , self . cc1g ()) } } # [doc = "prescaler"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Psc (pub u32) ; impl Psc { # [doc = "Prescaler value"] # [must_use] # [inline (always)] pub const fn psc (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Prescaler value"] # [inline (always)] pub const fn set_psc (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Psc { # [inline (always)] fn default () -> Psc { Psc (0) } } impl core :: fmt :: Debug for Psc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Psc") . field ("psc" , & self . psc ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Psc { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Psc {{ psc: {=u16:?} }}" , self . psc ()) } } # [doc = "status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "Update interrupt flag"] # [must_use] # [inline (always)] pub const fn uif (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt flag"] # [inline (always)] pub const fn set_uif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc1if (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt flag"] # [inline (always)] pub const fn set_cc1if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 1 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc1of (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 overcapture flag"] # [inline (always)] pub const fn set_cc1of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("uif" , & self . uif ()) . field ("cc1if" , & self . cc1if ()) . field ("cc1of" , & self . cc1of ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ uif: {=bool:?}, cc1if: {=bool:?}, cc1of: {=bool:?} }}" , self . uif () , self . cc1if () , self . cc1of ()) } } } } pub mod tim16 { # [doc = "Basic purpose timer"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Tim16 { ptr : * mut u8 } unsafe impl Send for Tim16 { } unsafe impl Sync for Tim16 { } impl Tim16 { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "control register 1"] # [inline (always)] pub const fn cr1 (self) -> crate :: common :: Reg < regs :: Cr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "control register 2"] # [inline (always)] pub const fn cr2 (self) -> crate :: common :: Reg < regs :: Cr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "DMA/Interrupt enable register"] # [inline (always)] pub const fn dier (self) -> crate :: common :: Reg < regs :: Dier , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "status register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "event generation register"] # [inline (always)] pub const fn egr (self) -> crate :: common :: Reg < regs :: Egr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "capture/compare mode register 1 (input mode)"] # [inline (always)] pub const fn ccmr1_input (self) -> crate :: common :: Reg < regs :: Ccmr1Input , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare mode register 1 (output mode)"] # [inline (always)] pub const fn ccmr1_output (self) -> crate :: common :: Reg < regs :: Ccmr1Output , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare enable register"] # [inline (always)] pub const fn ccer (self) -> crate :: common :: Reg < regs :: Ccer , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "counter"] # [inline (always)] pub const fn cnt (self) -> crate :: common :: Reg < regs :: Cnt , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "prescaler"] # [inline (always)] pub const fn psc (self) -> crate :: common :: Reg < regs :: Psc , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "auto-reload register"] # [inline (always)] pub const fn arr (self) -> crate :: common :: Reg < regs :: Arr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x2cusize) as _) } } # [doc = "repetition counter register"] # [inline (always)] pub const fn rcr (self) -> crate :: common :: Reg < regs :: Rcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x30usize) as _) } } # [doc = "capture/compare register 1"] # [inline (always)] pub const fn ccr1 (self) -> crate :: common :: Reg < regs :: Ccr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x34usize) as _) } } # [doc = "break and dead-time register"] # [inline (always)] pub const fn bdtr (self) -> crate :: common :: Reg < regs :: Bdtr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x44usize) as _) } } # [doc = "DMA control register"] # [inline (always)] pub const fn dcr (self) -> crate :: common :: Reg < regs :: Dcr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x48usize) as _) } } # [doc = "DMA address for full transfer"] # [inline (always)] pub const fn dmar (self) -> crate :: common :: Reg < regs :: Dmar , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x4cusize) as _) } } } pub mod regs { # [doc = "auto-reload register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Arr (pub u32) ; impl Arr { # [doc = "Auto reload value"] # [must_use] # [inline (always)] pub const fn arr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Auto reload value"] # [inline (always)] pub const fn set_arr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Arr { # [inline (always)] fn default () -> Arr { Arr (0) } } impl core :: fmt :: Debug for Arr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Arr") . field ("arr" , & self . arr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Arr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Arr {{ arr: {=u16:?} }}" , self . arr ()) } } # [doc = "break and dead-time register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Bdtr (pub u32) ; impl Bdtr { # [doc = "Dead-time generation setup"] # [must_use] # [inline (always)] pub const fn dtg (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Dead-time generation setup"] # [inline (always)] pub const fn set_dtg (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } # [doc = "Lock configuration"] # [must_use] # [inline (always)] pub const fn lock (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Lock configuration"] # [inline (always)] pub const fn set_lock (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Off-state selection for idle mode"] # [must_use] # [inline (always)] pub const fn ossi (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Off-state selection for idle mode"] # [inline (always)] pub const fn set_ossi (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Off-state selection for run mode"] # [must_use] # [inline (always)] pub const fn ossr (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Off-state selection for run mode"] # [inline (always)] pub const fn set_ossr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Break enable"] # [must_use] # [inline (always)] pub const fn bke (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Break enable"] # [inline (always)] pub const fn set_bke (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Break polarity"] # [must_use] # [inline (always)] pub const fn bkp (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Break polarity"] # [inline (always)] pub const fn set_bkp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } # [doc = "Automatic output enable"] # [must_use] # [inline (always)] pub const fn aoe (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Automatic output enable"] # [inline (always)] pub const fn set_aoe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "Main output enable"] # [must_use] # [inline (always)] pub const fn moe (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Main output enable"] # [inline (always)] pub const fn set_moe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Bdtr { # [inline (always)] fn default () -> Bdtr { Bdtr (0) } } impl core :: fmt :: Debug for Bdtr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Bdtr") . field ("dtg" , & self . dtg ()) . field ("lock" , & self . lock ()) . field ("ossi" , & self . ossi ()) . field ("ossr" , & self . ossr ()) . field ("bke" , & self . bke ()) . field ("bkp" , & self . bkp ()) . field ("aoe" , & self . aoe ()) . field ("moe" , & self . moe ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Bdtr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Bdtr {{ dtg: {=u8:?}, lock: {=u8:?}, ossi: {=bool:?}, ossr: {=bool:?}, bke: {=bool:?}, bkp: {=bool:?}, aoe: {=bool:?}, moe: {=bool:?} }}" , self . dtg () , self . lock () , self . ossi () , self . ossr () , self . bke () , self . bkp () , self . aoe () , self . moe ()) } } # [doc = "capture/compare enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccer (pub u32) ; impl Ccer { # [doc = "Capture/Compare 1 output enable"] # [must_use] # [inline (always)] pub const fn cc1e (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output enable"] # [inline (always)] pub const fn set_cc1e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 output polarity"] # [must_use] # [inline (always)] pub const fn cc1p (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output polarity"] # [inline (always)] pub const fn set_cc1p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 1 complementary output enable"] # [must_use] # [inline (always)] pub const fn cc1ne (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 complementary output enable"] # [inline (always)] pub const fn set_cc1ne (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare 1 complementary output Polarity"] # [must_use] # [inline (always)] pub const fn cc1np (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 complementary output Polarity"] # [inline (always)] pub const fn set_cc1np (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } } impl Default for Ccer { # [inline (always)] fn default () -> Ccer { Ccer (0) } } impl core :: fmt :: Debug for Ccer { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccer") . field ("cc1e" , & self . cc1e ()) . field ("cc1p" , & self . cc1p ()) . field ("cc1ne" , & self . cc1ne ()) . field ("cc1np" , & self . cc1np ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccer { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccer {{ cc1e: {=bool:?}, cc1p: {=bool:?}, cc1ne: {=bool:?}, cc1np: {=bool:?} }}" , self . cc1e () , self . cc1p () , self . cc1ne () , self . cc1np ()) } } # [doc = "capture/compare mode register 1 (input mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Input (pub u32) ; impl Ccmr1Input { # [doc = "Capture/compare 1 selection"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/compare 1 selection"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Input capture 1 prescaler"] # [must_use] # [inline (always)] pub const fn ic1psc (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Input capture 1 prescaler"] # [inline (always)] pub const fn set_ic1psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Input capture 1 filter"] # [must_use] # [inline (always)] pub const fn ic1f (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Input capture 1 filter"] # [inline (always)] pub const fn set_ic1f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } } impl Default for Ccmr1Input { # [inline (always)] fn default () -> Ccmr1Input { Ccmr1Input (0) } } impl core :: fmt :: Debug for Ccmr1Input { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Input") . field ("cc1s" , & self . cc1s ()) . field ("ic1psc" , & self . ic1psc ()) . field ("ic1f" , & self . ic1f ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Input { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Input {{ cc1s: {=u8:?}, ic1psc: {=u8:?}, ic1f: {=u8:?} }}" , self . cc1s () , self . ic1psc () , self . ic1f ()) } } # [doc = "capture/compare mode register 1 (output mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Output (pub u32) ; impl Ccmr1Output { # [doc = "Capture/Compare 2 output enable"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 2 output enable"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Output compare 1 fast enable"] # [must_use] # [inline (always)] pub const fn oc1fe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 fast enable"] # [inline (always)] pub const fn set_oc1fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Output compare 1 preload enable"] # [must_use] # [inline (always)] pub const fn oc1pe (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 preload enable"] # [inline (always)] pub const fn set_oc1pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output compare 1 mode"] # [must_use] # [inline (always)] pub const fn oc1m (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Output compare 1 mode"] # [inline (always)] pub const fn set_oc1m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } } impl Default for Ccmr1Output { # [inline (always)] fn default () -> Ccmr1Output { Ccmr1Output (0) } } impl core :: fmt :: Debug for Ccmr1Output { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Output") . field ("cc1s" , & self . cc1s ()) . field ("oc1fe" , & self . oc1fe ()) . field ("oc1pe" , & self . oc1pe ()) . field ("oc1m" , & self . oc1m ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Output { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Output {{ cc1s: {=u8:?}, oc1fe: {=bool:?}, oc1pe: {=bool:?}, oc1m: {=u8:?} }}" , self . cc1s () , self . oc1fe () , self . oc1pe () , self . oc1m ()) } } # [doc = "capture/compare register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr1 (pub u32) ; impl Ccr1 { # [doc = "Capture/Compare 1 value"] # [must_use] # [inline (always)] pub const fn ccr1 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 1 value"] # [inline (always)] pub const fn set_ccr1 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr1 { # [inline (always)] fn default () -> Ccr1 { Ccr1 (0) } } impl core :: fmt :: Debug for Ccr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr1") . field ("ccr1" , & self . ccr1 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr1 {{ ccr1: {=u16:?} }}" , self . ccr1 ()) } } # [doc = "counter"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cnt (pub u32) ; impl Cnt { # [doc = "Counter value"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Counter value"] # [inline (always)] pub const fn set_cnt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Cnt { # [inline (always)] fn default () -> Cnt { Cnt (0) } } impl core :: fmt :: Debug for Cnt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cnt") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cnt { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cnt {{ cnt: {=u16:?} }}" , self . cnt ()) } } # [doc = "control register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr1 (pub u32) ; impl Cr1 { # [doc = "Counter enable"] # [must_use] # [inline (always)] pub const fn cen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Counter enable"] # [inline (always)] pub const fn set_cen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Update disable"] # [must_use] # [inline (always)] pub const fn udis (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Update disable"] # [inline (always)] pub const fn set_udis (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Update request source"] # [must_use] # [inline (always)] pub const fn urs (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Update request source"] # [inline (always)] pub const fn set_urs (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "One pulse mode"] # [must_use] # [inline (always)] pub const fn opm (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "One pulse mode"] # [inline (always)] pub const fn set_opm (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Auto-reload preload enable"] # [must_use] # [inline (always)] pub const fn arpe (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Auto-reload preload enable"] # [inline (always)] pub const fn set_arpe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Clock division"] # [must_use] # [inline (always)] pub const fn ckd (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Clock division"] # [inline (always)] pub const fn set_ckd (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } } impl Default for Cr1 { # [inline (always)] fn default () -> Cr1 { Cr1 (0) } } impl core :: fmt :: Debug for Cr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr1") . field ("cen" , & self . cen ()) . field ("udis" , & self . udis ()) . field ("urs" , & self . urs ()) . field ("opm" , & self . opm ()) . field ("arpe" , & self . arpe ()) . field ("ckd" , & self . ckd ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr1 {{ cen: {=bool:?}, udis: {=bool:?}, urs: {=bool:?}, opm: {=bool:?}, arpe: {=bool:?}, ckd: {=u8:?} }}" , self . cen () , self . udis () , self . urs () , self . opm () , self . arpe () , self . ckd ()) } } # [doc = "control register 2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr2 (pub u32) ; impl Cr2 { # [doc = "Capture/compare preloaded control"] # [must_use] # [inline (always)] pub const fn ccpc (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Capture/compare preloaded control"] # [inline (always)] pub const fn set_ccpc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/compare control update selection"] # [must_use] # [inline (always)] pub const fn ccus (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/compare control update selection"] # [inline (always)] pub const fn set_ccus (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare DMA selection"] # [must_use] # [inline (always)] pub const fn ccds (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare DMA selection"] # [inline (always)] pub const fn set_ccds (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output idle state 1"] # [must_use] # [inline (always)] pub const fn ois1 (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Output idle state 1"] # [inline (always)] pub const fn set_ois1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Output idle state 1"] # [must_use] # [inline (always)] pub const fn ois1n (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Output idle state 1"] # [inline (always)] pub const fn set_ois1n (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } } impl Default for Cr2 { # [inline (always)] fn default () -> Cr2 { Cr2 (0) } } impl core :: fmt :: Debug for Cr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr2") . field ("ccpc" , & self . ccpc ()) . field ("ccus" , & self . ccus ()) . field ("ccds" , & self . ccds ()) . field ("ois1" , & self . ois1 ()) . field ("ois1n" , & self . ois1n ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr2 {{ ccpc: {=bool:?}, ccus: {=bool:?}, ccds: {=bool:?}, ois1: {=bool:?}, ois1n: {=bool:?} }}" , self . ccpc () , self . ccus () , self . ccds () , self . ois1 () , self . ois1n ()) } } # [doc = "DMA control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dcr (pub u32) ; impl Dcr { # [doc = "DMA base address"] # [must_use] # [inline (always)] pub const fn dba (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x1f ; val as u8 } # [doc = "DMA base address"] # [inline (always)] pub const fn set_dba (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize) ; } # [doc = "DMA burst length"] # [must_use] # [inline (always)] pub const fn dbl (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x1f ; val as u8 } # [doc = "DMA burst length"] # [inline (always)] pub const fn set_dbl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize) ; } } impl Default for Dcr { # [inline (always)] fn default () -> Dcr { Dcr (0) } } impl core :: fmt :: Debug for Dcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dcr") . field ("dba" , & self . dba ()) . field ("dbl" , & self . dbl ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dcr {{ dba: {=u8:?}, dbl: {=u8:?} }}" , self . dba () , self . dbl ()) } } # [doc = "DMA/Interrupt enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dier (pub u32) ; impl Dier { # [doc = "Update interrupt enable"] # [must_use] # [inline (always)] pub const fn uie (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt enable"] # [inline (always)] pub const fn set_uie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc1ie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt enable"] # [inline (always)] pub const fn set_cc1ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Compare interrupt enable"] # [must_use] # [inline (always)] pub const fn comie (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Compare interrupt enable"] # [inline (always)] pub const fn set_comie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "break interrupt enable"] # [must_use] # [inline (always)] pub const fn bie (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "break interrupt enable"] # [inline (always)] pub const fn set_bie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Update DMA request enable"] # [must_use] # [inline (always)] pub const fn ude (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Update DMA request enable"] # [inline (always)] pub const fn set_ude (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Capture/Compare 1 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc1de (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 DMA request enable"] # [inline (always)] pub const fn set_cc1de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } } impl Default for Dier { # [inline (always)] fn default () -> Dier { Dier (0) } } impl core :: fmt :: Debug for Dier { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dier") . field ("uie" , & self . uie ()) . field ("cc1ie" , & self . cc1ie ()) . field ("comie" , & self . comie ()) . field ("bie" , & self . bie ()) . field ("ude" , & self . ude ()) . field ("cc1de" , & self . cc1de ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dier { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dier {{ uie: {=bool:?}, cc1ie: {=bool:?}, comie: {=bool:?}, bie: {=bool:?}, ude: {=bool:?}, cc1de: {=bool:?} }}" , self . uie () , self . cc1ie () , self . comie () , self . bie () , self . ude () , self . cc1de ()) } } # [doc = "DMA address for full transfer"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dmar (pub u32) ; impl Dmar { # [doc = "DMA register for burst accesses"] # [must_use] # [inline (always)] pub const fn dmab (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "DMA register for burst accesses"] # [inline (always)] pub const fn set_dmab (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Dmar { # [inline (always)] fn default () -> Dmar { Dmar (0) } } impl core :: fmt :: Debug for Dmar { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dmar") . field ("dmab" , & self . dmab ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dmar { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dmar {{ dmab: {=u16:?} }}" , self . dmab ()) } } # [doc = "event generation register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Egr (pub u32) ; impl Egr { # [doc = "Update generation"] # [must_use] # [inline (always)] pub const fn ug (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update generation"] # [inline (always)] pub const fn set_ug (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/compare 1 generation"] # [must_use] # [inline (always)] pub const fn cc1g (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/compare 1 generation"] # [inline (always)] pub const fn set_cc1g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare control update generation"] # [must_use] # [inline (always)] pub const fn comg (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare control update generation"] # [inline (always)] pub const fn set_comg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Break generation"] # [must_use] # [inline (always)] pub const fn bg (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Break generation"] # [inline (always)] pub const fn set_bg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } } impl Default for Egr { # [inline (always)] fn default () -> Egr { Egr (0) } } impl core :: fmt :: Debug for Egr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Egr") . field ("ug" , & self . ug ()) . field ("cc1g" , & self . cc1g ()) . field ("comg" , & self . comg ()) . field ("bg" , & self . bg ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Egr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Egr {{ ug: {=bool:?}, cc1g: {=bool:?}, comg: {=bool:?}, bg: {=bool:?} }}" , self . ug () , self . cc1g () , self . comg () , self . bg ()) } } # [doc = "prescaler"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Psc (pub u32) ; impl Psc { # [doc = "Prescaler value"] # [must_use] # [inline (always)] pub const fn psc (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Prescaler value"] # [inline (always)] pub const fn set_psc (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Psc { # [inline (always)] fn default () -> Psc { Psc (0) } } impl core :: fmt :: Debug for Psc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Psc") . field ("psc" , & self . psc ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Psc { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Psc {{ psc: {=u16:?} }}" , self . psc ()) } } # [doc = "repetition counter register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rcr (pub u32) ; impl Rcr { # [doc = "Repetition counter value"] # [must_use] # [inline (always)] pub const fn rep (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Repetition counter value"] # [inline (always)] pub const fn set_rep (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Rcr { # [inline (always)] fn default () -> Rcr { Rcr (0) } } impl core :: fmt :: Debug for Rcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rcr") . field ("rep" , & self . rep ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rcr {{ rep: {=u8:?} }}" , self . rep ()) } } # [doc = "status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "Update interrupt flag"] # [must_use] # [inline (always)] pub const fn uif (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt flag"] # [inline (always)] pub const fn set_uif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc1if (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt flag"] # [inline (always)] pub const fn set_cc1if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "COM interrupt flag"] # [must_use] # [inline (always)] pub const fn comif (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "COM interrupt flag"] # [inline (always)] pub const fn set_comif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Break interrupt flag"] # [must_use] # [inline (always)] pub const fn bif (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Break interrupt flag"] # [inline (always)] pub const fn set_bif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capture/Compare 1 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc1of (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 overcapture flag"] # [inline (always)] pub const fn set_cc1of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("uif" , & self . uif ()) . field ("cc1if" , & self . cc1if ()) . field ("comif" , & self . comif ()) . field ("bif" , & self . bif ()) . field ("cc1of" , & self . cc1of ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ uif: {=bool:?}, cc1if: {=bool:?}, comif: {=bool:?}, bif: {=bool:?}, cc1of: {=bool:?} }}" , self . uif () , self . cc1if () , self . comif () , self . bif () , self . cc1of ()) } } } } pub mod tim2 { # [doc = "General purpose timer"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Tim2 { ptr : * mut u8 } unsafe impl Send for Tim2 { } unsafe impl Sync for Tim2 { } impl Tim2 { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "control register 1"] # [inline (always)] pub const fn cr1 (self) -> crate :: common :: Reg < regs :: Cr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "control register 2"] # [inline (always)] pub const fn cr2 (self) -> crate :: common :: Reg < regs :: Cr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "slave mode control register 1"] # [inline (always)] pub const fn smcr (self) -> crate :: common :: Reg < regs :: Smcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "DMA/Interrupt enable register"] # [inline (always)] pub const fn dier (self) -> crate :: common :: Reg < regs :: Dier , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "status register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "event generation register"] # [inline (always)] pub const fn egr (self) -> crate :: common :: Reg < regs :: Egr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "capture/compare mode register 1 (input mode)"] # [inline (always)] pub const fn ccmr1_input (self) -> crate :: common :: Reg < regs :: Ccmr1Input , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare mode register 1 (output mode)"] # [inline (always)] pub const fn ccmr1_output (self) -> crate :: common :: Reg < regs :: Ccmr1Output , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare mode register 2 (input mode)"] # [inline (always)] pub const fn ccmr2_input (self) -> crate :: common :: Reg < regs :: Ccmr2Input , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "capture/compare mode register 2(output mode)"] # [inline (always)] pub const fn ccmr2_output (self) -> crate :: common :: Reg < regs :: Ccmr2Output , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "capture/compare enable register"] # [inline (always)] pub const fn ccer (self) -> crate :: common :: Reg < regs :: Ccer , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "counter"] # [inline (always)] pub const fn cnt (self) -> crate :: common :: Reg < regs :: Cnt , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "prescaler"] # [inline (always)] pub const fn psc (self) -> crate :: common :: Reg < regs :: Psc , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "auto-reload register"] # [inline (always)] pub const fn arr (self) -> crate :: common :: Reg < regs :: Arr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x2cusize) as _) } } # [doc = "capture/compare register 1"] # [inline (always)] pub const fn ccr1 (self) -> crate :: common :: Reg < regs :: Ccr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x34usize) as _) } } # [doc = "capture/compare register 2"] # [inline (always)] pub const fn ccr2 (self) -> crate :: common :: Reg < regs :: Ccr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x38usize) as _) } } # [doc = "capture/compare register 3"] # [inline (always)] pub const fn ccr3 (self) -> crate :: common :: Reg < regs :: Ccr3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x3cusize) as _) } } # [doc = "capture/compare register 4"] # [inline (always)] pub const fn ccr4 (self) -> crate :: common :: Reg < regs :: Ccr4 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x40usize) as _) } } # [doc = "DMA control register"] # [inline (always)] pub const fn dcr (self) -> crate :: common :: Reg < regs :: Dcr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x48usize) as _) } } # [doc = "DMA address for full transfer"] # [inline (always)] pub const fn dmar (self) -> crate :: common :: Reg < regs :: Dmar , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x4cusize) as _) } } } pub mod regs { # [doc = "auto-reload register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Arr (pub u32) ; impl Arr { # [doc = "Auto reload value"] # [must_use] # [inline (always)] pub const fn arr (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Auto reload value"] # [inline (always)] pub const fn set_arr (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Arr { # [inline (always)] fn default () -> Arr { Arr (0) } } impl core :: fmt :: Debug for Arr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Arr") . field ("arr" , & self . arr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Arr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Arr {{ arr: {=u32:?} }}" , self . arr ()) } } # [doc = "capture/compare enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccer (pub u32) ; impl Ccer { # [doc = "Capture/Compare 1 output enable"] # [must_use] # [inline (always)] pub const fn cc1e (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output enable"] # [inline (always)] pub const fn set_cc1e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 output polarity"] # [must_use] # [inline (always)] pub const fn cc1p (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output polarity"] # [inline (always)] pub const fn set_cc1p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 2 output enable"] # [must_use] # [inline (always)] pub const fn cc2e (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 output enable"] # [inline (always)] pub const fn set_cc2e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Capture/Compare 2 output polarity"] # [must_use] # [inline (always)] pub const fn cc2p (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 output polarity"] # [inline (always)] pub const fn set_cc2p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Capture/Compare 3 output enable"] # [must_use] # [inline (always)] pub const fn cc3e (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 output enable"] # [inline (always)] pub const fn set_cc3e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Capture/Compare 3 output polarity"] # [must_use] # [inline (always)] pub const fn cc3p (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 output polarity"] # [inline (always)] pub const fn set_cc3p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Capture/Compare 4 output enable"] # [must_use] # [inline (always)] pub const fn cc4e (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 output enable"] # [inline (always)] pub const fn set_cc4e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Capture/Compare 4 output polarity"] # [must_use] # [inline (always)] pub const fn cc4p (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 output polarity"] # [inline (always)] pub const fn set_cc4p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } } impl Default for Ccer { # [inline (always)] fn default () -> Ccer { Ccer (0) } } impl core :: fmt :: Debug for Ccer { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccer") . field ("cc1e" , & self . cc1e ()) . field ("cc1p" , & self . cc1p ()) . field ("cc2e" , & self . cc2e ()) . field ("cc2p" , & self . cc2p ()) . field ("cc3e" , & self . cc3e ()) . field ("cc3p" , & self . cc3p ()) . field ("cc4e" , & self . cc4e ()) . field ("cc4p" , & self . cc4p ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccer { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccer {{ cc1e: {=bool:?}, cc1p: {=bool:?}, cc2e: {=bool:?}, cc2p: {=bool:?}, cc3e: {=bool:?}, cc3p: {=bool:?}, cc4e: {=bool:?}, cc4p: {=bool:?} }}" , self . cc1e () , self . cc1p () , self . cc2e () , self . cc2p () , self . cc3e () , self . cc3p () , self . cc4e () , self . cc4p ()) } } # [doc = "capture/compare mode register 1 (input mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Input (pub u32) ; impl Ccmr1Input { # [doc = "Capture/compare 1 selection"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/compare 1 selection"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Input capture 1 prescaler"] # [must_use] # [inline (always)] pub const fn ic1psc (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Input capture 1 prescaler"] # [inline (always)] pub const fn set_ic1psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Input capture 1 filter"] # [must_use] # [inline (always)] pub const fn ic1f (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Input capture 1 filter"] # [inline (always)] pub const fn set_ic1f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Capture/Compare 2 selection"] # [must_use] # [inline (always)] pub const fn cc2s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 2 selection"] # [inline (always)] pub const fn set_cc2s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Input capture 2 prescaler"] # [must_use] # [inline (always)] pub const fn ic2psc (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Input capture 2 prescaler"] # [inline (always)] pub const fn set_ic2psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Input capture 2 filter"] # [must_use] # [inline (always)] pub const fn ic2f (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "Input capture 2 filter"] # [inline (always)] pub const fn set_ic2f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Ccmr1Input { # [inline (always)] fn default () -> Ccmr1Input { Ccmr1Input (0) } } impl core :: fmt :: Debug for Ccmr1Input { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Input") . field ("cc1s" , & self . cc1s ()) . field ("ic1psc" , & self . ic1psc ()) . field ("ic1f" , & self . ic1f ()) . field ("cc2s" , & self . cc2s ()) . field ("ic2psc" , & self . ic2psc ()) . field ("ic2f" , & self . ic2f ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Input { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Input {{ cc1s: {=u8:?}, ic1psc: {=u8:?}, ic1f: {=u8:?}, cc2s: {=u8:?}, ic2psc: {=u8:?}, ic2f: {=u8:?} }}" , self . cc1s () , self . ic1psc () , self . ic1f () , self . cc2s () , self . ic2psc () , self . ic2f ()) } } # [doc = "capture/compare mode register 1 (output mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Output (pub u32) ; impl Ccmr1Output { # [doc = "Capture/Compare 2 output enable"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 2 output enable"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Output compare 1 fast enable"] # [must_use] # [inline (always)] pub const fn oc1fe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 fast enable"] # [inline (always)] pub const fn set_oc1fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Output compare 1 preload enable"] # [must_use] # [inline (always)] pub const fn oc1pe (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 preload enable"] # [inline (always)] pub const fn set_oc1pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output compare 1 mode"] # [must_use] # [inline (always)] pub const fn oc1m (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Output compare 1 mode"] # [inline (always)] pub const fn set_oc1m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Output compare 1 clear enable"] # [must_use] # [inline (always)] pub const fn oc1ce (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 clear enable"] # [inline (always)] pub const fn set_oc1ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capure/Compare 2 selection"] # [must_use] # [inline (always)] pub const fn cc2s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capure/Compare 2 selection"] # [inline (always)] pub const fn set_cc2s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Output compare 4 fast enable"] # [must_use] # [inline (always)] pub const fn oc2fe (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 fast enable"] # [inline (always)] pub const fn set_oc2fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Output compare 2 preload enable"] # [must_use] # [inline (always)] pub const fn oc2pe (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Output compare 2 preload enable"] # [inline (always)] pub const fn set_oc2pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Output compare 2 mode"] # [must_use] # [inline (always)] pub const fn oc2m (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x07 ; val as u8 } # [doc = "Output compare 2 mode"] # [inline (always)] pub const fn set_oc2m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize) ; } # [doc = "Output compare 2 clear enable"] # [must_use] # [inline (always)] pub const fn oc2ce (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Output compare 2 clear enable"] # [inline (always)] pub const fn set_oc2ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccmr1Output { # [inline (always)] fn default () -> Ccmr1Output { Ccmr1Output (0) } } impl core :: fmt :: Debug for Ccmr1Output { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Output") . field ("cc1s" , & self . cc1s ()) . field ("oc1fe" , & self . oc1fe ()) . field ("oc1pe" , & self . oc1pe ()) . field ("oc1m" , & self . oc1m ()) . field ("oc1ce" , & self . oc1ce ()) . field ("cc2s" , & self . cc2s ()) . field ("oc2fe" , & self . oc2fe ()) . field ("oc2pe" , & self . oc2pe ()) . field ("oc2m" , & self . oc2m ()) . field ("oc2ce" , & self . oc2ce ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Output { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Output {{ cc1s: {=u8:?}, oc1fe: {=bool:?}, oc1pe: {=bool:?}, oc1m: {=u8:?}, oc1ce: {=bool:?}, cc2s: {=u8:?}, oc2fe: {=bool:?}, oc2pe: {=bool:?}, oc2m: {=u8:?}, oc2ce: {=bool:?} }}" , self . cc1s () , self . oc1fe () , self . oc1pe () , self . oc1m () , self . oc1ce () , self . cc2s () , self . oc2fe () , self . oc2pe () , self . oc2m () , self . oc2ce ()) } } # [doc = "capture/compare mode register 2 (input mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr2Input (pub u32) ; impl Ccmr2Input { # [doc = "Capture/compare 3 selection"] # [must_use] # [inline (always)] pub const fn cc3s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/compare 3 selection"] # [inline (always)] pub const fn set_cc3s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Input capture 3 prescaler"] # [must_use] # [inline (always)] pub const fn ic3psc (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Input capture 3 prescaler"] # [inline (always)] pub const fn set_ic3psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Input capture 3 filter"] # [must_use] # [inline (always)] pub const fn ic3f (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Input capture 3 filter"] # [inline (always)] pub const fn set_ic3f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Capture/Compare 4 selection"] # [must_use] # [inline (always)] pub const fn cc4s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 4 selection"] # [inline (always)] pub const fn set_cc4s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Input capture 4 prescaler"] # [must_use] # [inline (always)] pub const fn ic4psc (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Input capture 4 prescaler"] # [inline (always)] pub const fn set_ic4psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Input capture 4 filter"] # [must_use] # [inline (always)] pub const fn ic4f (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "Input capture 4 filter"] # [inline (always)] pub const fn set_ic4f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Ccmr2Input { # [inline (always)] fn default () -> Ccmr2Input { Ccmr2Input (0) } } impl core :: fmt :: Debug for Ccmr2Input { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr2Input") . field ("cc3s" , & self . cc3s ()) . field ("ic3psc" , & self . ic3psc ()) . field ("ic3f" , & self . ic3f ()) . field ("cc4s" , & self . cc4s ()) . field ("ic4psc" , & self . ic4psc ()) . field ("ic4f" , & self . ic4f ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr2Input { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr2Input {{ cc3s: {=u8:?}, ic3psc: {=u8:?}, ic3f: {=u8:?}, cc4s: {=u8:?}, ic4psc: {=u8:?}, ic4f: {=u8:?} }}" , self . cc3s () , self . ic3psc () , self . ic3f () , self . cc4s () , self . ic4psc () , self . ic4f ()) } } # [doc = "capture/compare mode register 2(output mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr2Output (pub u32) ; impl Ccmr2Output { # [doc = "Capture/Compare 3 selection"] # [must_use] # [inline (always)] pub const fn cc3s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 3 selection"] # [inline (always)] pub const fn set_cc3s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Output compare 3 fast enable"] # [must_use] # [inline (always)] pub const fn oc3fe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Output compare 3 fast enable"] # [inline (always)] pub const fn set_oc3fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Output compare 3 preload enable"] # [must_use] # [inline (always)] pub const fn oc3pe (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare 3 preload enable"] # [inline (always)] pub const fn set_oc3pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output compare 3 mode"] # [must_use] # [inline (always)] pub const fn oc3m (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Output compare 3 mode"] # [inline (always)] pub const fn set_oc3m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Output compare 3 clear enable"] # [must_use] # [inline (always)] pub const fn oc3ce (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Output compare 3 clear enable"] # [inline (always)] pub const fn set_oc3ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capture/Compare 4 selection"] # [must_use] # [inline (always)] pub const fn cc4s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 4 selection"] # [inline (always)] pub const fn set_cc4s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Output compare 4 fast enable"] # [must_use] # [inline (always)] pub const fn oc4fe (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 fast enable"] # [inline (always)] pub const fn set_oc4fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Output compare 4 preload enable"] # [must_use] # [inline (always)] pub const fn oc4pe (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 preload enable"] # [inline (always)] pub const fn set_oc4pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Output compare 4 mode"] # [must_use] # [inline (always)] pub const fn oc4m (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x07 ; val as u8 } # [doc = "Output compare 4 mode"] # [inline (always)] pub const fn set_oc4m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize) ; } # [doc = "Output compare 4 clear enable"] # [must_use] # [inline (always)] pub const fn oc4ce (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 clear enable"] # [inline (always)] pub const fn set_oc4ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccmr2Output { # [inline (always)] fn default () -> Ccmr2Output { Ccmr2Output (0) } } impl core :: fmt :: Debug for Ccmr2Output { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr2Output") . field ("cc3s" , & self . cc3s ()) . field ("oc3fe" , & self . oc3fe ()) . field ("oc3pe" , & self . oc3pe ()) . field ("oc3m" , & self . oc3m ()) . field ("oc3ce" , & self . oc3ce ()) . field ("cc4s" , & self . cc4s ()) . field ("oc4fe" , & self . oc4fe ()) . field ("oc4pe" , & self . oc4pe ()) . field ("oc4m" , & self . oc4m ()) . field ("oc4ce" , & self . oc4ce ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr2Output { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr2Output {{ cc3s: {=u8:?}, oc3fe: {=bool:?}, oc3pe: {=bool:?}, oc3m: {=u8:?}, oc3ce: {=bool:?}, cc4s: {=u8:?}, oc4fe: {=bool:?}, oc4pe: {=bool:?}, oc4m: {=u8:?}, oc4ce: {=bool:?} }}" , self . cc3s () , self . oc3fe () , self . oc3pe () , self . oc3m () , self . oc3ce () , self . cc4s () , self . oc4fe () , self . oc4pe () , self . oc4m () , self . oc4ce ()) } } # [doc = "capture/compare register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr1 (pub u32) ; impl Ccr1 { # [doc = "Capture/Compare 1 value"] # [must_use] # [inline (always)] pub const fn ccr1 (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Capture/Compare 1 value"] # [inline (always)] pub const fn set_ccr1 (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Ccr1 { # [inline (always)] fn default () -> Ccr1 { Ccr1 (0) } } impl core :: fmt :: Debug for Ccr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr1") . field ("ccr1" , & self . ccr1 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr1 {{ ccr1: {=u32:?} }}" , self . ccr1 ()) } } # [doc = "capture/compare register 2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr2 (pub u32) ; impl Ccr2 { # [doc = "Capture/Compare 2 value"] # [must_use] # [inline (always)] pub const fn ccr2 (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Capture/Compare 2 value"] # [inline (always)] pub const fn set_ccr2 (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Ccr2 { # [inline (always)] fn default () -> Ccr2 { Ccr2 (0) } } impl core :: fmt :: Debug for Ccr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr2") . field ("ccr2" , & self . ccr2 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr2 {{ ccr2: {=u32:?} }}" , self . ccr2 ()) } } # [doc = "capture/compare register 3"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr3 (pub u32) ; impl Ccr3 { # [doc = "Capture/Compare 3 value"] # [must_use] # [inline (always)] pub const fn ccr3 (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Capture/Compare 3 value"] # [inline (always)] pub const fn set_ccr3 (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Ccr3 { # [inline (always)] fn default () -> Ccr3 { Ccr3 (0) } } impl core :: fmt :: Debug for Ccr3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr3") . field ("ccr3" , & self . ccr3 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr3 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr3 {{ ccr3: {=u32:?} }}" , self . ccr3 ()) } } # [doc = "capture/compare register 4"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr4 (pub u32) ; impl Ccr4 { # [doc = "Capture/Compare 4 value"] # [must_use] # [inline (always)] pub const fn ccr4 (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Capture/Compare 4 value"] # [inline (always)] pub const fn set_ccr4 (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Ccr4 { # [inline (always)] fn default () -> Ccr4 { Ccr4 (0) } } impl core :: fmt :: Debug for Ccr4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr4") . field ("ccr4" , & self . ccr4 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr4 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr4 {{ ccr4: {=u32:?} }}" , self . ccr4 ()) } } # [doc = "counter"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cnt (pub u32) ; impl Cnt { # [doc = "Counter value"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u32 { let val = (self . 0 >> 0usize) & 0xffff_ffff ; val as u32 } # [doc = "Counter value"] # [inline (always)] pub const fn set_cnt (& mut self , val : u32) { self . 0 = (self . 0 & ! (0xffff_ffff << 0usize)) | (((val as u32) & 0xffff_ffff) << 0usize) ; } } impl Default for Cnt { # [inline (always)] fn default () -> Cnt { Cnt (0) } } impl core :: fmt :: Debug for Cnt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cnt") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cnt { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cnt {{ cnt: {=u32:?} }}" , self . cnt ()) } } # [doc = "control register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr1 (pub u32) ; impl Cr1 { # [doc = "Counter enable"] # [must_use] # [inline (always)] pub const fn cen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Counter enable"] # [inline (always)] pub const fn set_cen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Update disable"] # [must_use] # [inline (always)] pub const fn udis (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Update disable"] # [inline (always)] pub const fn set_udis (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Update request source"] # [must_use] # [inline (always)] pub const fn urs (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Update request source"] # [inline (always)] pub const fn set_urs (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "One pulse mode"] # [must_use] # [inline (always)] pub const fn opm (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "One pulse mode"] # [inline (always)] pub const fn set_opm (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Direction"] # [must_use] # [inline (always)] pub const fn dir (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Direction"] # [inline (always)] pub const fn set_dir (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Center-aligned mode selection"] # [must_use] # [inline (always)] pub const fn cms (& self) -> u8 { let val = (self . 0 >> 5usize) & 0x03 ; val as u8 } # [doc = "Center-aligned mode selection"] # [inline (always)] pub const fn set_cms (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize) ; } # [doc = "Auto-reload preload enable"] # [must_use] # [inline (always)] pub const fn arpe (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Auto-reload preload enable"] # [inline (always)] pub const fn set_arpe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Clock division"] # [must_use] # [inline (always)] pub const fn ckd (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Clock division"] # [inline (always)] pub const fn set_ckd (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } } impl Default for Cr1 { # [inline (always)] fn default () -> Cr1 { Cr1 (0) } } impl core :: fmt :: Debug for Cr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr1") . field ("cen" , & self . cen ()) . field ("udis" , & self . udis ()) . field ("urs" , & self . urs ()) . field ("opm" , & self . opm ()) . field ("dir" , & self . dir ()) . field ("cms" , & self . cms ()) . field ("arpe" , & self . arpe ()) . field ("ckd" , & self . ckd ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr1 {{ cen: {=bool:?}, udis: {=bool:?}, urs: {=bool:?}, opm: {=bool:?}, dir: {=bool:?}, cms: {=u8:?}, arpe: {=bool:?}, ckd: {=u8:?} }}" , self . cen () , self . udis () , self . urs () , self . opm () , self . dir () , self . cms () , self . arpe () , self . ckd ()) } } # [doc = "control register 2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr2 (pub u32) ; impl Cr2 { # [doc = "Capture/Compare DMA selection"] # [must_use] # [inline (always)] pub const fn ccds (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare DMA selection"] # [inline (always)] pub const fn set_ccds (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Master mode selection"] # [must_use] # [inline (always)] pub const fn mms (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Master mode selection"] # [inline (always)] pub const fn set_mms (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "TI1 selection"] # [must_use] # [inline (always)] pub const fn ti1s (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "TI1 selection"] # [inline (always)] pub const fn set_ti1s (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } } impl Default for Cr2 { # [inline (always)] fn default () -> Cr2 { Cr2 (0) } } impl core :: fmt :: Debug for Cr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr2") . field ("ccds" , & self . ccds ()) . field ("mms" , & self . mms ()) . field ("ti1s" , & self . ti1s ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr2 {{ ccds: {=bool:?}, mms: {=u8:?}, ti1s: {=bool:?} }}" , self . ccds () , self . mms () , self . ti1s ()) } } # [doc = "DMA control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dcr (pub u32) ; impl Dcr { # [doc = "DMA base address"] # [must_use] # [inline (always)] pub const fn dba (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x1f ; val as u8 } # [doc = "DMA base address"] # [inline (always)] pub const fn set_dba (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize) ; } # [doc = "DMA burst length"] # [must_use] # [inline (always)] pub const fn dbl (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x1f ; val as u8 } # [doc = "DMA burst length"] # [inline (always)] pub const fn set_dbl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize) ; } } impl Default for Dcr { # [inline (always)] fn default () -> Dcr { Dcr (0) } } impl core :: fmt :: Debug for Dcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dcr") . field ("dba" , & self . dba ()) . field ("dbl" , & self . dbl ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dcr {{ dba: {=u8:?}, dbl: {=u8:?} }}" , self . dba () , self . dbl ()) } } # [doc = "DMA/Interrupt enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dier (pub u32) ; impl Dier { # [doc = "Update interrupt enable"] # [must_use] # [inline (always)] pub const fn uie (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt enable"] # [inline (always)] pub const fn set_uie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc1ie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt enable"] # [inline (always)] pub const fn set_cc1ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 2 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc2ie (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 interrupt enable"] # [inline (always)] pub const fn set_cc2ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare 3 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc3ie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 interrupt enable"] # [inline (always)] pub const fn set_cc3ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/Compare 4 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc4ie (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 interrupt enable"] # [inline (always)] pub const fn set_cc4ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Trigger interrupt enable"] # [must_use] # [inline (always)] pub const fn tie (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Trigger interrupt enable"] # [inline (always)] pub const fn set_tie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Update DMA request enable"] # [must_use] # [inline (always)] pub const fn ude (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Update DMA request enable"] # [inline (always)] pub const fn set_ude (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Capture/Compare 1 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc1de (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 DMA request enable"] # [inline (always)] pub const fn set_cc1de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Capture/Compare 2 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc2de (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 DMA request enable"] # [inline (always)] pub const fn set_cc2de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Capture/Compare 3 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc3de (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 DMA request enable"] # [inline (always)] pub const fn set_cc3de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Capture/Compare 4 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc4de (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 DMA request enable"] # [inline (always)] pub const fn set_cc4de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Trigger DMA request enable"] # [must_use] # [inline (always)] pub const fn tde (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Trigger DMA request enable"] # [inline (always)] pub const fn set_tde (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } } impl Default for Dier { # [inline (always)] fn default () -> Dier { Dier (0) } } impl core :: fmt :: Debug for Dier { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dier") . field ("uie" , & self . uie ()) . field ("cc1ie" , & self . cc1ie ()) . field ("cc2ie" , & self . cc2ie ()) . field ("cc3ie" , & self . cc3ie ()) . field ("cc4ie" , & self . cc4ie ()) . field ("tie" , & self . tie ()) . field ("ude" , & self . ude ()) . field ("cc1de" , & self . cc1de ()) . field ("cc2de" , & self . cc2de ()) . field ("cc3de" , & self . cc3de ()) . field ("cc4de" , & self . cc4de ()) . field ("tde" , & self . tde ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dier { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dier {{ uie: {=bool:?}, cc1ie: {=bool:?}, cc2ie: {=bool:?}, cc3ie: {=bool:?}, cc4ie: {=bool:?}, tie: {=bool:?}, ude: {=bool:?}, cc1de: {=bool:?}, cc2de: {=bool:?}, cc3de: {=bool:?}, cc4de: {=bool:?}, tde: {=bool:?} }}" , self . uie () , self . cc1ie () , self . cc2ie () , self . cc3ie () , self . cc4ie () , self . tie () , self . ude () , self . cc1de () , self . cc2de () , self . cc3de () , self . cc4de () , self . tde ()) } } # [doc = "DMA address for full transfer"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dmar (pub u32) ; impl Dmar { # [doc = "DMA register for burst accesses"] # [must_use] # [inline (always)] pub const fn dmab (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "DMA register for burst accesses"] # [inline (always)] pub const fn set_dmab (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Dmar { # [inline (always)] fn default () -> Dmar { Dmar (0) } } impl core :: fmt :: Debug for Dmar { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dmar") . field ("dmab" , & self . dmab ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dmar { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dmar {{ dmab: {=u16:?} }}" , self . dmab ()) } } # [doc = "event generation register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Egr (pub u32) ; impl Egr { # [doc = "Update generation"] # [must_use] # [inline (always)] pub const fn ug (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update generation"] # [inline (always)] pub const fn set_ug (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/compare 1 generation"] # [must_use] # [inline (always)] pub const fn cc1g (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/compare 1 generation"] # [inline (always)] pub const fn set_cc1g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/compare 2 generation"] # [must_use] # [inline (always)] pub const fn cc2g (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/compare 2 generation"] # [inline (always)] pub const fn set_cc2g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/compare 3 generation"] # [must_use] # [inline (always)] pub const fn cc3g (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/compare 3 generation"] # [inline (always)] pub const fn set_cc3g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/compare 4 generation"] # [must_use] # [inline (always)] pub const fn cc4g (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/compare 4 generation"] # [inline (always)] pub const fn set_cc4g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Trigger generation"] # [must_use] # [inline (always)] pub const fn tg (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Trigger generation"] # [inline (always)] pub const fn set_tg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } } impl Default for Egr { # [inline (always)] fn default () -> Egr { Egr (0) } } impl core :: fmt :: Debug for Egr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Egr") . field ("ug" , & self . ug ()) . field ("cc1g" , & self . cc1g ()) . field ("cc2g" , & self . cc2g ()) . field ("cc3g" , & self . cc3g ()) . field ("cc4g" , & self . cc4g ()) . field ("tg" , & self . tg ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Egr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Egr {{ ug: {=bool:?}, cc1g: {=bool:?}, cc2g: {=bool:?}, cc3g: {=bool:?}, cc4g: {=bool:?}, tg: {=bool:?} }}" , self . ug () , self . cc1g () , self . cc2g () , self . cc3g () , self . cc4g () , self . tg ()) } } # [doc = "prescaler"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Psc (pub u32) ; impl Psc { # [doc = "Prescaler value"] # [must_use] # [inline (always)] pub const fn psc (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Prescaler value"] # [inline (always)] pub const fn set_psc (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Psc { # [inline (always)] fn default () -> Psc { Psc (0) } } impl core :: fmt :: Debug for Psc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Psc") . field ("psc" , & self . psc ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Psc { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Psc {{ psc: {=u16:?} }}" , self . psc ()) } } # [doc = "slave mode control register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Smcr (pub u32) ; impl Smcr { # [doc = "Slave mode selection"] # [must_use] # [inline (always)] pub const fn sms (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x07 ; val as u8 } # [doc = "Slave mode selection"] # [inline (always)] pub const fn set_sms (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize) ; } # [doc = "Output compare clear selection"] # [must_use] # [inline (always)] pub const fn occs (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare clear selection"] # [inline (always)] pub const fn set_occs (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Trigger selection"] # [must_use] # [inline (always)] pub const fn ts (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Trigger selection"] # [inline (always)] pub const fn set_ts (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Master/slave mode"] # [must_use] # [inline (always)] pub const fn msm (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Master/slave mode"] # [inline (always)] pub const fn set_msm (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "External trigger filter"] # [must_use] # [inline (always)] pub const fn etf (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "External trigger filter"] # [inline (always)] pub const fn set_etf (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "External trigger prescaler"] # [must_use] # [inline (always)] pub const fn etps (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "External trigger prescaler"] # [inline (always)] pub const fn set_etps (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "External clock enable"] # [must_use] # [inline (always)] pub const fn ece (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "External clock enable"] # [inline (always)] pub const fn set_ece (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "External trigger polarity"] # [must_use] # [inline (always)] pub const fn etp (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "External trigger polarity"] # [inline (always)] pub const fn set_etp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Smcr { # [inline (always)] fn default () -> Smcr { Smcr (0) } } impl core :: fmt :: Debug for Smcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Smcr") . field ("sms" , & self . sms ()) . field ("occs" , & self . occs ()) . field ("ts" , & self . ts ()) . field ("msm" , & self . msm ()) . field ("etf" , & self . etf ()) . field ("etps" , & self . etps ()) . field ("ece" , & self . ece ()) . field ("etp" , & self . etp ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Smcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Smcr {{ sms: {=u8:?}, occs: {=bool:?}, ts: {=u8:?}, msm: {=bool:?}, etf: {=u8:?}, etps: {=u8:?}, ece: {=bool:?}, etp: {=bool:?} }}" , self . sms () , self . occs () , self . ts () , self . msm () , self . etf () , self . etps () , self . ece () , self . etp ()) } } # [doc = "status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "Update interrupt flag"] # [must_use] # [inline (always)] pub const fn uif (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt flag"] # [inline (always)] pub const fn set_uif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc1if (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt flag"] # [inline (always)] pub const fn set_cc1if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 2 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc2if (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 interrupt flag"] # [inline (always)] pub const fn set_cc2if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare 3 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc3if (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 interrupt flag"] # [inline (always)] pub const fn set_cc3if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/Compare 4 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc4if (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 interrupt flag"] # [inline (always)] pub const fn set_cc4if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Trigger interrupt flag"] # [must_use] # [inline (always)] pub const fn tif (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Trigger interrupt flag"] # [inline (always)] pub const fn set_tif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Capture/Compare 1 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc1of (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 overcapture flag"] # [inline (always)] pub const fn set_cc1of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Capture/Compare 2 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc2of (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 overcapture flag"] # [inline (always)] pub const fn set_cc2of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Capture/Compare 3 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc3of (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 overcapture flag"] # [inline (always)] pub const fn set_cc3of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Capture/Compare 4 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc4of (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 overcapture flag"] # [inline (always)] pub const fn set_cc4of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("uif" , & self . uif ()) . field ("cc1if" , & self . cc1if ()) . field ("cc2if" , & self . cc2if ()) . field ("cc3if" , & self . cc3if ()) . field ("cc4if" , & self . cc4if ()) . field ("tif" , & self . tif ()) . field ("cc1of" , & self . cc1of ()) . field ("cc2of" , & self . cc2of ()) . field ("cc3of" , & self . cc3of ()) . field ("cc4of" , & self . cc4of ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ uif: {=bool:?}, cc1if: {=bool:?}, cc2if: {=bool:?}, cc3if: {=bool:?}, cc4if: {=bool:?}, tif: {=bool:?}, cc1of: {=bool:?}, cc2of: {=bool:?}, cc3of: {=bool:?}, cc4of: {=bool:?} }}" , self . uif () , self . cc1if () , self . cc2if () , self . cc3if () , self . cc4if () , self . tif () , self . cc1of () , self . cc2of () , self . cc3of () , self . cc4of ()) } } } } pub mod tim3 { # [doc = "General purpose timer"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Tim3 { ptr : * mut u8 } unsafe impl Send for Tim3 { } unsafe impl Sync for Tim3 { } impl Tim3 { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "control register 1"] # [inline (always)] pub const fn cr1 (self) -> crate :: common :: Reg < regs :: Cr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "control register 2"] # [inline (always)] pub const fn cr2 (self) -> crate :: common :: Reg < regs :: Cr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "slave mode control register 1"] # [inline (always)] pub const fn smcr (self) -> crate :: common :: Reg < regs :: Smcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "DMA/Interrupt enable register"] # [inline (always)] pub const fn dier (self) -> crate :: common :: Reg < regs :: Dier , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "status register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "event generation register"] # [inline (always)] pub const fn egr (self) -> crate :: common :: Reg < regs :: Egr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "capture/compare mode register 1 (input mode)"] # [inline (always)] pub const fn ccmr1_input (self) -> crate :: common :: Reg < regs :: Ccmr1Input , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare mode register 1 (output mode)"] # [inline (always)] pub const fn ccmr1_output (self) -> crate :: common :: Reg < regs :: Ccmr1Output , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "capture/compare mode register 2 (input mode)"] # [inline (always)] pub const fn ccmr2_input (self) -> crate :: common :: Reg < regs :: Ccmr2Input , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "capture/compare mode register 2(output mode)"] # [inline (always)] pub const fn ccmr2_output (self) -> crate :: common :: Reg < regs :: Ccmr2Output , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "capture/compare enable register"] # [inline (always)] pub const fn ccer (self) -> crate :: common :: Reg < regs :: Ccer , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "counter"] # [inline (always)] pub const fn cnt (self) -> crate :: common :: Reg < regs :: Cnt , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "prescaler"] # [inline (always)] pub const fn psc (self) -> crate :: common :: Reg < regs :: Psc , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "auto-reload register"] # [inline (always)] pub const fn arr (self) -> crate :: common :: Reg < regs :: Arr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x2cusize) as _) } } # [doc = "capture/compare register 1"] # [inline (always)] pub const fn ccr1 (self) -> crate :: common :: Reg < regs :: Ccr1 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x34usize) as _) } } # [doc = "capture/compare register 2"] # [inline (always)] pub const fn ccr2 (self) -> crate :: common :: Reg < regs :: Ccr2 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x38usize) as _) } } # [doc = "capture/compare register 3"] # [inline (always)] pub const fn ccr3 (self) -> crate :: common :: Reg < regs :: Ccr3 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x3cusize) as _) } } # [doc = "capture/compare register 4"] # [inline (always)] pub const fn ccr4 (self) -> crate :: common :: Reg < regs :: Ccr4 , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x40usize) as _) } } # [doc = "DMA control register"] # [inline (always)] pub const fn dcr (self) -> crate :: common :: Reg < regs :: Dcr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x48usize) as _) } } # [doc = "DMA address for full transfer"] # [inline (always)] pub const fn dmar (self) -> crate :: common :: Reg < regs :: Dmar , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x4cusize) as _) } } } pub mod regs { # [doc = "auto-reload register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Arr (pub u32) ; impl Arr { # [doc = "Auto reload value"] # [must_use] # [inline (always)] pub const fn arr (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Auto reload value"] # [inline (always)] pub const fn set_arr (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Arr { # [inline (always)] fn default () -> Arr { Arr (0) } } impl core :: fmt :: Debug for Arr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Arr") . field ("arr" , & self . arr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Arr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Arr {{ arr: {=u16:?} }}" , self . arr ()) } } # [doc = "capture/compare enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccer (pub u32) ; impl Ccer { # [doc = "Capture/Compare 1 output enable"] # [must_use] # [inline (always)] pub const fn cc1e (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output enable"] # [inline (always)] pub const fn set_cc1e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 output polarity"] # [must_use] # [inline (always)] pub const fn cc1p (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 output polarity"] # [inline (always)] pub const fn set_cc1p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 2 output enable"] # [must_use] # [inline (always)] pub const fn cc2e (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 output enable"] # [inline (always)] pub const fn set_cc2e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Capture/Compare 2 output polarity"] # [must_use] # [inline (always)] pub const fn cc2p (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 output polarity"] # [inline (always)] pub const fn set_cc2p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Capture/Compare 3 output enable"] # [must_use] # [inline (always)] pub const fn cc3e (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 output enable"] # [inline (always)] pub const fn set_cc3e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Capture/Compare 3 output polarity"] # [must_use] # [inline (always)] pub const fn cc3p (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 output polarity"] # [inline (always)] pub const fn set_cc3p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Capture/Compare 4 output enable"] # [must_use] # [inline (always)] pub const fn cc4e (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 output enable"] # [inline (always)] pub const fn set_cc4e (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Capture/Compare 4 output polarity"] # [must_use] # [inline (always)] pub const fn cc4p (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 output polarity"] # [inline (always)] pub const fn set_cc4p (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } } impl Default for Ccer { # [inline (always)] fn default () -> Ccer { Ccer (0) } } impl core :: fmt :: Debug for Ccer { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccer") . field ("cc1e" , & self . cc1e ()) . field ("cc1p" , & self . cc1p ()) . field ("cc2e" , & self . cc2e ()) . field ("cc2p" , & self . cc2p ()) . field ("cc3e" , & self . cc3e ()) . field ("cc3p" , & self . cc3p ()) . field ("cc4e" , & self . cc4e ()) . field ("cc4p" , & self . cc4p ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccer { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccer {{ cc1e: {=bool:?}, cc1p: {=bool:?}, cc2e: {=bool:?}, cc2p: {=bool:?}, cc3e: {=bool:?}, cc3p: {=bool:?}, cc4e: {=bool:?}, cc4p: {=bool:?} }}" , self . cc1e () , self . cc1p () , self . cc2e () , self . cc2p () , self . cc3e () , self . cc3p () , self . cc4e () , self . cc4p ()) } } # [doc = "capture/compare mode register 1 (input mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Input (pub u32) ; impl Ccmr1Input { # [doc = "Capture/compare 1 selection"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/compare 1 selection"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Input capture 1 prescaler"] # [must_use] # [inline (always)] pub const fn ic1psc (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Input capture 1 prescaler"] # [inline (always)] pub const fn set_ic1psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Input capture 1 filter"] # [must_use] # [inline (always)] pub const fn ic1f (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Input capture 1 filter"] # [inline (always)] pub const fn set_ic1f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Capture/Compare 2 selection"] # [must_use] # [inline (always)] pub const fn cc2s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 2 selection"] # [inline (always)] pub const fn set_cc2s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Input capture 2 prescaler"] # [must_use] # [inline (always)] pub const fn ic2psc (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Input capture 2 prescaler"] # [inline (always)] pub const fn set_ic2psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Input capture 2 filter"] # [must_use] # [inline (always)] pub const fn ic2f (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "Input capture 2 filter"] # [inline (always)] pub const fn set_ic2f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Ccmr1Input { # [inline (always)] fn default () -> Ccmr1Input { Ccmr1Input (0) } } impl core :: fmt :: Debug for Ccmr1Input { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Input") . field ("cc1s" , & self . cc1s ()) . field ("ic1psc" , & self . ic1psc ()) . field ("ic1f" , & self . ic1f ()) . field ("cc2s" , & self . cc2s ()) . field ("ic2psc" , & self . ic2psc ()) . field ("ic2f" , & self . ic2f ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Input { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Input {{ cc1s: {=u8:?}, ic1psc: {=u8:?}, ic1f: {=u8:?}, cc2s: {=u8:?}, ic2psc: {=u8:?}, ic2f: {=u8:?} }}" , self . cc1s () , self . ic1psc () , self . ic1f () , self . cc2s () , self . ic2psc () , self . ic2f ()) } } # [doc = "capture/compare mode register 1 (output mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr1Output (pub u32) ; impl Ccmr1Output { # [doc = "Capture/Compare 2 output enable"] # [must_use] # [inline (always)] pub const fn cc1s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 2 output enable"] # [inline (always)] pub const fn set_cc1s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Output compare 1 fast enable"] # [must_use] # [inline (always)] pub const fn oc1fe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 fast enable"] # [inline (always)] pub const fn set_oc1fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Output compare 1 preload enable"] # [must_use] # [inline (always)] pub const fn oc1pe (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 preload enable"] # [inline (always)] pub const fn set_oc1pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output compare 1 mode"] # [must_use] # [inline (always)] pub const fn oc1m (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Output compare 1 mode"] # [inline (always)] pub const fn set_oc1m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Output compare 1 clear enable"] # [must_use] # [inline (always)] pub const fn oc1ce (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Output compare 1 clear enable"] # [inline (always)] pub const fn set_oc1ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capure/Compare 2 selection"] # [must_use] # [inline (always)] pub const fn cc2s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capure/Compare 2 selection"] # [inline (always)] pub const fn set_cc2s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Output compare 4 fast enable"] # [must_use] # [inline (always)] pub const fn oc2fe (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 fast enable"] # [inline (always)] pub const fn set_oc2fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Output compare 2 preload enable"] # [must_use] # [inline (always)] pub const fn oc2pe (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Output compare 2 preload enable"] # [inline (always)] pub const fn set_oc2pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Output compare 2 mode"] # [must_use] # [inline (always)] pub const fn oc2m (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x07 ; val as u8 } # [doc = "Output compare 2 mode"] # [inline (always)] pub const fn set_oc2m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize) ; } # [doc = "Output compare 2 clear enable"] # [must_use] # [inline (always)] pub const fn oc2ce (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Output compare 2 clear enable"] # [inline (always)] pub const fn set_oc2ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccmr1Output { # [inline (always)] fn default () -> Ccmr1Output { Ccmr1Output (0) } } impl core :: fmt :: Debug for Ccmr1Output { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr1Output") . field ("cc1s" , & self . cc1s ()) . field ("oc1fe" , & self . oc1fe ()) . field ("oc1pe" , & self . oc1pe ()) . field ("oc1m" , & self . oc1m ()) . field ("oc1ce" , & self . oc1ce ()) . field ("cc2s" , & self . cc2s ()) . field ("oc2fe" , & self . oc2fe ()) . field ("oc2pe" , & self . oc2pe ()) . field ("oc2m" , & self . oc2m ()) . field ("oc2ce" , & self . oc2ce ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr1Output { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr1Output {{ cc1s: {=u8:?}, oc1fe: {=bool:?}, oc1pe: {=bool:?}, oc1m: {=u8:?}, oc1ce: {=bool:?}, cc2s: {=u8:?}, oc2fe: {=bool:?}, oc2pe: {=bool:?}, oc2m: {=u8:?}, oc2ce: {=bool:?} }}" , self . cc1s () , self . oc1fe () , self . oc1pe () , self . oc1m () , self . oc1ce () , self . cc2s () , self . oc2fe () , self . oc2pe () , self . oc2m () , self . oc2ce ()) } } # [doc = "capture/compare mode register 2 (input mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr2Input (pub u32) ; impl Ccmr2Input { # [doc = "Capture/compare 3 selection"] # [must_use] # [inline (always)] pub const fn cc3s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/compare 3 selection"] # [inline (always)] pub const fn set_cc3s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Input capture 3 prescaler"] # [must_use] # [inline (always)] pub const fn ic3psc (& self) -> u8 { let val = (self . 0 >> 2usize) & 0x03 ; val as u8 } # [doc = "Input capture 3 prescaler"] # [inline (always)] pub const fn set_ic3psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 2usize)) | (((val as u32) & 0x03) << 2usize) ; } # [doc = "Input capture 3 filter"] # [must_use] # [inline (always)] pub const fn ic3f (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x0f ; val as u8 } # [doc = "Input capture 3 filter"] # [inline (always)] pub const fn set_ic3f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize) ; } # [doc = "Capture/Compare 4 selection"] # [must_use] # [inline (always)] pub const fn cc4s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 4 selection"] # [inline (always)] pub const fn set_cc4s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Input capture 4 prescaler"] # [must_use] # [inline (always)] pub const fn ic4psc (& self) -> u8 { let val = (self . 0 >> 10usize) & 0x03 ; val as u8 } # [doc = "Input capture 4 prescaler"] # [inline (always)] pub const fn set_ic4psc (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 10usize)) | (((val as u32) & 0x03) << 10usize) ; } # [doc = "Input capture 4 filter"] # [must_use] # [inline (always)] pub const fn ic4f (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x0f ; val as u8 } # [doc = "Input capture 4 filter"] # [inline (always)] pub const fn set_ic4f (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize) ; } } impl Default for Ccmr2Input { # [inline (always)] fn default () -> Ccmr2Input { Ccmr2Input (0) } } impl core :: fmt :: Debug for Ccmr2Input { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr2Input") . field ("cc3s" , & self . cc3s ()) . field ("ic3psc" , & self . ic3psc ()) . field ("ic3f" , & self . ic3f ()) . field ("cc4s" , & self . cc4s ()) . field ("ic4psc" , & self . ic4psc ()) . field ("ic4f" , & self . ic4f ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr2Input { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr2Input {{ cc3s: {=u8:?}, ic3psc: {=u8:?}, ic3f: {=u8:?}, cc4s: {=u8:?}, ic4psc: {=u8:?}, ic4f: {=u8:?} }}" , self . cc3s () , self . ic3psc () , self . ic3f () , self . cc4s () , self . ic4psc () , self . ic4f ()) } } # [doc = "capture/compare mode register 2(output mode)"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccmr2Output (pub u32) ; impl Ccmr2Output { # [doc = "Capture/Compare 3 selection"] # [must_use] # [inline (always)] pub const fn cc3s (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 3 selection"] # [inline (always)] pub const fn set_cc3s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize) ; } # [doc = "Output compare 3 fast enable"] # [must_use] # [inline (always)] pub const fn oc3fe (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Output compare 3 fast enable"] # [inline (always)] pub const fn set_oc3fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Output compare 3 preload enable"] # [must_use] # [inline (always)] pub const fn oc3pe (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare 3 preload enable"] # [inline (always)] pub const fn set_oc3pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Output compare 3 mode"] # [must_use] # [inline (always)] pub const fn oc3m (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Output compare 3 mode"] # [inline (always)] pub const fn set_oc3m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Output compare 3 clear enable"] # [must_use] # [inline (always)] pub const fn oc3ce (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Output compare 3 clear enable"] # [inline (always)] pub const fn set_oc3ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Capture/Compare 4 selection"] # [must_use] # [inline (always)] pub const fn cc4s (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Capture/Compare 4 selection"] # [inline (always)] pub const fn set_cc4s (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } # [doc = "Output compare 4 fast enable"] # [must_use] # [inline (always)] pub const fn oc4fe (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 fast enable"] # [inline (always)] pub const fn set_oc4fe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Output compare 4 preload enable"] # [must_use] # [inline (always)] pub const fn oc4pe (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 preload enable"] # [inline (always)] pub const fn set_oc4pe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Output compare 4 mode"] # [must_use] # [inline (always)] pub const fn oc4m (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x07 ; val as u8 } # [doc = "Output compare 4 mode"] # [inline (always)] pub const fn set_oc4m (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 12usize)) | (((val as u32) & 0x07) << 12usize) ; } # [doc = "Output compare 4 clear enable"] # [must_use] # [inline (always)] pub const fn oc4ce (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "Output compare 4 clear enable"] # [inline (always)] pub const fn set_oc4ce (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Ccmr2Output { # [inline (always)] fn default () -> Ccmr2Output { Ccmr2Output (0) } } impl core :: fmt :: Debug for Ccmr2Output { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccmr2Output") . field ("cc3s" , & self . cc3s ()) . field ("oc3fe" , & self . oc3fe ()) . field ("oc3pe" , & self . oc3pe ()) . field ("oc3m" , & self . oc3m ()) . field ("oc3ce" , & self . oc3ce ()) . field ("cc4s" , & self . cc4s ()) . field ("oc4fe" , & self . oc4fe ()) . field ("oc4pe" , & self . oc4pe ()) . field ("oc4m" , & self . oc4m ()) . field ("oc4ce" , & self . oc4ce ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccmr2Output { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccmr2Output {{ cc3s: {=u8:?}, oc3fe: {=bool:?}, oc3pe: {=bool:?}, oc3m: {=u8:?}, oc3ce: {=bool:?}, cc4s: {=u8:?}, oc4fe: {=bool:?}, oc4pe: {=bool:?}, oc4m: {=u8:?}, oc4ce: {=bool:?} }}" , self . cc3s () , self . oc3fe () , self . oc3pe () , self . oc3m () , self . oc3ce () , self . cc4s () , self . oc4fe () , self . oc4pe () , self . oc4m () , self . oc4ce ()) } } # [doc = "capture/compare register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr1 (pub u32) ; impl Ccr1 { # [doc = "Capture/Compare 1 value"] # [must_use] # [inline (always)] pub const fn ccr1 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 1 value"] # [inline (always)] pub const fn set_ccr1 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr1 { # [inline (always)] fn default () -> Ccr1 { Ccr1 (0) } } impl core :: fmt :: Debug for Ccr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr1") . field ("ccr1" , & self . ccr1 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr1 {{ ccr1: {=u16:?} }}" , self . ccr1 ()) } } # [doc = "capture/compare register 2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr2 (pub u32) ; impl Ccr2 { # [doc = "Capture/Compare 2 value"] # [must_use] # [inline (always)] pub const fn ccr2 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 2 value"] # [inline (always)] pub const fn set_ccr2 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr2 { # [inline (always)] fn default () -> Ccr2 { Ccr2 (0) } } impl core :: fmt :: Debug for Ccr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr2") . field ("ccr2" , & self . ccr2 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr2 {{ ccr2: {=u16:?} }}" , self . ccr2 ()) } } # [doc = "capture/compare register 3"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr3 (pub u32) ; impl Ccr3 { # [doc = "Capture/Compare 3 value"] # [must_use] # [inline (always)] pub const fn ccr3 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 3 value"] # [inline (always)] pub const fn set_ccr3 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr3 { # [inline (always)] fn default () -> Ccr3 { Ccr3 (0) } } impl core :: fmt :: Debug for Ccr3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr3") . field ("ccr3" , & self . ccr3 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr3 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr3 {{ ccr3: {=u16:?} }}" , self . ccr3 ()) } } # [doc = "capture/compare register 4"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr4 (pub u32) ; impl Ccr4 { # [doc = "Capture/Compare 4 value"] # [must_use] # [inline (always)] pub const fn ccr4 (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Capture/Compare 4 value"] # [inline (always)] pub const fn set_ccr4 (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Ccr4 { # [inline (always)] fn default () -> Ccr4 { Ccr4 (0) } } impl core :: fmt :: Debug for Ccr4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr4") . field ("ccr4" , & self . ccr4 ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr4 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr4 {{ ccr4: {=u16:?} }}" , self . ccr4 ()) } } # [doc = "counter"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cnt (pub u32) ; impl Cnt { # [doc = "Counter value"] # [must_use] # [inline (always)] pub const fn cnt (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Counter value"] # [inline (always)] pub const fn set_cnt (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Cnt { # [inline (always)] fn default () -> Cnt { Cnt (0) } } impl core :: fmt :: Debug for Cnt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cnt") . field ("cnt" , & self . cnt ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cnt { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cnt {{ cnt: {=u16:?} }}" , self . cnt ()) } } # [doc = "control register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr1 (pub u32) ; impl Cr1 { # [doc = "Counter enable"] # [must_use] # [inline (always)] pub const fn cen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Counter enable"] # [inline (always)] pub const fn set_cen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Update disable"] # [must_use] # [inline (always)] pub const fn udis (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Update disable"] # [inline (always)] pub const fn set_udis (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Update request source"] # [must_use] # [inline (always)] pub const fn urs (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Update request source"] # [inline (always)] pub const fn set_urs (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "One pulse mode"] # [must_use] # [inline (always)] pub const fn opm (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "One pulse mode"] # [inline (always)] pub const fn set_opm (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Direction"] # [must_use] # [inline (always)] pub const fn dir (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Direction"] # [inline (always)] pub const fn set_dir (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Center-aligned mode selection"] # [must_use] # [inline (always)] pub const fn cms (& self) -> u8 { let val = (self . 0 >> 5usize) & 0x03 ; val as u8 } # [doc = "Center-aligned mode selection"] # [inline (always)] pub const fn set_cms (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize) ; } # [doc = "Auto-reload preload enable"] # [must_use] # [inline (always)] pub const fn arpe (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Auto-reload preload enable"] # [inline (always)] pub const fn set_arpe (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Clock division"] # [must_use] # [inline (always)] pub const fn ckd (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x03 ; val as u8 } # [doc = "Clock division"] # [inline (always)] pub const fn set_ckd (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 8usize)) | (((val as u32) & 0x03) << 8usize) ; } } impl Default for Cr1 { # [inline (always)] fn default () -> Cr1 { Cr1 (0) } } impl core :: fmt :: Debug for Cr1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr1") . field ("cen" , & self . cen ()) . field ("udis" , & self . udis ()) . field ("urs" , & self . urs ()) . field ("opm" , & self . opm ()) . field ("dir" , & self . dir ()) . field ("cms" , & self . cms ()) . field ("arpe" , & self . arpe ()) . field ("ckd" , & self . ckd ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr1 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr1 {{ cen: {=bool:?}, udis: {=bool:?}, urs: {=bool:?}, opm: {=bool:?}, dir: {=bool:?}, cms: {=u8:?}, arpe: {=bool:?}, ckd: {=u8:?} }}" , self . cen () , self . udis () , self . urs () , self . opm () , self . dir () , self . cms () , self . arpe () , self . ckd ()) } } # [doc = "control register 2"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr2 (pub u32) ; impl Cr2 { # [doc = "Capture/Compare DMA selection"] # [must_use] # [inline (always)] pub const fn ccds (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare DMA selection"] # [inline (always)] pub const fn set_ccds (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Master mode selection"] # [must_use] # [inline (always)] pub const fn mms (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Master mode selection"] # [inline (always)] pub const fn set_mms (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "TI1 selection"] # [must_use] # [inline (always)] pub const fn ti1s (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "TI1 selection"] # [inline (always)] pub const fn set_ti1s (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } } impl Default for Cr2 { # [inline (always)] fn default () -> Cr2 { Cr2 (0) } } impl core :: fmt :: Debug for Cr2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr2") . field ("ccds" , & self . ccds ()) . field ("mms" , & self . mms ()) . field ("ti1s" , & self . ti1s ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr2 { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr2 {{ ccds: {=bool:?}, mms: {=u8:?}, ti1s: {=bool:?} }}" , self . ccds () , self . mms () , self . ti1s ()) } } # [doc = "DMA control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dcr (pub u32) ; impl Dcr { # [doc = "DMA base address"] # [must_use] # [inline (always)] pub const fn dba (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x1f ; val as u8 } # [doc = "DMA base address"] # [inline (always)] pub const fn set_dba (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize) ; } # [doc = "DMA burst length"] # [must_use] # [inline (always)] pub const fn dbl (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x1f ; val as u8 } # [doc = "DMA burst length"] # [inline (always)] pub const fn set_dbl (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x1f << 8usize)) | (((val as u32) & 0x1f) << 8usize) ; } } impl Default for Dcr { # [inline (always)] fn default () -> Dcr { Dcr (0) } } impl core :: fmt :: Debug for Dcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dcr") . field ("dba" , & self . dba ()) . field ("dbl" , & self . dbl ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dcr {{ dba: {=u8:?}, dbl: {=u8:?} }}" , self . dba () , self . dbl ()) } } # [doc = "DMA/Interrupt enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dier (pub u32) ; impl Dier { # [doc = "Update interrupt enable"] # [must_use] # [inline (always)] pub const fn uie (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt enable"] # [inline (always)] pub const fn set_uie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc1ie (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt enable"] # [inline (always)] pub const fn set_cc1ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 2 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc2ie (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 interrupt enable"] # [inline (always)] pub const fn set_cc2ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare 3 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc3ie (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 interrupt enable"] # [inline (always)] pub const fn set_cc3ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/Compare 4 interrupt enable"] # [must_use] # [inline (always)] pub const fn cc4ie (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 interrupt enable"] # [inline (always)] pub const fn set_cc4ie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Trigger interrupt enable"] # [must_use] # [inline (always)] pub const fn tie (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Trigger interrupt enable"] # [inline (always)] pub const fn set_tie (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Update DMA request enable"] # [must_use] # [inline (always)] pub const fn ude (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Update DMA request enable"] # [inline (always)] pub const fn set_ude (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Capture/Compare 1 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc1de (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 DMA request enable"] # [inline (always)] pub const fn set_cc1de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Capture/Compare 2 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc2de (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 DMA request enable"] # [inline (always)] pub const fn set_cc2de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Capture/Compare 3 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc3de (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 DMA request enable"] # [inline (always)] pub const fn set_cc3de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Capture/Compare 4 DMA request enable"] # [must_use] # [inline (always)] pub const fn cc4de (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 DMA request enable"] # [inline (always)] pub const fn set_cc4de (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Trigger DMA request enable"] # [must_use] # [inline (always)] pub const fn tde (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "Trigger DMA request enable"] # [inline (always)] pub const fn set_tde (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } } impl Default for Dier { # [inline (always)] fn default () -> Dier { Dier (0) } } impl core :: fmt :: Debug for Dier { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dier") . field ("uie" , & self . uie ()) . field ("cc1ie" , & self . cc1ie ()) . field ("cc2ie" , & self . cc2ie ()) . field ("cc3ie" , & self . cc3ie ()) . field ("cc4ie" , & self . cc4ie ()) . field ("tie" , & self . tie ()) . field ("ude" , & self . ude ()) . field ("cc1de" , & self . cc1de ()) . field ("cc2de" , & self . cc2de ()) . field ("cc3de" , & self . cc3de ()) . field ("cc4de" , & self . cc4de ()) . field ("tde" , & self . tde ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dier { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dier {{ uie: {=bool:?}, cc1ie: {=bool:?}, cc2ie: {=bool:?}, cc3ie: {=bool:?}, cc4ie: {=bool:?}, tie: {=bool:?}, ude: {=bool:?}, cc1de: {=bool:?}, cc2de: {=bool:?}, cc3de: {=bool:?}, cc4de: {=bool:?}, tde: {=bool:?} }}" , self . uie () , self . cc1ie () , self . cc2ie () , self . cc3ie () , self . cc4ie () , self . tie () , self . ude () , self . cc1de () , self . cc2de () , self . cc3de () , self . cc4de () , self . tde ()) } } # [doc = "DMA address for full transfer"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Dmar (pub u32) ; impl Dmar { # [doc = "DMA register for burst accesses"] # [must_use] # [inline (always)] pub const fn dmab (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "DMA register for burst accesses"] # [inline (always)] pub const fn set_dmab (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Dmar { # [inline (always)] fn default () -> Dmar { Dmar (0) } } impl core :: fmt :: Debug for Dmar { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dmar") . field ("dmab" , & self . dmab ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Dmar { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Dmar {{ dmab: {=u16:?} }}" , self . dmab ()) } } # [doc = "event generation register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Egr (pub u32) ; impl Egr { # [doc = "Update generation"] # [must_use] # [inline (always)] pub const fn ug (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update generation"] # [inline (always)] pub const fn set_ug (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/compare 1 generation"] # [must_use] # [inline (always)] pub const fn cc1g (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/compare 1 generation"] # [inline (always)] pub const fn set_cc1g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/compare 2 generation"] # [must_use] # [inline (always)] pub const fn cc2g (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/compare 2 generation"] # [inline (always)] pub const fn set_cc2g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/compare 3 generation"] # [must_use] # [inline (always)] pub const fn cc3g (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/compare 3 generation"] # [inline (always)] pub const fn set_cc3g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/compare 4 generation"] # [must_use] # [inline (always)] pub const fn cc4g (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/compare 4 generation"] # [inline (always)] pub const fn set_cc4g (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Trigger generation"] # [must_use] # [inline (always)] pub const fn tg (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Trigger generation"] # [inline (always)] pub const fn set_tg (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } } impl Default for Egr { # [inline (always)] fn default () -> Egr { Egr (0) } } impl core :: fmt :: Debug for Egr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Egr") . field ("ug" , & self . ug ()) . field ("cc1g" , & self . cc1g ()) . field ("cc2g" , & self . cc2g ()) . field ("cc3g" , & self . cc3g ()) . field ("cc4g" , & self . cc4g ()) . field ("tg" , & self . tg ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Egr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Egr {{ ug: {=bool:?}, cc1g: {=bool:?}, cc2g: {=bool:?}, cc3g: {=bool:?}, cc4g: {=bool:?}, tg: {=bool:?} }}" , self . ug () , self . cc1g () , self . cc2g () , self . cc3g () , self . cc4g () , self . tg ()) } } # [doc = "prescaler"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Psc (pub u32) ; impl Psc { # [doc = "Prescaler value"] # [must_use] # [inline (always)] pub const fn psc (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Prescaler value"] # [inline (always)] pub const fn set_psc (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Psc { # [inline (always)] fn default () -> Psc { Psc (0) } } impl core :: fmt :: Debug for Psc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Psc") . field ("psc" , & self . psc ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Psc { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Psc {{ psc: {=u16:?} }}" , self . psc ()) } } # [doc = "slave mode control register 1"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Smcr (pub u32) ; impl Smcr { # [doc = "Slave mode selection"] # [must_use] # [inline (always)] pub const fn sms (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x07 ; val as u8 } # [doc = "Slave mode selection"] # [inline (always)] pub const fn set_sms (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize) ; } # [doc = "Output compare clear selection"] # [must_use] # [inline (always)] pub const fn occs (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Output compare clear selection"] # [inline (always)] pub const fn set_occs (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Trigger selection"] # [must_use] # [inline (always)] pub const fn ts (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x07 ; val as u8 } # [doc = "Trigger selection"] # [inline (always)] pub const fn set_ts (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x07 << 4usize)) | (((val as u32) & 0x07) << 4usize) ; } # [doc = "Master/slave mode"] # [must_use] # [inline (always)] pub const fn msm (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Master/slave mode"] # [inline (always)] pub const fn set_msm (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "External trigger filter"] # [must_use] # [inline (always)] pub const fn etf (& self) -> u8 { let val = (self . 0 >> 8usize) & 0x0f ; val as u8 } # [doc = "External trigger filter"] # [inline (always)] pub const fn set_etf (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize) ; } # [doc = "External trigger prescaler"] # [must_use] # [inline (always)] pub const fn etps (& self) -> u8 { let val = (self . 0 >> 12usize) & 0x03 ; val as u8 } # [doc = "External trigger prescaler"] # [inline (always)] pub const fn set_etps (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 12usize)) | (((val as u32) & 0x03) << 12usize) ; } # [doc = "External clock enable"] # [must_use] # [inline (always)] pub const fn ece (& self) -> bool { let val = (self . 0 >> 14usize) & 0x01 ; val != 0 } # [doc = "External clock enable"] # [inline (always)] pub const fn set_ece (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize) ; } # [doc = "External trigger polarity"] # [must_use] # [inline (always)] pub const fn etp (& self) -> bool { let val = (self . 0 >> 15usize) & 0x01 ; val != 0 } # [doc = "External trigger polarity"] # [inline (always)] pub const fn set_etp (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize) ; } } impl Default for Smcr { # [inline (always)] fn default () -> Smcr { Smcr (0) } } impl core :: fmt :: Debug for Smcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Smcr") . field ("sms" , & self . sms ()) . field ("occs" , & self . occs ()) . field ("ts" , & self . ts ()) . field ("msm" , & self . msm ()) . field ("etf" , & self . etf ()) . field ("etps" , & self . etps ()) . field ("ece" , & self . ece ()) . field ("etp" , & self . etp ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Smcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Smcr {{ sms: {=u8:?}, occs: {=bool:?}, ts: {=u8:?}, msm: {=bool:?}, etf: {=u8:?}, etps: {=u8:?}, ece: {=bool:?}, etp: {=bool:?} }}" , self . sms () , self . occs () , self . ts () , self . msm () , self . etf () , self . etps () , self . ece () , self . etp ()) } } # [doc = "status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "Update interrupt flag"] # [must_use] # [inline (always)] pub const fn uif (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Update interrupt flag"] # [inline (always)] pub const fn set_uif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Capture/Compare 1 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc1if (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 interrupt flag"] # [inline (always)] pub const fn set_cc1if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Capture/Compare 2 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc2if (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 interrupt flag"] # [inline (always)] pub const fn set_cc2if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Capture/Compare 3 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc3if (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 interrupt flag"] # [inline (always)] pub const fn set_cc3if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Capture/Compare 4 interrupt flag"] # [must_use] # [inline (always)] pub const fn cc4if (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 interrupt flag"] # [inline (always)] pub const fn set_cc4if (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Trigger interrupt flag"] # [must_use] # [inline (always)] pub const fn tif (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Trigger interrupt flag"] # [inline (always)] pub const fn set_tif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Capture/Compare 1 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc1of (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 1 overcapture flag"] # [inline (always)] pub const fn set_cc1of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Capture/Compare 2 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc2of (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 2 overcapture flag"] # [inline (always)] pub const fn set_cc2of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Capture/Compare 3 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc3of (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 3 overcapture flag"] # [inline (always)] pub const fn set_cc3of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Capture/Compare 4 overcapture flag"] # [must_use] # [inline (always)] pub const fn cc4of (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Capture/Compare 4 overcapture flag"] # [inline (always)] pub const fn set_cc4of (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("uif" , & self . uif ()) . field ("cc1if" , & self . cc1if ()) . field ("cc2if" , & self . cc2if ()) . field ("cc3if" , & self . cc3if ()) . field ("cc4if" , & self . cc4if ()) . field ("tif" , & self . tif ()) . field ("cc1of" , & self . cc1of ()) . field ("cc2of" , & self . cc2of ()) . field ("cc3of" , & self . cc3of ()) . field ("cc4of" , & self . cc4of ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ uif: {=bool:?}, cc1if: {=bool:?}, cc2if: {=bool:?}, cc3if: {=bool:?}, cc4if: {=bool:?}, tif: {=bool:?}, cc1of: {=bool:?}, cc2of: {=bool:?}, cc3of: {=bool:?}, cc4of: {=bool:?} }}" , self . uif () , self . cc1if () , self . cc2if () , self . cc3if () , self . cc4if () , self . tif () , self . cc1of () , self . cc2of () , self . cc3of () , self . cc4of ()) } } } } pub mod uart1 { # [doc = "Universal asynchronous receiver transmitter"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Uart1 { ptr : * mut u8 } unsafe impl Send for Uart1 { } unsafe impl Sync for Uart1 { } impl Uart1 { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Transmit data register"] # [inline (always)] pub const fn tdr (self) -> crate :: common :: Reg < regs :: Tdr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Receive data register"] # [inline (always)] pub const fn rdr (self) -> crate :: common :: Reg < regs :: Rdr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Current status register"] # [inline (always)] pub const fn csr (self) -> crate :: common :: Reg < regs :: Csr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } # [doc = "Interrupt status register"] # [inline (always)] pub const fn isr (self) -> crate :: common :: Reg < regs :: Isr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0cusize) as _) } } # [doc = "Interrupt enable register"] # [inline (always)] pub const fn ier (self) -> crate :: common :: Reg < regs :: Ier , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x10usize) as _) } } # [doc = "ICR"] # [inline (always)] pub const fn icr (self) -> crate :: common :: Reg < regs :: Icr , crate :: common :: W > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x14usize) as _) } } # [doc = "Global control register"] # [inline (always)] pub const fn gcr (self) -> crate :: common :: Reg < regs :: Gcr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x18usize) as _) } } # [doc = "common control register"] # [inline (always)] pub const fn ccr (self) -> crate :: common :: Reg < regs :: Ccr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x1cusize) as _) } } # [doc = "Baud rate register"] # [inline (always)] pub const fn brr (self) -> crate :: common :: Reg < regs :: Brr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x20usize) as _) } } # [doc = "Fractional baud rate register"] # [inline (always)] pub const fn fra (self) -> crate :: common :: Reg < regs :: Fra , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x24usize) as _) } } # [doc = "RXADDR"] # [inline (always)] pub const fn rxaddr (self) -> crate :: common :: Reg < regs :: Rxaddr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x28usize) as _) } } # [doc = "RXMASK"] # [inline (always)] pub const fn rxmask (self) -> crate :: common :: Reg < regs :: Rxmask , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x2cusize) as _) } } # [doc = "SCR"] # [inline (always)] pub const fn scr (self) -> crate :: common :: Reg < regs :: Scr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x30usize) as _) } } } pub mod regs { # [doc = "Baud rate register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Brr (pub u32) ; impl Brr { # [doc = "Mantissa part of UARTDIV"] # [must_use] # [inline (always)] pub const fn div_mantissa (& self) -> u16 { let val = (self . 0 >> 0usize) & 0xffff ; val as u16 } # [doc = "Mantissa part of UARTDIV"] # [inline (always)] pub const fn set_div_mantissa (& mut self , val : u16) { self . 0 = (self . 0 & ! (0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize) ; } } impl Default for Brr { # [inline (always)] fn default () -> Brr { Brr (0) } } impl core :: fmt :: Debug for Brr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Brr") . field ("div_mantissa" , & self . div_mantissa ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Brr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Brr {{ div_mantissa: {=u16:?} }}" , self . div_mantissa ()) } } # [doc = "common control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ccr (pub u32) ; impl Ccr { # [doc = "Parity enable bit"] # [must_use] # [inline (always)] pub const fn pen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Parity enable bit"] # [inline (always)] pub const fn set_pen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Parity selection bit"] # [must_use] # [inline (always)] pub const fn psel (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Parity selection bit"] # [inline (always)] pub const fn set_psel (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Stop bit 0 selection"] # [must_use] # [inline (always)] pub const fn spb0 (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Stop bit 0 selection"] # [inline (always)] pub const fn set_spb0 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "UART transmit frame break"] # [must_use] # [inline (always)] pub const fn brk (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "UART transmit frame break"] # [inline (always)] pub const fn set_brk (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "UART width bit"] # [must_use] # [inline (always)] pub const fn char (& self) -> u8 { let val = (self . 0 >> 4usize) & 0x03 ; val as u8 } # [doc = "UART width bit"] # [inline (always)] pub const fn set_char (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 4usize)) | (((val as u32) & 0x03) << 4usize) ; } # [doc = "Stop bit 1 selection bit"] # [must_use] # [inline (always)] pub const fn spb1 (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Stop bit 1 selection bit"] # [inline (always)] pub const fn set_spb1 (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Synchronous frame receive"] # [must_use] # [inline (always)] pub const fn b8rxd (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Synchronous frame receive"] # [inline (always)] pub const fn set_b8rxd (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Synchronous frame transmit"] # [must_use] # [inline (always)] pub const fn b8txd (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Synchronous frame transmit"] # [inline (always)] pub const fn set_b8txd (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } # [doc = "Synchronous frame polarity control bit"] # [must_use] # [inline (always)] pub const fn b8pol (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Synchronous frame polarity control bit"] # [inline (always)] pub const fn set_b8pol (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } # [doc = "Synchronous frame auto toggle bit"] # [must_use] # [inline (always)] pub const fn b8tog (& self) -> bool { let val = (self . 0 >> 10usize) & 0x01 ; val != 0 } # [doc = "Synchronous frame auto toggle bit"] # [inline (always)] pub const fn set_b8tog (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize) ; } # [doc = "Synchronous frame enable bit"] # [must_use] # [inline (always)] pub const fn b8en (& self) -> bool { let val = (self . 0 >> 11usize) & 0x01 ; val != 0 } # [doc = "Synchronous frame enable bit"] # [inline (always)] pub const fn set_b8en (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize) ; } # [doc = "Receive wake up method"] # [must_use] # [inline (always)] pub const fn rwu (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Receive wake up method"] # [inline (always)] pub const fn set_rwu (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } # [doc = "Wake up method"] # [must_use] # [inline (always)] pub const fn wake (& self) -> bool { let val = (self . 0 >> 13usize) & 0x01 ; val != 0 } # [doc = "Wake up method"] # [inline (always)] pub const fn set_wake (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize) ; } } impl Default for Ccr { # [inline (always)] fn default () -> Ccr { Ccr (0) } } impl core :: fmt :: Debug for Ccr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccr") . field ("pen" , & self . pen ()) . field ("psel" , & self . psel ()) . field ("spb0" , & self . spb0 ()) . field ("brk" , & self . brk ()) . field ("char" , & self . char ()) . field ("spb1" , & self . spb1 ()) . field ("b8rxd" , & self . b8rxd ()) . field ("b8txd" , & self . b8txd ()) . field ("b8pol" , & self . b8pol ()) . field ("b8tog" , & self . b8tog ()) . field ("b8en" , & self . b8en ()) . field ("rwu" , & self . rwu ()) . field ("wake" , & self . wake ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ccr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ccr {{ pen: {=bool:?}, psel: {=bool:?}, spb0: {=bool:?}, brk: {=bool:?}, char: {=u8:?}, spb1: {=bool:?}, b8rxd: {=bool:?}, b8txd: {=bool:?}, b8pol: {=bool:?}, b8tog: {=bool:?}, b8en: {=bool:?}, rwu: {=bool:?}, wake: {=bool:?} }}" , self . pen () , self . psel () , self . spb0 () , self . brk () , self . char () , self . spb1 () , self . b8rxd () , self . b8txd () , self . b8pol () , self . b8tog () , self . b8en () , self . rwu () , self . wake ()) } } # [doc = "Current status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Csr (pub u32) ; impl Csr { # [doc = "Transmit complete flag bit"] # [must_use] # [inline (always)] pub const fn txc (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Transmit complete flag bit"] # [inline (always)] pub const fn set_txc (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Receive valid data flag bit"] # [must_use] # [inline (always)] pub const fn rxavl (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Receive valid data flag bit"] # [inline (always)] pub const fn set_rxavl (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Transmit buffer full flag bit"] # [must_use] # [inline (always)] pub const fn txfull (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Transmit buffer full flag bit"] # [inline (always)] pub const fn set_txfull (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Transmit buffer empty flag bit"] # [must_use] # [inline (always)] pub const fn txbuf_empty (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Transmit buffer empty flag bit"] # [inline (always)] pub const fn set_txbuf_empty (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } } impl Default for Csr { # [inline (always)] fn default () -> Csr { Csr (0) } } impl core :: fmt :: Debug for Csr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Csr") . field ("txc" , & self . txc ()) . field ("rxavl" , & self . rxavl ()) . field ("txfull" , & self . txfull ()) . field ("txbuf_empty" , & self . txbuf_empty ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Csr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Csr {{ txc: {=bool:?}, rxavl: {=bool:?}, txfull: {=bool:?}, txbuf_empty: {=bool:?} }}" , self . txc () , self . rxavl () , self . txfull () , self . txbuf_empty ()) } } # [doc = "Fractional baud rate register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Fra (pub u32) ; impl Fra { # [doc = "Fractional part of UARTDIV"] # [must_use] # [inline (always)] pub const fn div_fraction (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x0f ; val as u8 } # [doc = "Fractional part of UARTDIV"] # [inline (always)] pub const fn set_div_fraction (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize) ; } } impl Default for Fra { # [inline (always)] fn default () -> Fra { Fra (0) } } impl core :: fmt :: Debug for Fra { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Fra") . field ("div_fraction" , & self . div_fraction ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Fra { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Fra {{ div_fraction: {=u8:?} }}" , self . div_fraction ()) } } # [doc = "Global control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Gcr (pub u32) ; impl Gcr { # [doc = "UART mode selection bit"] # [must_use] # [inline (always)] pub const fn uarten (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "UART mode selection bit"] # [inline (always)] pub const fn set_uarten (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "DMA mode selection bit"] # [must_use] # [inline (always)] pub const fn dmamode (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "DMA mode selection bit"] # [inline (always)] pub const fn set_dmamode (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Automatic flow control enable bit"] # [must_use] # [inline (always)] pub const fn autoflowen (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Automatic flow control enable bit"] # [inline (always)] pub const fn set_autoflowen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Enable receive"] # [must_use] # [inline (always)] pub const fn rxen (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Enable receive"] # [inline (always)] pub const fn set_rxen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Enable transmit"] # [must_use] # [inline (always)] pub const fn txen (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Enable transmit"] # [inline (always)] pub const fn set_txen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } } impl Default for Gcr { # [inline (always)] fn default () -> Gcr { Gcr (0) } } impl core :: fmt :: Debug for Gcr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gcr") . field ("uarten" , & self . uarten ()) . field ("dmamode" , & self . dmamode ()) . field ("autoflowen" , & self . autoflowen ()) . field ("rxen" , & self . rxen ()) . field ("txen" , & self . txen ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Gcr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Gcr {{ uarten: {=bool:?}, dmamode: {=bool:?}, autoflowen: {=bool:?}, rxen: {=bool:?}, txen: {=bool:?} }}" , self . uarten () , self . dmamode () , self . autoflowen () , self . rxen () , self . txen ()) } } # [doc = "ICR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Icr (pub u32) ; impl Icr { # [doc = "Transmit buffer empty interrupt clear bit"] # [must_use] # [inline (always)] pub const fn txiclr (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Transmit buffer empty interrupt clear bit"] # [inline (always)] pub const fn set_txiclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Receive interrupt clear bit"] # [must_use] # [inline (always)] pub const fn rxiclr (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Receive interrupt clear bit"] # [inline (always)] pub const fn set_rxiclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Transmit complete interrupt clear bit"] # [must_use] # [inline (always)] pub const fn txc_clr (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Transmit complete interrupt clear bit"] # [inline (always)] pub const fn set_txc_clr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Receive overflow error interrupt clear bit"] # [must_use] # [inline (always)] pub const fn rxoerrclr (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Receive overflow error interrupt clear bit"] # [inline (always)] pub const fn set_rxoerrclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Parity error interrupt clear bit"] # [must_use] # [inline (always)] pub const fn rxperrclr (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Parity error interrupt clear bit"] # [inline (always)] pub const fn set_rxperrclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Frame error interrupt clear bit"] # [must_use] # [inline (always)] pub const fn rxferrclr (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Frame error interrupt clear bit"] # [inline (always)] pub const fn set_rxferrclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Receive frame break interrupt clear bit"] # [must_use] # [inline (always)] pub const fn rxbrkclr (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Receive frame break interrupt clear bit"] # [inline (always)] pub const fn set_rxbrkclr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Transmit Break Frame Interrupt clear Bit"] # [must_use] # [inline (always)] pub const fn txbrk_clr (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Transmit Break Frame Interrupt clear Bit"] # [inline (always)] pub const fn set_txbrk_clr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Receive Bit 8 Interrupt clear Bit"] # [must_use] # [inline (always)] pub const fn rxb8_clr (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Receive Bit 8 Interrupt clear Bit"] # [inline (always)] pub const fn set_rxb8_clr (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } } impl Default for Icr { # [inline (always)] fn default () -> Icr { Icr (0) } } impl core :: fmt :: Debug for Icr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Icr") . field ("txiclr" , & self . txiclr ()) . field ("rxiclr" , & self . rxiclr ()) . field ("txc_clr" , & self . txc_clr ()) . field ("rxoerrclr" , & self . rxoerrclr ()) . field ("rxperrclr" , & self . rxperrclr ()) . field ("rxferrclr" , & self . rxferrclr ()) . field ("rxbrkclr" , & self . rxbrkclr ()) . field ("txbrk_clr" , & self . txbrk_clr ()) . field ("rxb8_clr" , & self . rxb8_clr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Icr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Icr {{ txiclr: {=bool:?}, rxiclr: {=bool:?}, txc_clr: {=bool:?}, rxoerrclr: {=bool:?}, rxperrclr: {=bool:?}, rxferrclr: {=bool:?}, rxbrkclr: {=bool:?}, txbrk_clr: {=bool:?}, rxb8_clr: {=bool:?} }}" , self . txiclr () , self . rxiclr () , self . txc_clr () , self . rxoerrclr () , self . rxperrclr () , self . rxferrclr () , self . rxbrkclr () , self . txbrk_clr () , self . rxb8_clr ()) } } # [doc = "Interrupt enable register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Ier (pub u32) ; impl Ier { # [doc = "Transmit buffer empty interrupt enable bit"] # [must_use] # [inline (always)] pub const fn txien (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Transmit buffer empty interrupt enable bit"] # [inline (always)] pub const fn set_txien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Receive buffer interrupt enable bit"] # [must_use] # [inline (always)] pub const fn rxien (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Receive buffer interrupt enable bit"] # [inline (always)] pub const fn set_rxien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Transmit complete interrupt enable bit"] # [must_use] # [inline (always)] pub const fn txc_ien (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Transmit complete interrupt enable bit"] # [inline (always)] pub const fn set_txc_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Receive overflow error interrupt enable bit"] # [must_use] # [inline (always)] pub const fn rxoerren (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Receive overflow error interrupt enable bit"] # [inline (always)] pub const fn set_rxoerren (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Parity error interrupt enable bit"] # [must_use] # [inline (always)] pub const fn rxperren (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Parity error interrupt enable bit"] # [inline (always)] pub const fn set_rxperren (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Frame error interrupt enable bit"] # [must_use] # [inline (always)] pub const fn rxferren (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Frame error interrupt enable bit"] # [inline (always)] pub const fn set_rxferren (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Receive frame break interrupt enable bit"] # [must_use] # [inline (always)] pub const fn rxbrken (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Receive frame break interrupt enable bit"] # [inline (always)] pub const fn set_rxbrken (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Transmit Break Frame Interrupt Enable Bit"] # [must_use] # [inline (always)] pub const fn txbrk_ien (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Transmit Break Frame Interrupt Enable Bit"] # [inline (always)] pub const fn set_txbrk_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Receive Bit 8 Interrupt Enable Bit"] # [must_use] # [inline (always)] pub const fn rxb8_ien (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Receive Bit 8 Interrupt Enable Bit"] # [inline (always)] pub const fn set_rxb8_ien (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } } impl Default for Ier { # [inline (always)] fn default () -> Ier { Ier (0) } } impl core :: fmt :: Debug for Ier { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ier") . field ("txien" , & self . txien ()) . field ("rxien" , & self . rxien ()) . field ("txc_ien" , & self . txc_ien ()) . field ("rxoerren" , & self . rxoerren ()) . field ("rxperren" , & self . rxperren ()) . field ("rxferren" , & self . rxferren ()) . field ("rxbrken" , & self . rxbrken ()) . field ("txbrk_ien" , & self . txbrk_ien ()) . field ("rxb8_ien" , & self . rxb8_ien ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Ier { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Ier {{ txien: {=bool:?}, rxien: {=bool:?}, txc_ien: {=bool:?}, rxoerren: {=bool:?}, rxperren: {=bool:?}, rxferren: {=bool:?}, rxbrken: {=bool:?}, txbrk_ien: {=bool:?}, rxb8_ien: {=bool:?} }}" , self . txien () , self . rxien () , self . txc_ien () , self . rxoerren () , self . rxperren () , self . rxferren () , self . rxbrken () , self . txbrk_ien () , self . rxb8_ien ()) } } # [doc = "Interrupt status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Isr (pub u32) ; impl Isr { # [doc = "Transmit buffer empty interrupt flag bit"] # [must_use] # [inline (always)] pub const fn tx_intf (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Transmit buffer empty interrupt flag bit"] # [inline (always)] pub const fn set_tx_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "Receive valid data interrupt flag bit"] # [must_use] # [inline (always)] pub const fn rx_intf (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "Receive valid data interrupt flag bit"] # [inline (always)] pub const fn set_rx_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "UART Transmit Complete Interrupt Flag bit"] # [must_use] # [inline (always)] pub const fn txc_intf (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "UART Transmit Complete Interrupt Flag bit"] # [inline (always)] pub const fn set_txc_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "Receive overflow error interrupt flag bit"] # [must_use] # [inline (always)] pub const fn rxoerr_intf (& self) -> bool { let val = (self . 0 >> 3usize) & 0x01 ; val != 0 } # [doc = "Receive overflow error interrupt flag bit"] # [inline (always)] pub const fn set_rxoerr_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize) ; } # [doc = "Parity error interrupt flag bit"] # [must_use] # [inline (always)] pub const fn rxperr_intf (& self) -> bool { let val = (self . 0 >> 4usize) & 0x01 ; val != 0 } # [doc = "Parity error interrupt flag bit"] # [inline (always)] pub const fn set_rxperr_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize) ; } # [doc = "Frame error interrupt flag bit"] # [must_use] # [inline (always)] pub const fn rxferr_intf (& self) -> bool { let val = (self . 0 >> 5usize) & 0x01 ; val != 0 } # [doc = "Frame error interrupt flag bit"] # [inline (always)] pub const fn set_rxferr_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize) ; } # [doc = "Receive frame break interrupt flag bit"] # [must_use] # [inline (always)] pub const fn rxbrk_intf (& self) -> bool { let val = (self . 0 >> 6usize) & 0x01 ; val != 0 } # [doc = "Receive frame break interrupt flag bit"] # [inline (always)] pub const fn set_rxbrk_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize) ; } # [doc = "Transmit Break Frame Interrupt Flag Bit"] # [must_use] # [inline (always)] pub const fn txbrk_intf (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Transmit Break Frame Interrupt Flag Bit"] # [inline (always)] pub const fn set_txbrk_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } # [doc = "Receive Bit 8 Interrupt Flag Bit"] # [must_use] # [inline (always)] pub const fn rxb8_intf (& self) -> bool { let val = (self . 0 >> 8usize) & 0x01 ; val != 0 } # [doc = "Receive Bit 8 Interrupt Flag Bit"] # [inline (always)] pub const fn set_rxb8_intf (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize) ; } } impl Default for Isr { # [inline (always)] fn default () -> Isr { Isr (0) } } impl core :: fmt :: Debug for Isr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Isr") . field ("tx_intf" , & self . tx_intf ()) . field ("rx_intf" , & self . rx_intf ()) . field ("txc_intf" , & self . txc_intf ()) . field ("rxoerr_intf" , & self . rxoerr_intf ()) . field ("rxperr_intf" , & self . rxperr_intf ()) . field ("rxferr_intf" , & self . rxferr_intf ()) . field ("rxbrk_intf" , & self . rxbrk_intf ()) . field ("txbrk_intf" , & self . txbrk_intf ()) . field ("rxb8_intf" , & self . rxb8_intf ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Isr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Isr {{ tx_intf: {=bool:?}, rx_intf: {=bool:?}, txc_intf: {=bool:?}, rxoerr_intf: {=bool:?}, rxperr_intf: {=bool:?}, rxferr_intf: {=bool:?}, rxbrk_intf: {=bool:?}, txbrk_intf: {=bool:?}, rxb8_intf: {=bool:?} }}" , self . tx_intf () , self . rx_intf () , self . txc_intf () , self . rxoerr_intf () , self . rxperr_intf () , self . rxferr_intf () , self . rxbrk_intf () , self . txbrk_intf () , self . rxb8_intf ()) } } # [doc = "Receive data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rdr (pub u32) ; impl Rdr { # [doc = "Receive data register"] # [must_use] # [inline (always)] pub const fn rxreg (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Receive data register"] # [inline (always)] pub const fn set_rxreg (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Rdr { # [inline (always)] fn default () -> Rdr { Rdr (0) } } impl core :: fmt :: Debug for Rdr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rdr") . field ("rxreg" , & self . rxreg ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rdr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rdr {{ rxreg: {=u8:?} }}" , self . rxreg ()) } } # [doc = "RXADDR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rxaddr (pub u32) ; impl Rxaddr { # [doc = "Synchronous frame match address"] # [must_use] # [inline (always)] pub const fn rxaddr (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Synchronous frame match address"] # [inline (always)] pub const fn set_rxaddr (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Rxaddr { # [inline (always)] fn default () -> Rxaddr { Rxaddr (0) } } impl core :: fmt :: Debug for Rxaddr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rxaddr") . field ("rxaddr" , & self . rxaddr ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rxaddr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rxaddr {{ rxaddr: {=u8:?} }}" , self . rxaddr ()) } } # [doc = "RXMASK"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Rxmask (pub u32) ; impl Rxmask { # [doc = "Synchronous frame match address mask"] # [must_use] # [inline (always)] pub const fn rxmask (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Synchronous frame match address mask"] # [inline (always)] pub const fn set_rxmask (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Rxmask { # [inline (always)] fn default () -> Rxmask { Rxmask (0) } } impl core :: fmt :: Debug for Rxmask { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rxmask") . field ("rxmask" , & self . rxmask ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Rxmask { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Rxmask {{ rxmask: {=u8:?} }}" , self . rxmask ()) } } # [doc = "SCR"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Scr (pub u32) ; impl Scr { # [doc = "ISO7816 enable control bit"] # [must_use] # [inline (always)] pub const fn scen (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "ISO7816 enable control bit"] # [inline (always)] pub const fn set_scen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } # [doc = "ISO7816 check auto-response bit"] # [must_use] # [inline (always)] pub const fn scaen (& self) -> bool { let val = (self . 0 >> 1usize) & 0x01 ; val != 0 } # [doc = "ISO7816 check auto-response bit"] # [inline (always)] pub const fn set_scaen (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize) ; } # [doc = "Master receive frame answer bit"] # [must_use] # [inline (always)] pub const fn nack (& self) -> bool { let val = (self . 0 >> 2usize) & 0x01 ; val != 0 } # [doc = "Master receive frame answer bit"] # [inline (always)] pub const fn set_nack (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize) ; } # [doc = "ISO7816 protection counter bit"] # [must_use] # [inline (always)] pub const fn scfcnt (& self) -> u8 { let val = (self . 0 >> 4usize) & 0xff ; val as u8 } # [doc = "ISO7816 protection counter bit"] # [inline (always)] pub const fn set_scfcnt (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 4usize)) | (((val as u32) & 0xff) << 4usize) ; } # [doc = "Single-wire half-duplex mode selection bit"] # [must_use] # [inline (always)] pub const fn hdsel (& self) -> bool { let val = (self . 0 >> 12usize) & 0x01 ; val != 0 } # [doc = "Single-wire half-duplex mode selection bit"] # [inline (always)] pub const fn set_hdsel (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize) ; } } impl Default for Scr { # [inline (always)] fn default () -> Scr { Scr (0) } } impl core :: fmt :: Debug for Scr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Scr") . field ("scen" , & self . scen ()) . field ("scaen" , & self . scaen ()) . field ("nack" , & self . nack ()) . field ("scfcnt" , & self . scfcnt ()) . field ("hdsel" , & self . hdsel ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Scr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Scr {{ scen: {=bool:?}, scaen: {=bool:?}, nack: {=bool:?}, scfcnt: {=u8:?}, hdsel: {=bool:?} }}" , self . scen () , self . scaen () , self . nack () , self . scfcnt () , self . hdsel ()) } } # [doc = "Transmit data register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Tdr (pub u32) ; impl Tdr { # [doc = "Transmit data register"] # [must_use] # [inline (always)] pub const fn txreg (& self) -> u8 { let val = (self . 0 >> 0usize) & 0xff ; val as u8 } # [doc = "Transmit data register"] # [inline (always)] pub const fn set_txreg (& mut self , val : u8) { self . 0 = (self . 0 & ! (0xff << 0usize)) | (((val as u32) & 0xff) << 0usize) ; } } impl Default for Tdr { # [inline (always)] fn default () -> Tdr { Tdr (0) } } impl core :: fmt :: Debug for Tdr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tdr") . field ("txreg" , & self . txreg ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Tdr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Tdr {{ txreg: {=u8:?} }}" , self . txreg ()) } } } } pub mod wwdg { # [doc = "Window watchdog"] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Wwdg { ptr : * mut u8 } unsafe impl Send for Wwdg { } unsafe impl Sync for Wwdg { } impl Wwdg { # [inline (always)] pub const unsafe fn from_ptr (ptr : * mut ()) -> Self { Self { ptr : ptr as _ , } } # [inline (always)] pub const fn as_ptr (& self) -> * mut () { self . ptr as _ } # [doc = "Control register"] # [inline (always)] pub const fn cr (self) -> crate :: common :: Reg < regs :: Cr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x0usize) as _) } } # [doc = "Configuration register"] # [inline (always)] pub const fn cfgr (self) -> crate :: common :: Reg < regs :: Cfgr , crate :: common :: RW > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x04usize) as _) } } # [doc = "Status register"] # [inline (always)] pub const fn sr (self) -> crate :: common :: Reg < regs :: Sr , crate :: common :: R > { unsafe { crate :: common :: Reg :: from_ptr (self . ptr . wrapping_add (0x08usize) as _) } } } pub mod regs { # [doc = "Configuration register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cfgr (pub u32) ; impl Cfgr { # [doc = "7-bit window value"] # [must_use] # [inline (always)] pub const fn window (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x7f ; val as u8 } # [doc = "7-bit window value"] # [inline (always)] pub const fn set_window (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize) ; } # [doc = "Timer base"] # [must_use] # [inline (always)] pub const fn wdgtb (& self) -> u8 { let val = (self . 0 >> 7usize) & 0x03 ; val as u8 } # [doc = "Timer base"] # [inline (always)] pub const fn set_wdgtb (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x03 << 7usize)) | (((val as u32) & 0x03) << 7usize) ; } # [doc = "Early wakeup interrupt"] # [must_use] # [inline (always)] pub const fn ewi (& self) -> bool { let val = (self . 0 >> 9usize) & 0x01 ; val != 0 } # [doc = "Early wakeup interrupt"] # [inline (always)] pub const fn set_ewi (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize) ; } } impl Default for Cfgr { # [inline (always)] fn default () -> Cfgr { Cfgr (0) } } impl core :: fmt :: Debug for Cfgr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cfgr") . field ("window" , & self . window ()) . field ("wdgtb" , & self . wdgtb ()) . field ("ewi" , & self . ewi ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cfgr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cfgr {{ window: {=u8:?}, wdgtb: {=u8:?}, ewi: {=bool:?} }}" , self . window () , self . wdgtb () , self . ewi ()) } } # [doc = "Control register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Cr (pub u32) ; impl Cr { # [doc = "7-bit counter"] # [must_use] # [inline (always)] pub const fn t (& self) -> u8 { let val = (self . 0 >> 0usize) & 0x7f ; val as u8 } # [doc = "7-bit counter"] # [inline (always)] pub const fn set_t (& mut self , val : u8) { self . 0 = (self . 0 & ! (0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize) ; } # [doc = "Activation bit"] # [must_use] # [inline (always)] pub const fn wdga (& self) -> bool { let val = (self . 0 >> 7usize) & 0x01 ; val != 0 } # [doc = "Activation bit"] # [inline (always)] pub const fn set_wdga (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize) ; } } impl Default for Cr { # [inline (always)] fn default () -> Cr { Cr (0) } } impl core :: fmt :: Debug for Cr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Cr") . field ("t" , & self . t ()) . field ("wdga" , & self . wdga ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Cr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Cr {{ t: {=u8:?}, wdga: {=bool:?} }}" , self . t () , self . wdga ()) } } # [doc = "Status register"] # [repr (transparent)] # [derive (Copy , Clone , Eq , PartialEq)] pub struct Sr (pub u32) ; impl Sr { # [doc = "Early wakeup interrupt flag"] # [must_use] # [inline (always)] pub const fn ewif (& self) -> bool { let val = (self . 0 >> 0usize) & 0x01 ; val != 0 } # [doc = "Early wakeup interrupt flag"] # [inline (always)] pub const fn set_ewif (& mut self , val : bool) { self . 0 = (self . 0 & ! (0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize) ; } } impl Default for Sr { # [inline (always)] fn default () -> Sr { Sr (0) } } impl core :: fmt :: Debug for Sr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sr") . field ("ewif" , & self . ewif ()) . finish () } } # [cfg (feature = "defmt")] impl defmt :: Format for Sr { fn format (& self , f : defmt :: Formatter) { defmt :: write ! (f , "Sr {{ ewif: {=bool:?} }}" , self . ewif ()) } } } }