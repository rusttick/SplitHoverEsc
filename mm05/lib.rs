# ! [doc = "Peripheral access API for MM32SPIN05XQ microcontrollers (generated using svd2rust v0.37.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] # ! [cfg_attr (docsrs , feature (doc_auto_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 2 ;
#[allow (unused_imports)] use generic :: * ;
#[doc = r"Common register and bit access and modify traits"] pub mod generic { use core :: marker ;
#[doc = " Generic peripheral accessor"] pub struct Periph < RB , const A : usize > { _marker : marker :: PhantomData < RB > , } unsafe impl < RB , const A : usize > Send for Periph < RB , A > { } impl < RB , const A : usize > Periph < RB , A > {
#[doc = "Pointer to the register block"] pub const PTR : * const RB = A as * const _ ;
#[doc = "Return the pointer to the register block"]
#[inline (always)] pub const fn ptr () -> * const RB { Self :: PTR }
#[doc = " Steal an instance of this peripheral"]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Ensure that the new instance of the peripheral cannot be used in a way"]
#[doc = " that may race with any existing instances, for example by only"]
#[doc = " accessing read-only or write-only registers, or by consuming the"]
#[doc = " original peripheral and using critical sections to coordinate"]
#[doc = " access between multiple new instances."]
#[doc = ""]
#[doc = " Additionally, other software such as HALs may rely on only one"]
#[doc = " peripheral instance existing to ensure memory safety; ensure"]
#[doc = " no stolen instances are passed to such software."] pub unsafe fn steal () -> Self { Self { _marker : marker :: PhantomData , } } } impl < RB , const A : usize > core :: ops :: Deref for Periph < RB , A > { type Target = RB ;
#[inline (always)] fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } }
#[doc = " Raw register type (`u8`, `u16`, `u32`, ...)"] pub trait RawReg : Copy + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > {
#[doc = " Mask for bits of width `WI`"] fn mask < const WI : u8 > () -> Self ;
#[doc = " `0`"] const ZERO : Self ;
#[doc = " `1`"] const ONE : Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U {
#[inline (always)] fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } const ZERO : Self = 0 ; const ONE : Self = 1 ; } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ;
#[doc = " Raw register type"] pub trait RegisterSpec {
#[doc = " Raw register type (`u8`, `u16`, `u32`, ...)."] type Ux : RawReg ; }
#[doc = " Raw field type"] pub trait FieldSpec : Sized {
#[doc = " Raw field type (`u8`, `u16`, `u32`, ...)."] type Ux : Copy + core :: fmt :: Debug + PartialEq + From < Self > ; }
#[doc = " Marker for fields with fixed values"] pub trait IsEnum : FieldSpec { }
#[doc = " Trait implemented by readable registers to enable the `read` method."]
#[doc = ""]
#[doc = " Registers marked with `Writable` can be also be `modify`'ed."] pub trait Readable : RegisterSpec { }
#[doc = " Trait implemented by writeable registers."]
#[doc = ""]
#[doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
#[doc = ""]
#[doc = " Registers marked with `Readable` can be also be `modify`'ed."] pub trait Writable : RegisterSpec {
#[doc = " Is it safe to write any bits to register"] type Safety ;
#[doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"] const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = Self :: Ux :: ZERO ;
#[doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"] const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux = Self :: Ux :: ZERO ; }
#[doc = " Reset value of the register."]
#[doc = ""]
#[doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
#[doc = " register by using the `reset` method."] pub trait Resettable : RegisterSpec {
#[doc = " Reset value of the register."] const RESET_VALUE : Self :: Ux = Self :: Ux :: ZERO ;
#[doc = " Reset value of the register."]
#[inline (always)] fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } }
#[doc (hidden)] pub mod raw { use super :: { marker , BitM , FieldSpec , RegisterSpec , Unsafe , Writable } ; pub struct R < REG : RegisterSpec > { pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct W < REG : RegisterSpec > {
#[doc = "Writable bits"] pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct FieldReader < FI = u8 > where FI : FieldSpec , { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReader < FI > {
#[doc = " Creates a new instance of the reader."]
#[allow (unused)]
#[inline (always)] pub (crate) const fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct BitReader < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReader < FI > {
#[doc = " Creates a new instance of the reader."]
#[allow (unused)]
#[inline (always)] pub (crate) const fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } }
#[must_use = "after creating `FieldWriter` you need to call field value setting method"] pub struct FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , {
#[doc = " Creates a new instance of the writer"]
#[allow (unused)]
#[inline (always)] pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } }
#[must_use = "after creating `BitWriter` you need to call bit setting method"] pub struct BitWriter < 'a , REG , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , FI , M > BitWriter < 'a , REG , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Creates a new instance of the writer"]
#[allow (unused)]
#[inline (always)] pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } }
#[doc = " Register reader."]
#[doc = ""]
#[doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
#[doc = " method."] pub type R < REG > = raw :: R < REG > ; impl < REG : RegisterSpec > R < REG > {
#[doc = " Reads raw bits from register."]
#[inline (always)] pub const fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } }
#[doc = " Register writer."]
#[doc = ""]
#[doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."] pub type W < REG > = raw :: W < REG > ; impl < REG : Writable > W < REG > {
#[doc = " Writes raw bits to the register."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
#[inline (always)] pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } impl < REG > W < REG > where REG : Writable < Safety = Safe > , {
#[doc = " Writes raw bits to the register."]
#[inline (always)] pub fn set (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } }
#[doc = " Field reader."]
#[doc = ""]
#[doc = " Result of the `read` methods of fields."] pub type FieldReader < FI = u8 > = raw :: FieldReader < FI > ;
#[doc = " Bit-wise field reader"] pub type BitReader < FI = bool > = raw :: BitReader < FI > ; impl < FI : FieldSpec > FieldReader < FI > {
#[doc = " Reads raw bits from field."]
#[inline (always)] pub const fn bits (& self) -> FI :: Ux { self . bits } } impl < FI : FieldSpec > core :: fmt :: Debug for FieldReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , {
#[inline (always)] fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > {
#[doc = " Value of the field as raw bits."]
#[inline (always)] pub const fn bit (& self) -> bool { self . bits }
#[doc = " Returns `true` if the bit is clear (0)."]
#[inline (always)] pub const fn bit_is_clear (& self) -> bool { ! self . bit () }
#[doc = " Returns `true` if the bit is set (1)."]
#[inline (always)] pub const fn bit_is_set (& self) -> bool { self . bit () } } impl < FI > core :: fmt :: Debug for BitReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } }
#[doc = " Marker for register/field writers which can take any value of specified width"] pub struct Safe ;
#[doc = " You should check that value is allowed to pass to register/field writer marked with this"] pub struct Unsafe ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct Range < const MIN : u64 , const MAX : u64 > ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct RangeFrom < const MIN : u64 > ;
#[doc = " Marker for field writers are safe to write in specified inclusive range"] pub struct RangeTo < const MAX : u64 > ;
#[doc = " Write field Proxy"] pub type FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > = raw :: FieldWriter < 'a , REG , WI , FI , Safety > ; impl < REG , const WI : u8 , FI , Safety > FieldWriter < '_ , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , {
#[doc = " Field width"] pub const WIDTH : u8 = WI ;
#[doc = " Field width"]
#[inline (always)] pub const fn width (& self) -> u8 { WI }
#[doc = " Field offset"]
#[inline (always)] pub const fn offset (& self) -> u8 { self . o } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
#[inline (always)] pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << self . o ; self . w } } impl < 'a , REG , const WI : u8 , FI > FieldWriter < 'a , REG , WI , FI , Safe > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , Range < MIN , MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN && value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 > FieldWriter < 'a , REG , WI , FI , RangeFrom < MIN > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , RangeTo < MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , {
#[doc = " Writes raw bits to the field"]
#[inline (always)] pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : IsEnum , REG :: Ux : From < FI :: Ux > , {
#[doc = " Writes `variant` to the field"]
#[inline (always)] pub fn variant (self , variant : FI) -> & 'a mut W < REG > { unsafe { self . bits (FI :: Ux :: from (variant)) } } } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => {
#[doc (hidden)] pub struct $ mwv ;
#[doc = " Bit-wise write field proxy"] pub type $ writer <'a , REG , FI = bool > = raw :: BitWriter <'a , REG , FI , $ mwv >; impl <'a , REG , FI > $ writer <'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI >, {
#[doc = " Field width"] pub const WIDTH : u8 = 1 ;
#[doc = " Field width"]
#[inline (always)] pub const fn width (& self) -> u8 { Self :: WIDTH }
#[doc = " Field offset"]
#[inline (always)] pub const fn offset (& self) -> u8 { self . o }
#[doc = " Writes bit to the field"]
#[inline (always)] pub fn bit (self , value : bool) -> &'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: ONE) << self . o ; self . w }
#[doc = " Writes `variant` to the field"]
#[inline (always)] pub fn variant (self , variant : FI) -> &'a mut W < REG > { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , FI > BitWriter < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Sets the field bit"]
#[inline (always)] pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w }
#[doc = " Clears the field bit"]
#[inline (always)] pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Sets the field bit"]
#[inline (always)] pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = " Clears the field bit"]
#[inline (always)] pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Clears the field bit by passing one"]
#[inline (always)] pub fn clear_bit_by_one (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Sets the field bit by passing zero"]
#[inline (always)] pub fn set_bit_by_zero (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Toggle the field bit by passing one"]
#[inline (always)] pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: ONE << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , {
#[doc = "Toggle the field bit by passing zero"]
#[inline (always)] pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: ONE << self . o) ; self . w } }
#[doc = " This structure provides volatile access to registers."]
#[repr (transparent)] pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > {
#[doc = " Returns the underlying memory address of register."]
#[doc = ""]
#[doc = " ```ignore"]
#[doc = " let reg_ptr = periph.reg.as_ptr();"]
#[doc = " ```"]
#[inline (always)] pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > {
#[doc = " Reads the contents of a `Readable` register."]
#[doc = ""]
#[doc = " You can read the raw contents of a register by using `bits`:"]
#[doc = " ```ignore"]
#[doc = " let bits = periph.reg.read().bits();"]
#[doc = " ```"]
#[doc = " or get the content of a particular field of a register:"]
#[doc = " ```ignore"]
#[doc = " let reader = periph.reg.read();"]
#[doc = " let bits = reader.field1().bits();"]
#[doc = " let flag = reader.field2().bit_is_set();"]
#[doc = " ```"]
#[inline (always)] pub fn read (& self) -> R < REG > { R { bits : self . register . get () , _reg : marker :: PhantomData , } } } impl < REG : Resettable + Writable > Reg < REG > {
#[doc = " Writes the reset value to `Writable` register."]
#[doc = ""]
#[doc = " Resets the register to its initial state."]
#[inline (always)] pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) }
#[doc = " Writes bits to a `Writable` register."]
#[doc = ""]
#[doc = " You can write raw bits into a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
#[doc = " ```"]
#[doc = " or write only the fields you need:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| w"]
#[doc = "     .field1().bits(newfield1bits)"]
#[doc = "     .field2().set_bit()"]
#[doc = "     .field3().variant(VARIANT)"]
#[doc = " );"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write(|w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT)"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " In the latter case, other fields will be set to their reset value."]
#[inline (always)] pub fn write < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value }
#[doc = " Writes bits to a `Writable` register and produce a value."]
#[doc = ""]
#[doc = " You can write raw bits into a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| unsafe { w.bits(rawbits); });"]
#[doc = " ```"]
#[doc = " or write only the fields you need:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| {"]
#[doc = "     w.field1().bits(newfield1bits)"]
#[doc = "         .field2().set_bit()"]
#[doc = "         .field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.write_and(|w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " In the latter case, other fields will be set to their reset value."]
#[doc = ""]
#[doc = " Values can be returned from the closure:"]
#[doc = " ```ignore"]
#[doc = " let state = periph.reg.write_and(|w| State::set(w.field1()));"]
#[doc = " ```"]
#[inline (always)] pub fn from_write < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Writable > Reg < REG > {
#[doc = " Writes 0 to a `Writable` register."]
#[doc = ""]
#[doc = " Similar to `write`, but unused bits will contain 0."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Unsafe to use with registers which don't allow to write 0."]
#[inline (always)] pub unsafe fn write_with_zero < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: Ux :: ZERO , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value }
#[doc = " Writes 0 to a `Writable` register and produces a value."]
#[doc = ""]
#[doc = " Similar to `write`, but unused bits will contain 0."]
#[doc = ""]
#[doc = " # Safety"]
#[doc = ""]
#[doc = " Unsafe to use with registers which don't allow to write 0."]
#[inline (always)] pub unsafe fn from_write_with_zero < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: Ux :: ZERO , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Readable + Writable > Reg < REG > {
#[doc = " Modifies the contents of the register by reading and then writing it."]
#[doc = ""]
#[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
#[doc = "    r.bits() | 3"]
#[doc = " ) });"]
#[doc = " ```"]
#[doc = " or"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| w"]
#[doc = "     .field1().bits(newfield1bits)"]
#[doc = "     .field2().set_bit()"]
#[doc = "     .field3().variant(VARIANT)"]
#[doc = " );"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT)"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " Other fields will have the value they had before the call to `modify`."]
#[inline (always)] pub fn modify < F > (& self , f : F) -> REG :: Ux where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> & 'w mut W < REG > , { let bits = self . register . get () ; let value = f (& R { bits , _reg : marker :: PhantomData , } , & mut W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ,) . bits ; self . register . set (value) ; value }
#[doc = " Modifies the contents of the register by reading and then writing it"]
#[doc = " and produces a value."]
#[doc = ""]
#[doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
#[doc = " ```ignore"]
#[doc = " let bits = periph.reg.modify(|r, w| {"]
#[doc = "     let new_bits = r.bits() | 3;"]
#[doc = "     unsafe {"]
#[doc = "         w.bits(new_bits);"]
#[doc = "     }"]
#[doc = ""]
#[doc = "     new_bits"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits)"]
#[doc = "         .field2().set_bit()"]
#[doc = "         .field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " or an alternative way of saying the same:"]
#[doc = " ```ignore"]
#[doc = " periph.reg.modify(|_, w| {"]
#[doc = "     w.field1().bits(newfield1bits);"]
#[doc = "     w.field2().set_bit();"]
#[doc = "     w.field3().variant(VARIANT);"]
#[doc = " });"]
#[doc = " ```"]
#[doc = " Other fields will have the value they had before the call to `modify`."]
#[inline (always)] pub fn from_modify < F , T > (& self , f : F) -> T where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> T , { let bits = self . register . get () ; let mut writer = W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& R { bits , _reg : marker :: PhantomData , } , & mut writer ,) ; self . register . set (writer . bits) ; result } } impl < REG : Readable > core :: fmt :: Debug for crate :: generic :: Reg < REG > where R < REG > : core :: fmt :: Debug , { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . read () , f) } } }
#[cfg (feature = "rt")] extern "C" { fn WWDG_IWDG () ; fn PVD () ; fn PWM () ; fn FLASH () ; fn RCC () ; fn EXTI0_1 () ; fn EXTI2_3 () ; fn EXTI4_15 () ; fn HWDIV () ; fn DMA1_Channel1 () ; fn DMA1_Channel2_3 () ; fn DMA1_Channel4_5 () ; fn ADC_COMP () ; fn TIM1_BRK_UP_TRG_COM () ; fn TIM1_CC () ; fn TIM2 () ; fn TIM3 () ; fn TIM14 () ; fn TIM16 () ; fn TIM17 () ; fn I2C1 () ; fn SPI1 () ; fn SPI2 () ; fn UART1 () ; fn UART2 () ; }
#[doc (hidden)]
#[repr (C)] pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , }
#[cfg (feature = "rt")]
#[doc (hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle] pub static __INTERRUPTS : [Vector ; 29] = [Vector { _handler : WWDG_IWDG } , Vector { _handler : PVD } , Vector { _handler : PWM } , Vector { _handler : FLASH } , Vector { _handler : RCC } , Vector { _handler : EXTI0_1 } , Vector { _handler : EXTI2_3 } , Vector { _handler : EXTI4_15 } , Vector { _handler : HWDIV } , Vector { _handler : DMA1_Channel1 } , Vector { _handler : DMA1_Channel2_3 } , Vector { _handler : DMA1_Channel4_5 } , Vector { _handler : ADC_COMP } , Vector { _handler : TIM1_BRK_UP_TRG_COM } , Vector { _handler : TIM1_CC } , Vector { _handler : TIM2 } , Vector { _handler : TIM3 } , Vector { _reserved : 0 } , Vector { _reserved : 0 } , Vector { _handler : TIM14 } , Vector { _reserved : 0 } , Vector { _handler : TIM16 } , Vector { _handler : TIM17 } , Vector { _handler : I2C1 } , Vector { _reserved : 0 } , Vector { _handler : SPI1 } , Vector { _handler : SPI2 } , Vector { _handler : UART1 } , Vector { _handler : UART2 } ,] ;
#[doc = r"Enumeration of all the interrupts."]
#[derive (Copy , Clone , Debug , PartialEq , Eq)]
#[repr (u16)] pub enum Interrupt {
#[doc = "0 - Watchdog interrupt"] WWDG_IWDG = 0 ,
#[doc = "1 - PVD through EXTI line detection interrupt"] PVD = 1 ,
#[doc = "2 - Commutation and Input Interrupt"] PWM = 2 ,
#[doc = "3 - Flash global interrupt"] FLASH = 3 ,
#[doc = "4 - RCC global interrupt"] RCC = 4 ,
#[doc = "5 - EXTI Line0_1 interrupt"] EXTI0_1 = 5 ,
#[doc = "6 - EXTI Line2_3 interrupt"] EXTI2_3 = 6 ,
#[doc = "7 - EXTI Line4_15 interrupt"] EXTI4_15 = 7 ,
#[doc = "8 - HWDIV global interrupt"] HWDIV = 8 ,
#[doc = "9 - DMA1 Channel1 global interrupt"] DMA1_Channel1 = 9 ,
#[doc = "10 - DMA1 Channel2_3 global interrupt"] DMA1_Channel2_3 = 10 ,
#[doc = "11 - DMA1 Channel4_5 global interrupt"] DMA1_Channel4_5 = 11 ,
#[doc = "12 - ADC and COMP global interrupt"] ADC_COMP = 12 ,
#[doc = "13 - TIM1 break,Update,Trigger and Commutation interrupt"] TIM1_BRK_UP_TRG_COM = 13 ,
#[doc = "14 - TIM1 Capture Compare interrupt"] TIM1_CC = 14 ,
#[doc = "15 - TIM2 global interrupt"] TIM2 = 15 ,
#[doc = "16 - TIM3 global interrupt"] TIM3 = 16 ,
#[doc = "19 - TIM14 global interrupt"] TIM14 = 19 ,
#[doc = "21 - TIM16 global interrupt"] TIM16 = 21 ,
#[doc = "22 - TIM17 global interrupt"] TIM17 = 22 ,
#[doc = "23 - I2C1 interrupt"] I2C1 = 23 ,
#[doc = "25 - SPI1 global interrupt"] SPI1 = 25 ,
#[doc = "26 - SPI2 global interrupt"] SPI2 = 26 ,
#[doc = "27 - UART1 global interrupt"] UART1 = 27 ,
#[doc = "28 - UART2 global interrupt"] UART2 = 28 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt {
#[inline (always)] fn number (self) -> u16 { self as u16 } }
#[doc = "Analog to digital converter"] pub type Adc = crate :: Periph < adc :: RegisterBlock , 0x4001_2400 > ; impl core :: fmt :: Debug for Adc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc") . finish () } }
#[doc = "Analog to digital converter"] pub mod adc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { dr : Dr , cfgr : Cfgr , cr : Cr , chsr : Chsr , cmpr : Cmpr , sr : Sr , ch0dr : Ch0dr , ch1dr : Ch1dr , ch2dr : Ch2dr , ch3dr : Ch3dr , ch4dr : Ch4dr , ch5dr : Ch5dr , ch6dr : Ch6dr , ch7dr : Ch7dr , ch8dr : Ch8dr , ch9dr : Ch9dr , ch10dr : Ch10dr , ch11dr : Ch11dr , ch12dr : Ch12dr , _reserved19 : [u8 ; 0x04] , ch14dr : Ch14dr , ch15dr : Ch15dr , sta_ext : StaExt , } impl RegisterBlock {
#[doc = "0x00 - Data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x04 - Configure register"]
#[inline (always)] pub const fn cfgr (& self) -> & Cfgr { & self . cfgr }
#[doc = "0x08 - Control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x0c - Channel select register"]
#[inline (always)] pub const fn chsr (& self) -> & Chsr { & self . chsr }
#[doc = "0x10 - Compare register"]
#[inline (always)] pub const fn cmpr (& self) -> & Cmpr { & self . cmpr }
#[doc = "0x14 - Status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x18 - Channel 0 data register"]
#[inline (always)] pub const fn ch0dr (& self) -> & Ch0dr { & self . ch0dr }
#[doc = "0x1c - Channel 1 data register"]
#[inline (always)] pub const fn ch1dr (& self) -> & Ch1dr { & self . ch1dr }
#[doc = "0x20 - Channel 2 data register"]
#[inline (always)] pub const fn ch2dr (& self) -> & Ch2dr { & self . ch2dr }
#[doc = "0x24 - Channel 3 data register"]
#[inline (always)] pub const fn ch3dr (& self) -> & Ch3dr { & self . ch3dr }
#[doc = "0x28 - Channel 4 data register"]
#[inline (always)] pub const fn ch4dr (& self) -> & Ch4dr { & self . ch4dr }
#[doc = "0x2c - Channel 5 data register"]
#[inline (always)] pub const fn ch5dr (& self) -> & Ch5dr { & self . ch5dr }
#[doc = "0x30 - Channel 6 data register"]
#[inline (always)] pub const fn ch6dr (& self) -> & Ch6dr { & self . ch6dr }
#[doc = "0x34 - Channel 7 data register"]
#[inline (always)] pub const fn ch7dr (& self) -> & Ch7dr { & self . ch7dr }
#[doc = "0x38 - Channel 8 data register"]
#[inline (always)] pub const fn ch8dr (& self) -> & Ch8dr { & self . ch8dr }
#[doc = "0x3c - Channel 9 data register"]
#[inline (always)] pub const fn ch9dr (& self) -> & Ch9dr { & self . ch9dr }
#[doc = "0x40 - Channel 10 data register"]
#[inline (always)] pub const fn ch10dr (& self) -> & Ch10dr { & self . ch10dr }
#[doc = "0x44 - Channel 11 data register"]
#[inline (always)] pub const fn ch11dr (& self) -> & Ch11dr { & self . ch11dr }
#[doc = "0x48 - Channel 12 data register"]
#[inline (always)] pub const fn ch12dr (& self) -> & Ch12dr { & self . ch12dr }
#[doc = "0x50 - Channel 14 data register"]
#[inline (always)] pub const fn ch14dr (& self) -> & Ch14dr { & self . ch14dr }
#[doc = "0x54 - Channel 15 data register"]
#[inline (always)] pub const fn ch15dr (& self) -> & Ch15dr { & self . ch15dr }
#[doc = "0x58 - Extended status register"]
#[inline (always)] pub const fn sta_ext (& self) -> & StaExt { & self . sta_ext } }
#[doc = "DR (r) register accessor: Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "Data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `CH` reader - ADC current channel convert data"] pub type ChR = crate :: FieldReader ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:19 - ADC current channel convert data"]
#[inline (always)] pub fn ch (& self) -> ChR { ChR :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`reset()` method sets DR to value 0"] impl crate :: Resettable for DrSpec { } }
#[doc = "CFGR (rw) register accessor: Configure register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
#[doc (alias = "CFGR")] pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ;
#[doc = "Configure register"] pub mod cfgr {
#[doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ;
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ;
#[doc = "Field `ADEN` reader - ADC enable"] pub type AdenR = crate :: BitReader ;
#[doc = "Field `ADEN` writer - ADC enable"] pub type AdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADWEN` reader - ADC window comparison enable"] pub type AdwenR = crate :: BitReader ;
#[doc = "Field `ADWEN` writer - ADC window comparison enable"] pub type AdwenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TSEN` reader - Temperature sensor enable"] pub type TsenR = crate :: BitReader ;
#[doc = "Field `TSEN` writer - Temperature sensor enable"] pub type TsenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `VSEN` reader - Reference voltage enable"] pub type VsenR = crate :: BitReader ;
#[doc = "Field `VSEN` writer - Reference voltage enable"] pub type VsenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PREH` reader - ADC high prescaler coefficient"] pub type PrehR = crate :: FieldReader ;
#[doc = "Field `PREH` writer - ADC high prescaler coefficient"] pub type PrehW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `RSLTCTL` reader - Resolution"] pub type RsltctlR = crate :: FieldReader ;
#[doc = "Field `RSLTCTL` writer - Resolution"] pub type RsltctlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `SAMCTL` reader - Channel x Sample time selection"] pub type SamctlR = crate :: FieldReader ;
#[doc = "Field `SAMCTL` writer - Channel x Sample time selection"] pub type SamctlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `PREL` reader - ADC low prescaler coefficient"] pub type PrelR = crate :: BitReader ;
#[doc = "Field `PREL` writer - ADC low prescaler coefficient"] pub type PrelW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - ADC enable"]
#[inline (always)] pub fn aden (& self) -> AdenR { AdenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ADC window comparison enable"]
#[inline (always)] pub fn adwen (& self) -> AdwenR { AdwenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Temperature sensor enable"]
#[inline (always)] pub fn tsen (& self) -> TsenR { TsenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Reference voltage enable"]
#[inline (always)] pub fn vsen (& self) -> VsenR { VsenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - ADC high prescaler coefficient"]
#[inline (always)] pub fn preh (& self) -> PrehR { PrehR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 7:9 - Resolution"]
#[inline (always)] pub fn rsltctl (& self) -> RsltctlR { RsltctlR :: new (((self . bits >> 7) & 7) as u8) }
#[doc = "Bits 10:13 - Channel x Sample time selection"]
#[inline (always)] pub fn samctl (& self) -> SamctlR { SamctlR :: new (((self . bits >> 10) & 0x0f) as u8) }
#[doc = "Bit 14 - ADC low prescaler coefficient"]
#[inline (always)] pub fn prel (& self) -> PrelR { PrelR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - ADC enable"]
#[inline (always)] pub fn aden (& mut self) -> AdenW < '_ , CfgrSpec > { AdenW :: new (self , 0) }
#[doc = "Bit 1 - ADC window comparison enable"]
#[inline (always)] pub fn adwen (& mut self) -> AdwenW < '_ , CfgrSpec > { AdwenW :: new (self , 1) }
#[doc = "Bit 2 - Temperature sensor enable"]
#[inline (always)] pub fn tsen (& mut self) -> TsenW < '_ , CfgrSpec > { TsenW :: new (self , 2) }
#[doc = "Bit 3 - Reference voltage enable"]
#[inline (always)] pub fn vsen (& mut self) -> VsenW < '_ , CfgrSpec > { VsenW :: new (self , 3) }
#[doc = "Bits 4:6 - ADC high prescaler coefficient"]
#[inline (always)] pub fn preh (& mut self) -> PrehW < '_ , CfgrSpec > { PrehW :: new (self , 4) }
#[doc = "Bits 7:9 - Resolution"]
#[inline (always)] pub fn rsltctl (& mut self) -> RsltctlW < '_ , CfgrSpec > { RsltctlW :: new (self , 7) }
#[doc = "Bits 10:13 - Channel x Sample time selection"]
#[inline (always)] pub fn samctl (& mut self) -> SamctlW < '_ , CfgrSpec > { SamctlW :: new (self , 10) }
#[doc = "Bit 14 - ADC low prescaler coefficient"]
#[inline (always)] pub fn prel (& mut self) -> PrelW < '_ , CfgrSpec > { PrelW :: new (self , 14) } }
#[doc = "Configure register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0"] impl crate :: Resettable for CfgrSpec { } }
#[doc = "CR (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `ADIE` reader - ADC interrupt enable"] pub type AdieR = crate :: BitReader ;
#[doc = "Field `ADIE` writer - ADC interrupt enable"] pub type AdieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADWIE` reader - ADC window comparator interrupt enable"] pub type AdwieR = crate :: BitReader ;
#[doc = "Field `ADWIE` writer - ADC window comparator interrupt enable"] pub type AdwieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRGEN` reader - External trigger enable"] pub type TrgenR = crate :: BitReader ;
#[doc = "Field `TRGEN` writer - External trigger enable"] pub type TrgenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAEN` reader - Direct memory access enable"] pub type DmaenR = crate :: BitReader ;
#[doc = "Field `DMAEN` writer - Direct memory access enable"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRGSELL` reader - External trigger selection low"] pub type TrgsellR = crate :: FieldReader ;
#[doc = "Field `TRGSELL` writer - External trigger selection low"] pub type TrgsellW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `ADST` reader - ADC start"] pub type AdstR = crate :: BitReader ;
#[doc = "Field `ADST` writer - ADC start"] pub type AdstW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MODE` reader - ADC mode"] pub type ModeR = crate :: FieldReader ;
#[doc = "Field `MODE` writer - ADC mode"] pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ALIGN` reader - Data alignment"] pub type AlignR = crate :: BitReader ;
#[doc = "Field `ALIGN` writer - Data alignment"] pub type AlignW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMPCH` reader - Window comparison channel selection"] pub type CmpchR = crate :: FieldReader ;
#[doc = "Field `CMPCH` writer - Window comparison channel selection"] pub type CmpchW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `SCANDIR` reader - ADC scan direction"] pub type ScandirR = crate :: BitReader ;
#[doc = "Field `SCANDIR` writer - ADC scan direction"] pub type ScandirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TRGSELH` reader - External trigger selection high"] pub type TrgselhR = crate :: FieldReader ;
#[doc = "Field `TRGSELH` writer - External trigger selection high"] pub type TrgselhW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TRGSHIFT` reader - External trigger shift sample"] pub type TrgshiftR = crate :: FieldReader ;
#[doc = "Field `TRGSHIFT` writer - External trigger shift sample"] pub type TrgshiftW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `CALIBEN` reader - Self-calibration enable"] pub type CalibenR = crate :: BitReader ;
#[doc = "Field `CALIBEN` writer - Self-calibration enable"] pub type CalibenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CALIBSEL` reader - Self-calibration voltage selection"] pub type CalibselR = crate :: BitReader ;
#[doc = "Field `CALIBSEL` writer - Self-calibration voltage selection"] pub type CalibselW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - ADC interrupt enable"]
#[inline (always)] pub fn adie (& self) -> AdieR { AdieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ADC window comparator interrupt enable"]
#[inline (always)] pub fn adwie (& self) -> AdwieR { AdwieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - External trigger enable"]
#[inline (always)] pub fn trgen (& self) -> TrgenR { TrgenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Direct memory access enable"]
#[inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - External trigger selection low"]
#[inline (always)] pub fn trgsell (& self) -> TrgsellR { TrgsellR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 8 - ADC start"]
#[inline (always)] pub fn adst (& self) -> AdstR { AdstR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bits 9:10 - ADC mode"]
#[inline (always)] pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 9) & 3) as u8) }
#[doc = "Bit 11 - Data alignment"]
#[inline (always)] pub fn align (& self) -> AlignR { AlignR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:15 - Window comparison channel selection"]
#[inline (always)] pub fn cmpch (& self) -> CmpchR { CmpchR :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bit 16 - ADC scan direction"]
#[inline (always)] pub fn scandir (& self) -> ScandirR { ScandirR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bits 17:18 - External trigger selection high"]
#[inline (always)] pub fn trgselh (& self) -> TrgselhR { TrgselhR :: new (((self . bits >> 17) & 3) as u8) }
#[doc = "Bits 19:21 - External trigger shift sample"]
#[inline (always)] pub fn trgshift (& self) -> TrgshiftR { TrgshiftR :: new (((self . bits >> 19) & 7) as u8) }
#[doc = "Bit 22 - Self-calibration enable"]
#[inline (always)] pub fn caliben (& self) -> CalibenR { CalibenR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - Self-calibration voltage selection"]
#[inline (always)] pub fn calibsel (& self) -> CalibselR { CalibselR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 0 - ADC interrupt enable"]
#[inline (always)] pub fn adie (& mut self) -> AdieW < '_ , CrSpec > { AdieW :: new (self , 0) }
#[doc = "Bit 1 - ADC window comparator interrupt enable"]
#[inline (always)] pub fn adwie (& mut self) -> AdwieW < '_ , CrSpec > { AdwieW :: new (self , 1) }
#[doc = "Bit 2 - External trigger enable"]
#[inline (always)] pub fn trgen (& mut self) -> TrgenW < '_ , CrSpec > { TrgenW :: new (self , 2) }
#[doc = "Bit 3 - Direct memory access enable"]
#[inline (always)] pub fn dmaen (& mut self) -> DmaenW < '_ , CrSpec > { DmaenW :: new (self , 3) }
#[doc = "Bits 4:6 - External trigger selection low"]
#[inline (always)] pub fn trgsell (& mut self) -> TrgsellW < '_ , CrSpec > { TrgsellW :: new (self , 4) }
#[doc = "Bit 8 - ADC start"]
#[inline (always)] pub fn adst (& mut self) -> AdstW < '_ , CrSpec > { AdstW :: new (self , 8) }
#[doc = "Bits 9:10 - ADC mode"]
#[inline (always)] pub fn mode (& mut self) -> ModeW < '_ , CrSpec > { ModeW :: new (self , 9) }
#[doc = "Bit 11 - Data alignment"]
#[inline (always)] pub fn align (& mut self) -> AlignW < '_ , CrSpec > { AlignW :: new (self , 11) }
#[doc = "Bits 12:15 - Window comparison channel selection"]
#[inline (always)] pub fn cmpch (& mut self) -> CmpchW < '_ , CrSpec > { CmpchW :: new (self , 12) }
#[doc = "Bit 16 - ADC scan direction"]
#[inline (always)] pub fn scandir (& mut self) -> ScandirW < '_ , CrSpec > { ScandirW :: new (self , 16) }
#[doc = "Bits 17:18 - External trigger selection high"]
#[inline (always)] pub fn trgselh (& mut self) -> TrgselhW < '_ , CrSpec > { TrgselhW :: new (self , 17) }
#[doc = "Bits 19:21 - External trigger shift sample"]
#[inline (always)] pub fn trgshift (& mut self) -> TrgshiftW < '_ , CrSpec > { TrgshiftW :: new (self , 19) }
#[doc = "Bit 22 - Self-calibration enable"]
#[inline (always)] pub fn caliben (& mut self) -> CalibenW < '_ , CrSpec > { CalibenW :: new (self , 22) }
#[doc = "Bit 23 - Self-calibration voltage selection"]
#[inline (always)] pub fn calibsel (& mut self) -> CalibselW < '_ , CrSpec > { CalibselW :: new (self , 23) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "CHSR (rw) register accessor: Channel select register\n\nYou can [`read`](crate::Reg::read) this register and get [`chsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@chsr`] module"]
#[doc (alias = "CHSR")] pub type Chsr = crate :: Reg < chsr :: ChsrSpec > ;
#[doc = "Channel select register"] pub mod chsr {
#[doc = "Register `CHSR` reader"] pub type R = crate :: R < ChsrSpec > ;
#[doc = "Register `CHSR` writer"] pub type W = crate :: W < ChsrSpec > ;
#[doc = "Field `CH0EN` reader - Analog input channel 0 enable"] pub type Ch0enR = crate :: BitReader ;
#[doc = "Field `CH0EN` writer - Analog input channel 0 enable"] pub type Ch0enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH1EN` reader - Analog input channel 1 enable"] pub type Ch1enR = crate :: BitReader ;
#[doc = "Field `CH1EN` writer - Analog input channel 1 enable"] pub type Ch1enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH2EN` reader - Analog input channel 2 enable"] pub type Ch2enR = crate :: BitReader ;
#[doc = "Field `CH2EN` writer - Analog input channel 2 enable"] pub type Ch2enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH3EN` reader - Analog input channel 3 enable"] pub type Ch3enR = crate :: BitReader ;
#[doc = "Field `CH3EN` writer - Analog input channel 3 enable"] pub type Ch3enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH4EN` reader - Analog input channel 4 enable"] pub type Ch4enR = crate :: BitReader ;
#[doc = "Field `CH4EN` writer - Analog input channel 4 enable"] pub type Ch4enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH5EN` reader - Analog input channel 5 enable"] pub type Ch5enR = crate :: BitReader ;
#[doc = "Field `CH5EN` writer - Analog input channel 5 enable"] pub type Ch5enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH6EN` reader - Analog input channel 6 enable"] pub type Ch6enR = crate :: BitReader ;
#[doc = "Field `CH6EN` writer - Analog input channel 6 enable"] pub type Ch6enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH7EN` reader - Analog input channel 7 enable"] pub type Ch7enR = crate :: BitReader ;
#[doc = "Field `CH7EN` writer - Analog input channel 7 enable"] pub type Ch7enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH8EN` reader - Analog input channel 8 enable"] pub type Ch8enR = crate :: BitReader ;
#[doc = "Field `CH8EN` writer - Analog input channel 8 enable"] pub type Ch8enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH9EN` reader - Analog input channel 9 enable"] pub type Ch9enR = crate :: BitReader ;
#[doc = "Field `CH9EN` writer - Analog input channel 9 enable"] pub type Ch9enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH10EN` reader - Analog input channel 10 enable"] pub type Ch10enR = crate :: BitReader ;
#[doc = "Field `CH10EN` writer - Analog input channel 10 enable"] pub type Ch10enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH11EN` reader - Analog input channel 11 enable"] pub type Ch11enR = crate :: BitReader ;
#[doc = "Field `CH11EN` writer - Analog input channel 11 enable"] pub type Ch11enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHCALIB` reader - Enable ADC internal self-calibration channel"] pub type ChcalibR = crate :: BitReader ;
#[doc = "Field `CHCALIB` writer - Enable ADC internal self-calibration channel"] pub type ChcalibW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTSEN` reader - Temperature Sensor channel enable"] pub type ChtsenR = crate :: BitReader ;
#[doc = "Field `CHTSEN` writer - Temperature Sensor channel enable"] pub type ChtsenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHVSEN` reader - Internal reference voltage channel enable"] pub type ChvsenR = crate :: BitReader ;
#[doc = "Field `CHVSEN` writer - Internal reference voltage channel enable"] pub type ChvsenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Analog input channel 0 enable"]
#[inline (always)] pub fn ch0en (& self) -> Ch0enR { Ch0enR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Analog input channel 1 enable"]
#[inline (always)] pub fn ch1en (& self) -> Ch1enR { Ch1enR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Analog input channel 2 enable"]
#[inline (always)] pub fn ch2en (& self) -> Ch2enR { Ch2enR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Analog input channel 3 enable"]
#[inline (always)] pub fn ch3en (& self) -> Ch3enR { Ch3enR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Analog input channel 4 enable"]
#[inline (always)] pub fn ch4en (& self) -> Ch4enR { Ch4enR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Analog input channel 5 enable"]
#[inline (always)] pub fn ch5en (& self) -> Ch5enR { Ch5enR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Analog input channel 6 enable"]
#[inline (always)] pub fn ch6en (& self) -> Ch6enR { Ch6enR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Analog input channel 7 enable"]
#[inline (always)] pub fn ch7en (& self) -> Ch7enR { Ch7enR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Analog input channel 8 enable"]
#[inline (always)] pub fn ch8en (& self) -> Ch8enR { Ch8enR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Analog input channel 9 enable"]
#[inline (always)] pub fn ch9en (& self) -> Ch9enR { Ch9enR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Analog input channel 10 enable"]
#[inline (always)] pub fn ch10en (& self) -> Ch10enR { Ch10enR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Analog input channel 11 enable"]
#[inline (always)] pub fn ch11en (& self) -> Ch11enR { Ch11enR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 13 - Enable ADC internal self-calibration channel"]
#[inline (always)] pub fn chcalib (& self) -> ChcalibR { ChcalibR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Temperature Sensor channel enable"]
#[inline (always)] pub fn chtsen (& self) -> ChtsenR { ChtsenR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Internal reference voltage channel enable"]
#[inline (always)] pub fn chvsen (& self) -> ChvsenR { ChvsenR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Analog input channel 0 enable"]
#[inline (always)] pub fn ch0en (& mut self) -> Ch0enW < '_ , ChsrSpec > { Ch0enW :: new (self , 0) }
#[doc = "Bit 1 - Analog input channel 1 enable"]
#[inline (always)] pub fn ch1en (& mut self) -> Ch1enW < '_ , ChsrSpec > { Ch1enW :: new (self , 1) }
#[doc = "Bit 2 - Analog input channel 2 enable"]
#[inline (always)] pub fn ch2en (& mut self) -> Ch2enW < '_ , ChsrSpec > { Ch2enW :: new (self , 2) }
#[doc = "Bit 3 - Analog input channel 3 enable"]
#[inline (always)] pub fn ch3en (& mut self) -> Ch3enW < '_ , ChsrSpec > { Ch3enW :: new (self , 3) }
#[doc = "Bit 4 - Analog input channel 4 enable"]
#[inline (always)] pub fn ch4en (& mut self) -> Ch4enW < '_ , ChsrSpec > { Ch4enW :: new (self , 4) }
#[doc = "Bit 5 - Analog input channel 5 enable"]
#[inline (always)] pub fn ch5en (& mut self) -> Ch5enW < '_ , ChsrSpec > { Ch5enW :: new (self , 5) }
#[doc = "Bit 6 - Analog input channel 6 enable"]
#[inline (always)] pub fn ch6en (& mut self) -> Ch6enW < '_ , ChsrSpec > { Ch6enW :: new (self , 6) }
#[doc = "Bit 7 - Analog input channel 7 enable"]
#[inline (always)] pub fn ch7en (& mut self) -> Ch7enW < '_ , ChsrSpec > { Ch7enW :: new (self , 7) }
#[doc = "Bit 8 - Analog input channel 8 enable"]
#[inline (always)] pub fn ch8en (& mut self) -> Ch8enW < '_ , ChsrSpec > { Ch8enW :: new (self , 8) }
#[doc = "Bit 9 - Analog input channel 9 enable"]
#[inline (always)] pub fn ch9en (& mut self) -> Ch9enW < '_ , ChsrSpec > { Ch9enW :: new (self , 9) }
#[doc = "Bit 10 - Analog input channel 10 enable"]
#[inline (always)] pub fn ch10en (& mut self) -> Ch10enW < '_ , ChsrSpec > { Ch10enW :: new (self , 10) }
#[doc = "Bit 11 - Analog input channel 11 enable"]
#[inline (always)] pub fn ch11en (& mut self) -> Ch11enW < '_ , ChsrSpec > { Ch11enW :: new (self , 11) }
#[doc = "Bit 13 - Enable ADC internal self-calibration channel"]
#[inline (always)] pub fn chcalib (& mut self) -> ChcalibW < '_ , ChsrSpec > { ChcalibW :: new (self , 13) }
#[doc = "Bit 14 - Temperature Sensor channel enable"]
#[inline (always)] pub fn chtsen (& mut self) -> ChtsenW < '_ , ChsrSpec > { ChtsenW :: new (self , 14) }
#[doc = "Bit 15 - Internal reference voltage channel enable"]
#[inline (always)] pub fn chvsen (& mut self) -> ChvsenW < '_ , ChsrSpec > { ChvsenW :: new (self , 15) } }
#[doc = "Channel select register\n\nYou can [`read`](crate::Reg::read) this register and get [`chsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`chsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ChsrSpec ; impl crate :: RegisterSpec for ChsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`chsr::R`](R) reader structure"] impl crate :: Readable for ChsrSpec { }
#[doc = "`write(|w| ..)` method takes [`chsr::W`](W) writer structure"] impl crate :: Writable for ChsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CHSR to value 0"] impl crate :: Resettable for ChsrSpec { } }
#[doc = "CMPR (rw) register accessor: Compare register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmpr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmpr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmpr`] module"]
#[doc (alias = "CMPR")] pub type Cmpr = crate :: Reg < cmpr :: CmprSpec > ;
#[doc = "Compare register"] pub mod cmpr {
#[doc = "Register `CMPR` reader"] pub type R = crate :: R < CmprSpec > ;
#[doc = "Register `CMPR` writer"] pub type W = crate :: W < CmprSpec > ;
#[doc = "Field `CMPLDATA` reader - Compare data low limit"] pub type CmpldataR = crate :: FieldReader < u16 > ;
#[doc = "Field `CMPLDATA` writer - Compare data low limit"] pub type CmpldataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `CMPHDATA` reader - Compare data high limit"] pub type CmphdataR = crate :: FieldReader < u16 > ;
#[doc = "Field `CMPHDATA` writer - Compare data high limit"] pub type CmphdataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Compare data low limit"]
#[inline (always)] pub fn cmpldata (& self) -> CmpldataR { CmpldataR :: new ((self . bits & 0x0fff) as u16) }
#[doc = "Bits 16:27 - Compare data high limit"]
#[inline (always)] pub fn cmphdata (& self) -> CmphdataR { CmphdataR :: new (((self . bits >> 16) & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Compare data low limit"]
#[inline (always)] pub fn cmpldata (& mut self) -> CmpldataW < '_ , CmprSpec > { CmpldataW :: new (self , 0) }
#[doc = "Bits 16:27 - Compare data high limit"]
#[inline (always)] pub fn cmphdata (& mut self) -> CmphdataW < '_ , CmprSpec > { CmphdataW :: new (self , 16) } }
#[doc = "Compare register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmpr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmpr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CmprSpec ; impl crate :: RegisterSpec for CmprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmpr::R`](R) reader structure"] impl crate :: Readable for CmprSpec { }
#[doc = "`write(|w| ..)` method takes [`cmpr::W`](W) writer structure"] impl crate :: Writable for CmprSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMPR to value 0"] impl crate :: Resettable for CmprSpec { } }
#[doc = "SR (r) register accessor: Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `ADIF` reader - ADC interrupt flag"] pub type AdifR = crate :: BitReader ;
#[doc = "Field `ADWIF` reader - ADC window comparator interrupt flag"] pub type AdwifR = crate :: BitReader ;
#[doc = "Field `BUSY` reader - Busy"] pub type BusyR = crate :: BitReader ;
#[doc = "Field `CH` reader - Current conversion channel"] pub type ChR = crate :: FieldReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bit 0 - ADC interrupt flag"]
#[inline (always)] pub fn adif (& self) -> AdifR { AdifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ADC window comparator interrupt flag"]
#[inline (always)] pub fn adwif (& self) -> AdwifR { AdwifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Busy"]
#[inline (always)] pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 4:7 - Current conversion channel"]
#[inline (always)] pub fn ch (& self) -> ChR { ChR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:19 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 8) & 0x0fff) as u16) }
#[doc = "Bits 20:31 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 0x0fff) as u16) } }
#[doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "CH0DR (r) register accessor: Channel 0 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch0dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch0dr`] module"]
#[doc (alias = "CH0DR")] pub type Ch0dr = crate :: Reg < ch0dr :: Ch0drSpec > ;
#[doc = "Channel 0 data register"] pub mod ch0dr {
#[doc = "Register `CH0DR` reader"] pub type R = crate :: R < Ch0drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 0 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch0dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch0drSpec ; impl crate :: RegisterSpec for Ch0drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch0dr::R`](R) reader structure"] impl crate :: Readable for Ch0drSpec { }
#[doc = "`reset()` method sets CH0DR to value 0"] impl crate :: Resettable for Ch0drSpec { } }
#[doc = "CH1DR (r) register accessor: Channel 1 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1dr`] module"]
#[doc (alias = "CH1DR")] pub type Ch1dr = crate :: Reg < ch1dr :: Ch1drSpec > ;
#[doc = "Channel 1 data register"] pub mod ch1dr {
#[doc = "Register `CH1DR` reader"] pub type R = crate :: R < Ch1drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 1 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch1drSpec ; impl crate :: RegisterSpec for Ch1drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch1dr::R`](R) reader structure"] impl crate :: Readable for Ch1drSpec { }
#[doc = "`reset()` method sets CH1DR to value 0"] impl crate :: Resettable for Ch1drSpec { } }
#[doc = "CH2DR (r) register accessor: Channel 2 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2dr`] module"]
#[doc (alias = "CH2DR")] pub type Ch2dr = crate :: Reg < ch2dr :: Ch2drSpec > ;
#[doc = "Channel 2 data register"] pub mod ch2dr {
#[doc = "Register `CH2DR` reader"] pub type R = crate :: R < Ch2drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 2 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch2drSpec ; impl crate :: RegisterSpec for Ch2drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch2dr::R`](R) reader structure"] impl crate :: Readable for Ch2drSpec { }
#[doc = "`reset()` method sets CH2DR to value 0"] impl crate :: Resettable for Ch2drSpec { } }
#[doc = "CH3DR (r) register accessor: Channel 3 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3dr`] module"]
#[doc (alias = "CH3DR")] pub type Ch3dr = crate :: Reg < ch3dr :: Ch3drSpec > ;
#[doc = "Channel 3 data register"] pub mod ch3dr {
#[doc = "Register `CH3DR` reader"] pub type R = crate :: R < Ch3drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 3 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch3drSpec ; impl crate :: RegisterSpec for Ch3drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch3dr::R`](R) reader structure"] impl crate :: Readable for Ch3drSpec { }
#[doc = "`reset()` method sets CH3DR to value 0"] impl crate :: Resettable for Ch3drSpec { } }
#[doc = "CH4DR (r) register accessor: Channel 4 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4dr`] module"]
#[doc (alias = "CH4DR")] pub type Ch4dr = crate :: Reg < ch4dr :: Ch4drSpec > ;
#[doc = "Channel 4 data register"] pub mod ch4dr {
#[doc = "Register `CH4DR` reader"] pub type R = crate :: R < Ch4drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 4 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch4drSpec ; impl crate :: RegisterSpec for Ch4drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch4dr::R`](R) reader structure"] impl crate :: Readable for Ch4drSpec { }
#[doc = "`reset()` method sets CH4DR to value 0"] impl crate :: Resettable for Ch4drSpec { } }
#[doc = "CH5DR (r) register accessor: Channel 5 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch5dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch5dr`] module"]
#[doc (alias = "CH5DR")] pub type Ch5dr = crate :: Reg < ch5dr :: Ch5drSpec > ;
#[doc = "Channel 5 data register"] pub mod ch5dr {
#[doc = "Register `CH5DR` reader"] pub type R = crate :: R < Ch5drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 5 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch5dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch5drSpec ; impl crate :: RegisterSpec for Ch5drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch5dr::R`](R) reader structure"] impl crate :: Readable for Ch5drSpec { }
#[doc = "`reset()` method sets CH5DR to value 0"] impl crate :: Resettable for Ch5drSpec { } }
#[doc = "CH6DR (r) register accessor: Channel 6 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch6dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch6dr`] module"]
#[doc (alias = "CH6DR")] pub type Ch6dr = crate :: Reg < ch6dr :: Ch6drSpec > ;
#[doc = "Channel 6 data register"] pub mod ch6dr {
#[doc = "Register `CH6DR` reader"] pub type R = crate :: R < Ch6drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 6 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch6dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch6drSpec ; impl crate :: RegisterSpec for Ch6drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch6dr::R`](R) reader structure"] impl crate :: Readable for Ch6drSpec { }
#[doc = "`reset()` method sets CH6DR to value 0"] impl crate :: Resettable for Ch6drSpec { } }
#[doc = "CH7DR (r) register accessor: Channel 7 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch7dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch7dr`] module"]
#[doc (alias = "CH7DR")] pub type Ch7dr = crate :: Reg < ch7dr :: Ch7drSpec > ;
#[doc = "Channel 7 data register"] pub mod ch7dr {
#[doc = "Register `CH7DR` reader"] pub type R = crate :: R < Ch7drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 7 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch7dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch7drSpec ; impl crate :: RegisterSpec for Ch7drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch7dr::R`](R) reader structure"] impl crate :: Readable for Ch7drSpec { }
#[doc = "`reset()` method sets CH7DR to value 0"] impl crate :: Resettable for Ch7drSpec { } }
#[doc = "CH8DR (r) register accessor: Channel 8 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch8dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch8dr`] module"]
#[doc (alias = "CH8DR")] pub type Ch8dr = crate :: Reg < ch8dr :: Ch8drSpec > ;
#[doc = "Channel 8 data register"] pub mod ch8dr {
#[doc = "Register `CH8DR` reader"] pub type R = crate :: R < Ch8drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 8 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch8dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch8drSpec ; impl crate :: RegisterSpec for Ch8drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch8dr::R`](R) reader structure"] impl crate :: Readable for Ch8drSpec { }
#[doc = "`reset()` method sets CH8DR to value 0"] impl crate :: Resettable for Ch8drSpec { } }
#[doc = "CH9DR (r) register accessor: Channel 9 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch9dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch9dr`] module"]
#[doc (alias = "CH9DR")] pub type Ch9dr = crate :: Reg < ch9dr :: Ch9drSpec > ;
#[doc = "Channel 9 data register"] pub mod ch9dr {
#[doc = "Register `CH9DR` reader"] pub type R = crate :: R < Ch9drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 9 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch9dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch9drSpec ; impl crate :: RegisterSpec for Ch9drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch9dr::R`](R) reader structure"] impl crate :: Readable for Ch9drSpec { }
#[doc = "`reset()` method sets CH9DR to value 0"] impl crate :: Resettable for Ch9drSpec { } }
#[doc = "CH10DR (r) register accessor: Channel 10 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch10dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch10dr`] module"]
#[doc (alias = "CH10DR")] pub type Ch10dr = crate :: Reg < ch10dr :: Ch10drSpec > ;
#[doc = "Channel 10 data register"] pub mod ch10dr {
#[doc = "Register `CH10DR` reader"] pub type R = crate :: R < Ch10drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 10 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch10dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch10drSpec ; impl crate :: RegisterSpec for Ch10drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch10dr::R`](R) reader structure"] impl crate :: Readable for Ch10drSpec { }
#[doc = "`reset()` method sets CH10DR to value 0"] impl crate :: Resettable for Ch10drSpec { } }
#[doc = "CH11DR (r) register accessor: Channel 11 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch11dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch11dr`] module"]
#[doc (alias = "CH11DR")] pub type Ch11dr = crate :: Reg < ch11dr :: Ch11drSpec > ;
#[doc = "Channel 11 data register"] pub mod ch11dr {
#[doc = "Register `CH11DR` reader"] pub type R = crate :: R < Ch11drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 11 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch11dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch11drSpec ; impl crate :: RegisterSpec for Ch11drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch11dr::R`](R) reader structure"] impl crate :: Readable for Ch11drSpec { }
#[doc = "`reset()` method sets CH11DR to value 0"] impl crate :: Resettable for Ch11drSpec { } }
#[doc = "CH12DR (r) register accessor: Channel 12 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch12dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch12dr`] module"]
#[doc (alias = "CH12DR")] pub type Ch12dr = crate :: Reg < ch12dr :: Ch12drSpec > ;
#[doc = "Channel 12 data register"] pub mod ch12dr {
#[doc = "Register `CH12DR` reader"] pub type R = crate :: R < Ch12drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 12 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch12dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch12drSpec ; impl crate :: RegisterSpec for Ch12drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch12dr::R`](R) reader structure"] impl crate :: Readable for Ch12drSpec { }
#[doc = "`reset()` method sets CH12DR to value 0"] impl crate :: Resettable for Ch12drSpec { } }
#[doc = "CH14DR (r) register accessor: Channel 14 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch14dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch14dr`] module"]
#[doc (alias = "CH14DR")] pub type Ch14dr = crate :: Reg < ch14dr :: Ch14drSpec > ;
#[doc = "Channel 14 data register"] pub mod ch14dr {
#[doc = "Register `CH14DR` reader"] pub type R = crate :: R < Ch14drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 14 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch14dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch14drSpec ; impl crate :: RegisterSpec for Ch14drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch14dr::R`](R) reader structure"] impl crate :: Readable for Ch14drSpec { }
#[doc = "`reset()` method sets CH14DR to value 0"] impl crate :: Resettable for Ch14drSpec { } }
#[doc = "CH15DR (r) register accessor: Channel 15 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch15dr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch15dr`] module"]
#[doc (alias = "CH15DR")] pub type Ch15dr = crate :: Reg < ch15dr :: Ch15drSpec > ;
#[doc = "Channel 15 data register"] pub mod ch15dr {
#[doc = "Register `CH15DR` reader"] pub type R = crate :: R < Ch15drSpec > ;
#[doc = "Field `DATA` reader - Transfer data"] pub type DataR = crate :: FieldReader < u16 > ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: BitReader ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: BitReader ; impl R {
#[doc = "Bits 0:15 - Transfer data"]
#[inline (always)] pub fn data (& self) -> DataR { DataR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 20 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new (((self . bits >> 21) & 1) != 0) } }
#[doc = "Channel 15 data register\n\nYou can [`read`](crate::Reg::read) this register and get [`ch15dr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ch15drSpec ; impl crate :: RegisterSpec for Ch15drSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ch15dr::R`](R) reader structure"] impl crate :: Readable for Ch15drSpec { }
#[doc = "`reset()` method sets CH15DR to value 0"] impl crate :: Resettable for Ch15drSpec { } }
#[doc = "STA_EXT (r) register accessor: Extended status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sta_ext::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sta_ext`] module"]
#[doc (alias = "STA_EXT")] pub type StaExt = crate :: Reg < sta_ext :: StaExtSpec > ;
#[doc = "Extended status register"] pub mod sta_ext {
#[doc = "Register `STA_EXT` reader"] pub type R = crate :: R < StaExtSpec > ;
#[doc = "Field `VALID` reader - Valid flag"] pub type ValidR = crate :: FieldReader ;
#[doc = "Field `OVERRUN` reader - Overrun flag"] pub type OverrunR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Valid flag"]
#[inline (always)] pub fn valid (& self) -> ValidR { ValidR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Overrun flag"]
#[inline (always)] pub fn overrun (& self) -> OverrunR { OverrunR :: new (((self . bits >> 4) & 0x0f) as u8) } }
#[doc = "Extended status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sta_ext::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct StaExtSpec ; impl crate :: RegisterSpec for StaExtSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sta_ext::R`](R) reader structure"] impl crate :: Readable for StaExtSpec { }
#[doc = "`reset()` method sets STA_EXT to value 0"] impl crate :: Resettable for StaExtSpec { } } }
#[doc = "comparator"] pub type Comp = crate :: Periph < comp :: RegisterBlock , 0x4001_3c00 > ; impl core :: fmt :: Debug for Comp { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Comp") . finish () } }
#[doc = "comparator"] pub mod comp {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { comp1_csr : Comp1Csr , _reserved1 : [u8 ; 0x14] , comp_crv : CompCrv , comp1_poll : Comp1Poll , } impl RegisterBlock {
#[doc = "0x00 - COMP1_CSR"]
#[inline (always)] pub const fn comp1_csr (& self) -> & Comp1Csr { & self . comp1_csr }
#[doc = "0x18 - COMP_CRV"]
#[inline (always)] pub const fn comp_crv (& self) -> & CompCrv { & self . comp_crv }
#[doc = "0x1c - COMP1_POLL"]
#[inline (always)] pub const fn comp1_poll (& self) -> & Comp1Poll { & self . comp1_poll } }
#[doc = "COMP1_CSR (rw) register accessor: COMP1_CSR\n\nYou can [`read`](crate::Reg::read) this register and get [`comp1_csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp1_csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@comp1_csr`] module"]
#[doc (alias = "COMP1_CSR")] pub type Comp1Csr = crate :: Reg < comp1_csr :: Comp1CsrSpec > ;
#[doc = "COMP1_CSR"] pub mod comp1_csr {
#[doc = "Register `COMP1_CSR` reader"] pub type R = crate :: R < Comp1CsrSpec > ;
#[doc = "Register `COMP1_CSR` writer"] pub type W = crate :: W < Comp1CsrSpec > ;
#[doc = "Field `EN` reader - Comparator 1 enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Comparator 1 enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MODE` reader - Comparator 1 mode"] pub type ModeR = crate :: FieldReader ;
#[doc = "Field `MODE` writer - Comparator 1 mode"] pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `INM` reader - Comparator 1 inverting input selection"] pub type InmR = crate :: FieldReader ;
#[doc = "Field `INM` writer - Comparator 1 inverting input selection"] pub type InmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `INP` reader - Comparator 1 normal phase input selection"] pub type InpR = crate :: FieldReader ;
#[doc = "Field `INP` writer - Comparator 1 normal phase input selection"] pub type InpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OUT` reader - Comparator 1 output selection"] pub type OutR = crate :: FieldReader ;
#[doc = "Field `OUT` writer - Comparator 1 output selection"] pub type OutW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `POL` reader - Comparator 1 output polarity"] pub type PolR = crate :: BitReader ;
#[doc = "Field `POL` writer - Comparator 1 output polarity"] pub type PolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HYST` reader - Comparator 1 hysteresis"] pub type HystR = crate :: FieldReader ;
#[doc = "Field `HYST` writer - Comparator 1 hysteresis"] pub type HystW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OFLT` reader - Comparator 1 output filter"] pub type OfltR = crate :: FieldReader ;
#[doc = "Field `OFLT` writer - Comparator 1 output filter"] pub type OfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `STA` reader - Comparator 1 output status"] pub type StaR = crate :: BitReader ;
#[doc = "Field `STA` writer - Comparator 1 output status"] pub type StaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LOCK` reader - Comparator 1 lock"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - Comparator 1 lock"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Comparator 1 enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 2:3 - Comparator 1 mode"]
#[inline (always)] pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Comparator 1 inverting input selection"]
#[inline (always)] pub fn inm (& self) -> InmR { InmR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 7:8 - Comparator 1 normal phase input selection"]
#[inline (always)] pub fn inp (& self) -> InpR { InpR :: new (((self . bits >> 7) & 3) as u8) }
#[doc = "Bits 10:13 - Comparator 1 output selection"]
#[inline (always)] pub fn out (& self) -> OutR { OutR :: new (((self . bits >> 10) & 0x0f) as u8) }
#[doc = "Bit 15 - Comparator 1 output polarity"]
#[inline (always)] pub fn pol (& self) -> PolR { PolR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bits 16:17 - Comparator 1 hysteresis"]
#[inline (always)] pub fn hyst (& self) -> HystR { HystR :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:20 - Comparator 1 output filter"]
#[inline (always)] pub fn oflt (& self) -> OfltR { OfltR :: new (((self . bits >> 18) & 7) as u8) }
#[doc = "Bit 30 - Comparator 1 output status"]
#[inline (always)] pub fn sta (& self) -> StaR { StaR :: new (((self . bits >> 30) & 1) != 0) }
#[doc = "Bit 31 - Comparator 1 lock"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Comparator 1 enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Comp1CsrSpec > { EnW :: new (self , 0) }
#[doc = "Bits 2:3 - Comparator 1 mode"]
#[inline (always)] pub fn mode (& mut self) -> ModeW < '_ , Comp1CsrSpec > { ModeW :: new (self , 2) }
#[doc = "Bits 4:5 - Comparator 1 inverting input selection"]
#[inline (always)] pub fn inm (& mut self) -> InmW < '_ , Comp1CsrSpec > { InmW :: new (self , 4) }
#[doc = "Bits 7:8 - Comparator 1 normal phase input selection"]
#[inline (always)] pub fn inp (& mut self) -> InpW < '_ , Comp1CsrSpec > { InpW :: new (self , 7) }
#[doc = "Bits 10:13 - Comparator 1 output selection"]
#[inline (always)] pub fn out (& mut self) -> OutW < '_ , Comp1CsrSpec > { OutW :: new (self , 10) }
#[doc = "Bit 15 - Comparator 1 output polarity"]
#[inline (always)] pub fn pol (& mut self) -> PolW < '_ , Comp1CsrSpec > { PolW :: new (self , 15) }
#[doc = "Bits 16:17 - Comparator 1 hysteresis"]
#[inline (always)] pub fn hyst (& mut self) -> HystW < '_ , Comp1CsrSpec > { HystW :: new (self , 16) }
#[doc = "Bits 18:20 - Comparator 1 output filter"]
#[inline (always)] pub fn oflt (& mut self) -> OfltW < '_ , Comp1CsrSpec > { OfltW :: new (self , 18) }
#[doc = "Bit 30 - Comparator 1 output status"]
#[inline (always)] pub fn sta (& mut self) -> StaW < '_ , Comp1CsrSpec > { StaW :: new (self , 30) }
#[doc = "Bit 31 - Comparator 1 lock"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , Comp1CsrSpec > { LockW :: new (self , 31) } }
#[doc = "COMP1_CSR\n\nYou can [`read`](crate::Reg::read) this register and get [`comp1_csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp1_csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Comp1CsrSpec ; impl crate :: RegisterSpec for Comp1CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`comp1_csr::R`](R) reader structure"] impl crate :: Readable for Comp1CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`comp1_csr::W`](W) writer structure"] impl crate :: Writable for Comp1CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COMP1_CSR to value 0"] impl crate :: Resettable for Comp1CsrSpec { } }
#[doc = "COMP_CRV (rw) register accessor: COMP_CRV\n\nYou can [`read`](crate::Reg::read) this register and get [`comp_crv::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp_crv::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@comp_crv`] module"]
#[doc (alias = "COMP_CRV")] pub type CompCrv = crate :: Reg < comp_crv :: CompCrvSpec > ;
#[doc = "COMP_CRV"] pub mod comp_crv {
#[doc = "Register `COMP_CRV` reader"] pub type R = crate :: R < CompCrvSpec > ;
#[doc = "Register `COMP_CRV` writer"] pub type W = crate :: W < CompCrvSpec > ;
#[doc = "Field `CRV_SEL` reader - Comparator external referencevoltage select"] pub type CrvSelR = crate :: FieldReader ;
#[doc = "Field `CRV_SEL` writer - Comparator external referencevoltage select"] pub type CrvSelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EN` reader - Comparator external referencevoltage enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Comparator external referencevoltage enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRV_SRC` reader - Comparator external refer-ence voltage source select"] pub type CrvSrcR = crate :: BitReader ;
#[doc = "Field `CRV_SRC` writer - Comparator external refer-ence voltage source select"] pub type CrvSrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:3 - Comparator external referencevoltage select"]
#[inline (always)] pub fn crv_sel (& self) -> CrvSelR { CrvSelR :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bit 4 - Comparator external referencevoltage enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Comparator external refer-ence voltage source select"]
#[inline (always)] pub fn crv_src (& self) -> CrvSrcR { CrvSrcR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bits 0:3 - Comparator external referencevoltage select"]
#[inline (always)] pub fn crv_sel (& mut self) -> CrvSelW < '_ , CompCrvSpec > { CrvSelW :: new (self , 0) }
#[doc = "Bit 4 - Comparator external referencevoltage enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , CompCrvSpec > { EnW :: new (self , 4) }
#[doc = "Bit 5 - Comparator external refer-ence voltage source select"]
#[inline (always)] pub fn crv_src (& mut self) -> CrvSrcW < '_ , CompCrvSpec > { CrvSrcW :: new (self , 5) } }
#[doc = "COMP_CRV\n\nYou can [`read`](crate::Reg::read) this register and get [`comp_crv::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp_crv::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CompCrvSpec ; impl crate :: RegisterSpec for CompCrvSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`comp_crv::R`](R) reader structure"] impl crate :: Readable for CompCrvSpec { }
#[doc = "`write(|w| ..)` method takes [`comp_crv::W`](W) writer structure"] impl crate :: Writable for CompCrvSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COMP_CRV to value 0"] impl crate :: Resettable for CompCrvSpec { } }
#[doc = "COMP1_POLL (rw) register accessor: COMP1_POLL\n\nYou can [`read`](crate::Reg::read) this register and get [`comp1_poll::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp1_poll::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@comp1_poll`] module"]
#[doc (alias = "COMP1_POLL")] pub type Comp1Poll = crate :: Reg < comp1_poll :: Comp1PollSpec > ;
#[doc = "COMP1_POLL"] pub mod comp1_poll {
#[doc = "Register `COMP1_POLL` reader"] pub type R = crate :: R < Comp1PollSpec > ;
#[doc = "Register `COMP1_POLL` writer"] pub type W = crate :: W < Comp1PollSpec > ;
#[doc = "Field `EN` reader - Comparator 1 polling enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Comparator 1 polling enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CH` reader - Comparator 1 polling channel"] pub type ChR = crate :: BitReader ;
#[doc = "Field `CH` writer - Comparator 1 polling channel"] pub type ChW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FIXN` reader - Comparator 1 Polling inverting input fix"] pub type FixnR = crate :: BitReader ;
#[doc = "Field `FIXN` writer - Comparator 1 Polling inverting input fix"] pub type FixnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PERIOD` reader - Comparator 1 polling wait cycle"] pub type PeriodR = crate :: FieldReader ;
#[doc = "Field `PERIOD` writer - Comparator 1 polling wait cycle"] pub type PeriodW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `POUT` reader - Comparator 1 Polling output"] pub type PoutR = crate :: FieldReader ;
#[doc = "Field `POUT` writer - Comparator 1 Polling output"] pub type PoutW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bit 0 - Comparator 1 polling enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Comparator 1 polling channel"]
#[inline (always)] pub fn ch (& self) -> ChR { ChR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Comparator 1 Polling inverting input fix"]
#[inline (always)] pub fn fixn (& self) -> FixnR { FixnR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 4:6 - Comparator 1 polling wait cycle"]
#[inline (always)] pub fn period (& self) -> PeriodR { PeriodR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bits 8:10 - Comparator 1 Polling output"]
#[inline (always)] pub fn pout (& self) -> PoutR { PoutR :: new (((self . bits >> 8) & 7) as u8) } } impl W {
#[doc = "Bit 0 - Comparator 1 polling enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Comp1PollSpec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Comparator 1 polling channel"]
#[inline (always)] pub fn ch (& mut self) -> ChW < '_ , Comp1PollSpec > { ChW :: new (self , 1) }
#[doc = "Bit 2 - Comparator 1 Polling inverting input fix"]
#[inline (always)] pub fn fixn (& mut self) -> FixnW < '_ , Comp1PollSpec > { FixnW :: new (self , 2) }
#[doc = "Bits 4:6 - Comparator 1 polling wait cycle"]
#[inline (always)] pub fn period (& mut self) -> PeriodW < '_ , Comp1PollSpec > { PeriodW :: new (self , 4) }
#[doc = "Bits 8:10 - Comparator 1 Polling output"]
#[inline (always)] pub fn pout (& mut self) -> PoutW < '_ , Comp1PollSpec > { PoutW :: new (self , 8) } }
#[doc = "COMP1_POLL\n\nYou can [`read`](crate::Reg::read) this register and get [`comp1_poll::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`comp1_poll::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Comp1PollSpec ; impl crate :: RegisterSpec for Comp1PollSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`comp1_poll::R`](R) reader structure"] impl crate :: Readable for Comp1PollSpec { }
#[doc = "`write(|w| ..)` method takes [`comp1_poll::W`](W) writer structure"] impl crate :: Writable for Comp1PollSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets COMP1_POLL to value 0"] impl crate :: Resettable for Comp1PollSpec { } } }
#[doc = "CRC calculation unit"] pub type Crc = crate :: Periph < crc :: RegisterBlock , 0x4002_3000 > ; impl core :: fmt :: Debug for Crc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crc") . finish () } }
#[doc = "CRC calculation unit"] pub mod crc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { dr : Dr , idr : Idr , cr : Cr , } impl RegisterBlock {
#[doc = "0x00 - Data register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x04 - Independent data register"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x08 - Control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr } }
#[doc = "DR (rw) register accessor: Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "Data register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DR` reader - Data register bits"] pub type DrR = crate :: FieldReader < u32 > ;
#[doc = "Field `DR` writer - Data register bits"] pub type DrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Data register bits"]
#[inline (always)] pub fn dr (& self) -> DrR { DrR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Data register bits"]
#[inline (always)] pub fn dr (& mut self) -> DrW < '_ , DrSpec > { DrW :: new (self , 0) } }
#[doc = "Data register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0xffff_ffff"] impl crate :: Resettable for DrSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } }
#[doc = "IDR (rw) register accessor: Independent data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "Independent data register"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Register `IDR` writer"] pub type W = crate :: W < IdrSpec > ;
#[doc = "Field `IDR` reader - General-purpose 8-bit data register bits"] pub type IdrR = crate :: FieldReader ;
#[doc = "Field `IDR` writer - General-purpose 8-bit data register bits"] pub type IdrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - General-purpose 8-bit data register bits"]
#[inline (always)] pub fn idr (& self) -> IdrR { IdrR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - General-purpose 8-bit data register bits"]
#[inline (always)] pub fn idr (& mut self) -> IdrW < '_ , IdrSpec > { IdrW :: new (self , 0) } }
#[doc = "Independent data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`write(|w| ..)` method takes [`idr::W`](W) writer structure"] impl crate :: Writable for IdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "CR (w) register accessor: Control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register"] pub mod cr {
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `RESET` writer - CRC reset"] pub type ResetW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - CRC reset"]
#[inline (always)] pub fn reset (& mut self) -> ResetW < '_ , CrSpec > { ResetW :: new (self , 0) } }
#[doc = "Control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } } }
#[doc = "Debug support"] pub type Dbg = crate :: Periph < dbg :: RegisterBlock , 0x4001_3400 > ; impl core :: fmt :: Debug for Dbg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dbg") . finish () } }
#[doc = "Debug support"] pub mod dbg {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { idcode : Idcode , cr : Cr , } impl RegisterBlock {
#[doc = "0x00 - IDCODE"]
#[inline (always)] pub const fn idcode (& self) -> & Idcode { & self . idcode }
#[doc = "0x04 - CR"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr } }
#[doc = "IDCODE (r) register accessor: IDCODE\n\nYou can [`read`](crate::Reg::read) this register and get [`idcode::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idcode`] module"]
#[doc (alias = "IDCODE")] pub type Idcode = crate :: Reg < idcode :: IdcodeSpec > ;
#[doc = "IDCODE"] pub mod idcode {
#[doc = "Register `IDCODE` reader"] pub type R = crate :: R < IdcodeSpec > ;
#[doc = "Field `DEV_ID` reader - Device identifier"] pub type DevIdR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Device identifier"]
#[inline (always)] pub fn dev_id (& self) -> DevIdR { DevIdR :: new (self . bits) } }
#[doc = "IDCODE\n\nYou can [`read`](crate::Reg::read) this register and get [`idcode::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdcodeSpec ; impl crate :: RegisterSpec for IdcodeSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idcode::R`](R) reader structure"] impl crate :: Readable for IdcodeSpec { }
#[doc = "`reset()` method sets IDCODE to value 0"] impl crate :: Resettable for IdcodeSpec { } }
#[doc = "CR (w) register accessor: CR\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "CR"] pub mod cr {
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `DBG_SLEEP` writer - Debug Sleep mode"] pub type DbgSleepW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_STOP` writer - Debug Stop mode"] pub type DbgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_STANDBY` writer - Debug Standby mode"] pub type DbgStandbyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_IWDG_STOP` writer - Debug independent watchdog stopped when core is stopped"] pub type DbgIwdgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_WWDG_STOP` writer - Debug window watchdog when core is halted"] pub type DbgWwdgStopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBG_TIMx_STOP` writer - TIMx counter stopped when core is halted"] pub type DbgTimxStopW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl W {
#[doc = "Bit 0 - Debug Sleep mode"]
#[inline (always)] pub fn dbg_sleep (& mut self) -> DbgSleepW < '_ , CrSpec > { DbgSleepW :: new (self , 0) }
#[doc = "Bit 1 - Debug Stop mode"]
#[inline (always)] pub fn dbg_stop (& mut self) -> DbgStopW < '_ , CrSpec > { DbgStopW :: new (self , 1) }
#[doc = "Bit 2 - Debug Standby mode"]
#[inline (always)] pub fn dbg_standby (& mut self) -> DbgStandbyW < '_ , CrSpec > { DbgStandbyW :: new (self , 2) }
#[doc = "Bit 8 - Debug independent watchdog stopped when core is stopped"]
#[inline (always)] pub fn dbg_iwdg_stop (& mut self) -> DbgIwdgStopW < '_ , CrSpec > { DbgIwdgStopW :: new (self , 8) }
#[doc = "Bit 9 - Debug window watchdog when core is halted"]
#[inline (always)] pub fn dbg_wwdg_stop (& mut self) -> DbgWwdgStopW < '_ , CrSpec > { DbgWwdgStopW :: new (self , 9) }
#[doc = "Bits 10:13 - TIMx counter stopped when core is halted"]
#[inline (always)] pub fn dbg_timx_stop (& mut self) -> DbgTimxStopW < '_ , CrSpec > { DbgTimxStopW :: new (self , 10) } }
#[doc = "CR\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } } }
#[doc = "DEVICE"] pub type Device = crate :: Periph < device :: RegisterBlock , 0x1fff_f7e8 > ; impl core :: fmt :: Debug for Device { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Device") . finish () } }
#[doc = "DEVICE"] pub mod device {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { uid1 : Uid1 , uid2 : Uid2 , uid3 : Uid3 , uid4 : Uid4 , } impl RegisterBlock {
#[doc = "0x00 - Configuration register"]
#[inline (always)] pub const fn uid1 (& self) -> & Uid1 { & self . uid1 }
#[doc = "0x02 - Configuration register"]
#[inline (always)] pub const fn uid2 (& self) -> & Uid2 { & self . uid2 }
#[doc = "0x04 - Configuration register"]
#[inline (always)] pub const fn uid3 (& self) -> & Uid3 { & self . uid3 }
#[doc = "0x08 - Configuration register"]
#[inline (always)] pub const fn uid4 (& self) -> & Uid4 { & self . uid4 } }
#[doc = "UID1 (r) register accessor: Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`uid1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uid1`] module"]
#[doc (alias = "UID1")] pub type Uid1 = crate :: Reg < uid1 :: Uid1Spec > ;
#[doc = "Configuration register"] pub mod uid1 {
#[doc = "Register `UID1` reader"] pub type R = crate :: R < Uid1Spec > ;
#[doc = "Field `U_ID` reader - 15:0 unique ID bits"] pub type UIdR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - 15:0 unique ID bits"]
#[inline (always)] pub fn u_id (& self) -> UIdR { UIdR :: new (self . bits) } }
#[doc = "Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`uid1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Uid1Spec ; impl crate :: RegisterSpec for Uid1Spec { type Ux = u16 ; }
#[doc = "`read()` method returns [`uid1::R`](R) reader structure"] impl crate :: Readable for Uid1Spec { }
#[doc = "`reset()` method sets UID1 to value 0"] impl crate :: Resettable for Uid1Spec { } }
#[doc = "UID2 (r) register accessor: Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`uid2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uid2`] module"]
#[doc (alias = "UID2")] pub type Uid2 = crate :: Reg < uid2 :: Uid2Spec > ;
#[doc = "Configuration register"] pub mod uid2 {
#[doc = "Register `UID2` reader"] pub type R = crate :: R < Uid2Spec > ;
#[doc = "Field `U_ID` reader - 31:16 unique ID bits"] pub type UIdR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - 31:16 unique ID bits"]
#[inline (always)] pub fn u_id (& self) -> UIdR { UIdR :: new (self . bits) } }
#[doc = "Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`uid2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Uid2Spec ; impl crate :: RegisterSpec for Uid2Spec { type Ux = u16 ; }
#[doc = "`read()` method returns [`uid2::R`](R) reader structure"] impl crate :: Readable for Uid2Spec { }
#[doc = "`reset()` method sets UID2 to value 0"] impl crate :: Resettable for Uid2Spec { } }
#[doc = "UID3 (r) register accessor: Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`uid3::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uid3`] module"]
#[doc (alias = "UID3")] pub type Uid3 = crate :: Reg < uid3 :: Uid3Spec > ;
#[doc = "Configuration register"] pub mod uid3 {
#[doc = "Register `UID3` reader"] pub type R = crate :: R < Uid3Spec > ;
#[doc = "Field `U_ID` reader - 63:32 unique ID bits"] pub type UIdR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - 63:32 unique ID bits"]
#[inline (always)] pub fn u_id (& self) -> UIdR { UIdR :: new (self . bits) } }
#[doc = "Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`uid3::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Uid3Spec ; impl crate :: RegisterSpec for Uid3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`uid3::R`](R) reader structure"] impl crate :: Readable for Uid3Spec { }
#[doc = "`reset()` method sets UID3 to value 0"] impl crate :: Resettable for Uid3Spec { } }
#[doc = "UID4 (r) register accessor: Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`uid4::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uid4`] module"]
#[doc (alias = "UID4")] pub type Uid4 = crate :: Reg < uid4 :: Uid4Spec > ;
#[doc = "Configuration register"] pub mod uid4 {
#[doc = "Register `UID4` reader"] pub type R = crate :: R < Uid4Spec > ;
#[doc = "Field `U_ID` reader - 95:64 unique ID bits"] pub type UIdR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - 95:64 unique ID bits"]
#[inline (always)] pub fn u_id (& self) -> UIdR { UIdR :: new (self . bits) } }
#[doc = "Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`uid4::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Uid4Spec ; impl crate :: RegisterSpec for Uid4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`uid4::R`](R) reader structure"] impl crate :: Readable for Uid4Spec { }
#[doc = "`reset()` method sets UID4 to value 0"] impl crate :: Resettable for Uid4Spec { } } }
#[doc = "Hardware divider"] pub type Div = crate :: Periph < div :: RegisterBlock , 0x4003_0000 > ; impl core :: fmt :: Debug for Div { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Div") . finish () } }
#[doc = "Hardware divider"] pub mod div {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { dvdr : Dvdr , dvsr : Dvsr , quotr : Quotr , rmdr : Rmdr , sr : Sr , cr : Cr , } impl RegisterBlock {
#[doc = "0x00 - DVDR"]
#[inline (always)] pub const fn dvdr (& self) -> & Dvdr { & self . dvdr }
#[doc = "0x04 - DVSR"]
#[inline (always)] pub const fn dvsr (& self) -> & Dvsr { & self . dvsr }
#[doc = "0x08 - QUOTR"]
#[inline (always)] pub const fn quotr (& self) -> & Quotr { & self . quotr }
#[doc = "0x0c - RMDR"]
#[inline (always)] pub const fn rmdr (& self) -> & Rmdr { & self . rmdr }
#[doc = "0x10 - SR"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - CR"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr } }
#[doc = "DVDR (rw) register accessor: DVDR\n\nYou can [`read`](crate::Reg::read) this register and get [`dvdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dvdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dvdr`] module"]
#[doc (alias = "DVDR")] pub type Dvdr = crate :: Reg < dvdr :: DvdrSpec > ;
#[doc = "DVDR"] pub mod dvdr {
#[doc = "Register `DVDR` reader"] pub type R = crate :: R < DvdrSpec > ;
#[doc = "Register `DVDR` writer"] pub type W = crate :: W < DvdrSpec > ;
#[doc = "Field `DIVIDEND` reader - Dividend data"] pub type DividendR = crate :: FieldReader < u32 > ;
#[doc = "Field `DIVIDEND` writer - Dividend data"] pub type DividendW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Dividend data"]
#[inline (always)] pub fn dividend (& self) -> DividendR { DividendR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Dividend data"]
#[inline (always)] pub fn dividend (& mut self) -> DividendW < '_ , DvdrSpec > { DividendW :: new (self , 0) } }
#[doc = "DVDR\n\nYou can [`read`](crate::Reg::read) this register and get [`dvdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dvdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DvdrSpec ; impl crate :: RegisterSpec for DvdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dvdr::R`](R) reader structure"] impl crate :: Readable for DvdrSpec { }
#[doc = "`write(|w| ..)` method takes [`dvdr::W`](W) writer structure"] impl crate :: Writable for DvdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DVDR to value 0"] impl crate :: Resettable for DvdrSpec { } }
#[doc = "DVSR (rw) register accessor: DVSR\n\nYou can [`read`](crate::Reg::read) this register and get [`dvsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dvsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dvsr`] module"]
#[doc (alias = "DVSR")] pub type Dvsr = crate :: Reg < dvsr :: DvsrSpec > ;
#[doc = "DVSR"] pub mod dvsr {
#[doc = "Register `DVSR` reader"] pub type R = crate :: R < DvsrSpec > ;
#[doc = "Register `DVSR` writer"] pub type W = crate :: W < DvsrSpec > ;
#[doc = "Field `DIVISOR` reader - Divisor data"] pub type DivisorR = crate :: FieldReader < u32 > ;
#[doc = "Field `DIVISOR` writer - Divisor data"] pub type DivisorW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Divisor data"]
#[inline (always)] pub fn divisor (& self) -> DivisorR { DivisorR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Divisor data"]
#[inline (always)] pub fn divisor (& mut self) -> DivisorW < '_ , DvsrSpec > { DivisorW :: new (self , 0) } }
#[doc = "DVSR\n\nYou can [`read`](crate::Reg::read) this register and get [`dvsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dvsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DvsrSpec ; impl crate :: RegisterSpec for DvsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dvsr::R`](R) reader structure"] impl crate :: Readable for DvsrSpec { }
#[doc = "`write(|w| ..)` method takes [`dvsr::W`](W) writer structure"] impl crate :: Writable for DvsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DVSR to value 0x01"] impl crate :: Resettable for DvsrSpec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "QUOTR (r) register accessor: QUOTR\n\nYou can [`read`](crate::Reg::read) this register and get [`quotr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@quotr`] module"]
#[doc (alias = "QUOTR")] pub type Quotr = crate :: Reg < quotr :: QuotrSpec > ;
#[doc = "QUOTR"] pub mod quotr {
#[doc = "Register `QUOTR` reader"] pub type R = crate :: R < QuotrSpec > ;
#[doc = "Field `QUOTIENT` reader - Quotient data"] pub type QuotientR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Quotient data"]
#[inline (always)] pub fn quotient (& self) -> QuotientR { QuotientR :: new (self . bits) } }
#[doc = "QUOTR\n\nYou can [`read`](crate::Reg::read) this register and get [`quotr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct QuotrSpec ; impl crate :: RegisterSpec for QuotrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`quotr::R`](R) reader structure"] impl crate :: Readable for QuotrSpec { }
#[doc = "`reset()` method sets QUOTR to value 0"] impl crate :: Resettable for QuotrSpec { } }
#[doc = "RMDR (r) register accessor: RMDR\n\nYou can [`read`](crate::Reg::read) this register and get [`rmdr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rmdr`] module"]
#[doc (alias = "RMDR")] pub type Rmdr = crate :: Reg < rmdr :: RmdrSpec > ;
#[doc = "RMDR"] pub mod rmdr {
#[doc = "Register `RMDR` reader"] pub type R = crate :: R < RmdrSpec > ;
#[doc = "Field `REMAINDER` reader - Remainder data"] pub type RemainderR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Remainder data"]
#[inline (always)] pub fn remainder (& self) -> RemainderR { RemainderR :: new (self . bits) } }
#[doc = "RMDR\n\nYou can [`read`](crate::Reg::read) this register and get [`rmdr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RmdrSpec ; impl crate :: RegisterSpec for RmdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rmdr::R`](R) reader structure"] impl crate :: Readable for RmdrSpec { }
#[doc = "`reset()` method sets RMDR to value 0"] impl crate :: Resettable for RmdrSpec { } }
#[doc = "SR (r) register accessor: SR\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "SR"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `OVF` reader - Overflow flag"] pub type OvfR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Overflow flag"]
#[inline (always)] pub fn ovf (& self) -> OvfR { OvfR :: new ((self . bits & 1) != 0) } }
#[doc = "SR\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "CR (rw) register accessor: CR\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "CR"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `USIGN` reader - unsigned enable"] pub type UsignR = crate :: BitReader ;
#[doc = "Field `USIGN` writer - unsigned enable"] pub type UsignW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OVFE` reader - Overflow interrupt enable"] pub type OvfeR = crate :: BitReader ;
#[doc = "Field `OVFE` writer - Overflow interrupt enable"] pub type OvfeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - unsigned enable"]
#[inline (always)] pub fn usign (& self) -> UsignR { UsignR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Overflow interrupt enable"]
#[inline (always)] pub fn ovfe (& self) -> OvfeR { OvfeR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - unsigned enable"]
#[inline (always)] pub fn usign (& mut self) -> UsignW < '_ , CrSpec > { UsignW :: new (self , 0) }
#[doc = "Bit 1 - Overflow interrupt enable"]
#[inline (always)] pub fn ovfe (& mut self) -> OvfeW < '_ , CrSpec > { OvfeW :: new (self , 1) } }
#[doc = "CR\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x01"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x01 ; } } }
#[doc = "DMA1 controller"] pub type Dma1 = crate :: Periph < dma1 :: RegisterBlock , 0x4002_0000 > ; impl core :: fmt :: Debug for Dma1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma1") . finish () } }
#[doc = "DMA1 controller"] pub mod dma1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { isr : Isr , ifcr : Ifcr , ccr1 : Ccr1 , cndtr1 : Cndtr1 , cpar1 : Cpar1 , cmar1 : Cmar1 , _reserved6 : [u8 ; 0x04] , ccr2 : Ccr2 , cndtr2 : Cndtr2 , cpar2 : Cpar2 , cmar2 : Cmar2 , _reserved10 : [u8 ; 0x04] , ccr3 : Ccr3 , cndtr3 : Cndtr3 , cpar3 : Cpar3 , cmar3 : Cmar3 , _reserved14 : [u8 ; 0x04] , ccr4 : Ccr4 , cndtr4 : Cndtr4 , cpar4 : Cpar4 , cmar4 : Cmar4 , _reserved18 : [u8 ; 0x04] , ccr5 : Ccr5 , cndtr5 : Cndtr5 , cpar5 : Cpar5 , cmar5 : Cmar5 , } impl RegisterBlock {
#[doc = "0x00 - ISR"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x04 - IFCR"]
#[inline (always)] pub const fn ifcr (& self) -> & Ifcr { & self . ifcr }
#[doc = "0x08 - CCR1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x0c - CNDTR1"]
#[inline (always)] pub const fn cndtr1 (& self) -> & Cndtr1 { & self . cndtr1 }
#[doc = "0x10 - CPAR1"]
#[inline (always)] pub const fn cpar1 (& self) -> & Cpar1 { & self . cpar1 }
#[doc = "0x14 - CMAR1"]
#[inline (always)] pub const fn cmar1 (& self) -> & Cmar1 { & self . cmar1 }
#[doc = "0x1c - CCR2"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x20 - CNDTR2"]
#[inline (always)] pub const fn cndtr2 (& self) -> & Cndtr2 { & self . cndtr2 }
#[doc = "0x24 - CPAR2"]
#[inline (always)] pub const fn cpar2 (& self) -> & Cpar2 { & self . cpar2 }
#[doc = "0x28 - CMAR2"]
#[inline (always)] pub const fn cmar2 (& self) -> & Cmar2 { & self . cmar2 }
#[doc = "0x30 - CCR3"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x34 - CNDTR3"]
#[inline (always)] pub const fn cndtr3 (& self) -> & Cndtr3 { & self . cndtr3 }
#[doc = "0x38 - CPAR3"]
#[inline (always)] pub const fn cpar3 (& self) -> & Cpar3 { & self . cpar3 }
#[doc = "0x3c - CMAR3"]
#[inline (always)] pub const fn cmar3 (& self) -> & Cmar3 { & self . cmar3 }
#[doc = "0x44 - CCR4"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x48 - CNDTR4"]
#[inline (always)] pub const fn cndtr4 (& self) -> & Cndtr4 { & self . cndtr4 }
#[doc = "0x4c - CPAR4"]
#[inline (always)] pub const fn cpar4 (& self) -> & Cpar4 { & self . cpar4 }
#[doc = "0x50 - CMAR4"]
#[inline (always)] pub const fn cmar4 (& self) -> & Cmar4 { & self . cmar4 }
#[doc = "0x58 - CCR5"]
#[inline (always)] pub const fn ccr5 (& self) -> & Ccr5 { & self . ccr5 }
#[doc = "0x5c - CNDTR5"]
#[inline (always)] pub const fn cndtr5 (& self) -> & Cndtr5 { & self . cndtr5 }
#[doc = "0x60 - CPAR5"]
#[inline (always)] pub const fn cpar5 (& self) -> & Cpar5 { & self . cpar5 }
#[doc = "0x64 - CMAR5"]
#[inline (always)] pub const fn cmar5 (& self) -> & Cmar5 { & self . cmar5 } }
#[doc = "ISR (r) register accessor: ISR\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "ISR"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Field `GIF1` reader - channel 1 global interrupt flag"] pub type Gif1R = crate :: BitReader ;
#[doc = "Field `TCIF1` reader - channel 1 transfer complete flag"] pub type Tcif1R = crate :: BitReader ;
#[doc = "Field `HTIF1` reader - channel 1 half transfer flag"] pub type Htif1R = crate :: BitReader ;
#[doc = "Field `TEIF1` reader - channel 1 transfer error flag"] pub type Teif1R = crate :: BitReader ;
#[doc = "Field `GIF2` reader - channel 2 global interrupt flag"] pub type Gif2R = crate :: BitReader ;
#[doc = "Field `TCIF2` reader - channel 2 transfer complete flag"] pub type Tcif2R = crate :: BitReader ;
#[doc = "Field `HTIF2` reader - channel 2 half transfer flag"] pub type Htif2R = crate :: BitReader ;
#[doc = "Field `TEIF2` reader - channel 2 transfer error flag"] pub type Teif2R = crate :: BitReader ;
#[doc = "Field `GIF3` reader - channel 3 global interrupt flag"] pub type Gif3R = crate :: BitReader ;
#[doc = "Field `TCIF3` reader - channel 3 transfer complete flag"] pub type Tcif3R = crate :: BitReader ;
#[doc = "Field `HTIF3` reader - channel 3 half transfer flag"] pub type Htif3R = crate :: BitReader ;
#[doc = "Field `TEIF3` reader - channel 3 transfer error flag"] pub type Teif3R = crate :: BitReader ;
#[doc = "Field `GIF4` reader - channel 4 global interrupt flag"] pub type Gif4R = crate :: BitReader ;
#[doc = "Field `TCIF4` reader - channel 4 transfer complete flag"] pub type Tcif4R = crate :: BitReader ;
#[doc = "Field `HTIF4` reader - channel 4 half transfer flag"] pub type Htif4R = crate :: BitReader ;
#[doc = "Field `TEIF4` reader - channel 4 transfer error flag"] pub type Teif4R = crate :: BitReader ;
#[doc = "Field `GIF5` reader - channel 5 global interrupt flag"] pub type Gif5R = crate :: BitReader ;
#[doc = "Field `TCIF5` reader - channel 5 transfer complete flag"] pub type Tcif5R = crate :: BitReader ;
#[doc = "Field `HTIF5` reader - channel 5 half transfer flag"] pub type Htif5R = crate :: BitReader ;
#[doc = "Field `TEIF5` reader - channel 5 transfer error flag"] pub type Teif5R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - channel 1 global interrupt flag"]
#[inline (always)] pub fn gif1 (& self) -> Gif1R { Gif1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - channel 1 transfer complete flag"]
#[inline (always)] pub fn tcif1 (& self) -> Tcif1R { Tcif1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - channel 1 half transfer flag"]
#[inline (always)] pub fn htif1 (& self) -> Htif1R { Htif1R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - channel 1 transfer error flag"]
#[inline (always)] pub fn teif1 (& self) -> Teif1R { Teif1R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - channel 2 global interrupt flag"]
#[inline (always)] pub fn gif2 (& self) -> Gif2R { Gif2R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - channel 2 transfer complete flag"]
#[inline (always)] pub fn tcif2 (& self) -> Tcif2R { Tcif2R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - channel 2 half transfer flag"]
#[inline (always)] pub fn htif2 (& self) -> Htif2R { Htif2R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - channel 2 transfer error flag"]
#[inline (always)] pub fn teif2 (& self) -> Teif2R { Teif2R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - channel 3 global interrupt flag"]
#[inline (always)] pub fn gif3 (& self) -> Gif3R { Gif3R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - channel 3 transfer complete flag"]
#[inline (always)] pub fn tcif3 (& self) -> Tcif3R { Tcif3R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - channel 3 half transfer flag"]
#[inline (always)] pub fn htif3 (& self) -> Htif3R { Htif3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - channel 3 transfer error flag"]
#[inline (always)] pub fn teif3 (& self) -> Teif3R { Teif3R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - channel 4 global interrupt flag"]
#[inline (always)] pub fn gif4 (& self) -> Gif4R { Gif4R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - channel 4 transfer complete flag"]
#[inline (always)] pub fn tcif4 (& self) -> Tcif4R { Tcif4R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - channel 4 half transfer flag"]
#[inline (always)] pub fn htif4 (& self) -> Htif4R { Htif4R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - channel 4 transfer error flag"]
#[inline (always)] pub fn teif4 (& self) -> Teif4R { Teif4R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - channel 5 global interrupt flag"]
#[inline (always)] pub fn gif5 (& self) -> Gif5R { Gif5R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - channel 5 transfer complete flag"]
#[inline (always)] pub fn tcif5 (& self) -> Tcif5R { Tcif5R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - channel 5 half transfer flag"]
#[inline (always)] pub fn htif5 (& self) -> Htif5R { Htif5R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - channel 5 transfer error flag"]
#[inline (always)] pub fn teif5 (& self) -> Teif5R { Teif5R :: new (((self . bits >> 19) & 1) != 0) } }
#[doc = "ISR\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "IFCR (rw) register accessor: IFCR\n\nYou can [`read`](crate::Reg::read) this register and get [`ifcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ifcr`] module"]
#[doc (alias = "IFCR")] pub type Ifcr = crate :: Reg < ifcr :: IfcrSpec > ;
#[doc = "IFCR"] pub mod ifcr {
#[doc = "Register `IFCR` reader"] pub type R = crate :: R < IfcrSpec > ;
#[doc = "Register `IFCR` writer"] pub type W = crate :: W < IfcrSpec > ;
#[doc = "Field `CGIF1` reader - channel 1 global interrupt clear"] pub type Cgif1R = crate :: BitReader ;
#[doc = "Field `CGIF1` writer - channel 1 global interrupt clear"] pub type Cgif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF1` reader - channel 1 transfer complete clear"] pub type Ctcif1R = crate :: BitReader ;
#[doc = "Field `CTCIF1` writer - channel 1 transfer complete clear"] pub type Ctcif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF1` reader - channel 1 half transfer clear"] pub type Chtif1R = crate :: BitReader ;
#[doc = "Field `CHTIF1` writer - channel 1 half transfer clear"] pub type Chtif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF1` reader - channel 1 transfer error clear"] pub type Cteif1R = crate :: BitReader ;
#[doc = "Field `CTEIF1` writer - channel 1 transfer error clear"] pub type Cteif1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF2` reader - channel 2 global interrupt clear"] pub type Cgif2R = crate :: BitReader ;
#[doc = "Field `CGIF2` writer - channel 2 global interrupt clear"] pub type Cgif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF2` reader - channel 2 transfer complete clear"] pub type Ctcif2R = crate :: BitReader ;
#[doc = "Field `CTCIF2` writer - channel 2 transfer complete clear"] pub type Ctcif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF2` reader - channel 2 half transfer clear"] pub type Chtif2R = crate :: BitReader ;
#[doc = "Field `CHTIF2` writer - channel 2 half transfer clear"] pub type Chtif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF2` reader - channel 2 transfer error clear"] pub type Cteif2R = crate :: BitReader ;
#[doc = "Field `CTEIF2` writer - channel 2 transfer error clear"] pub type Cteif2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF3` reader - channel 3 global interrupt clear"] pub type Cgif3R = crate :: BitReader ;
#[doc = "Field `CGIF3` writer - channel 3 global interrupt clear"] pub type Cgif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF3` reader - channel 3 transfer complete clear"] pub type Ctcif3R = crate :: BitReader ;
#[doc = "Field `CTCIF3` writer - channel 3 transfer complete clear"] pub type Ctcif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF3` reader - channel 3 half transfer clear"] pub type Chtif3R = crate :: BitReader ;
#[doc = "Field `CHTIF3` writer - channel 3 half transfer clear"] pub type Chtif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF3` reader - channel 3 transfer error clear"] pub type Cteif3R = crate :: BitReader ;
#[doc = "Field `CTEIF3` writer - channel 3 transfer error clear"] pub type Cteif3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF4` reader - channel 4 global interrupt clear"] pub type Cgif4R = crate :: BitReader ;
#[doc = "Field `CGIF4` writer - channel 4 global interrupt clear"] pub type Cgif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF4` reader - channel 4 transfer complete clear"] pub type Ctcif4R = crate :: BitReader ;
#[doc = "Field `CTCIF4` writer - channel 4 transfer complete clear"] pub type Ctcif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF4` reader - channel 4 half transfer clear"] pub type Chtif4R = crate :: BitReader ;
#[doc = "Field `CHTIF4` writer - channel 4 half transfer clear"] pub type Chtif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF4` reader - channel 4 transfer error clear"] pub type Cteif4R = crate :: BitReader ;
#[doc = "Field `CTEIF4` writer - channel 4 transfer error clear"] pub type Cteif4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CGIF5` reader - channel 5 global interrupt clear"] pub type Cgif5R = crate :: BitReader ;
#[doc = "Field `CGIF5` writer - channel 5 global interrupt clear"] pub type Cgif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTCIF5` reader - channel 5 transfer complete clear"] pub type Ctcif5R = crate :: BitReader ;
#[doc = "Field `CTCIF5` writer - channel 5 transfer complete clear"] pub type Ctcif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHTIF5` reader - channel 5 half transfer clear"] pub type Chtif5R = crate :: BitReader ;
#[doc = "Field `CHTIF5` writer - channel 5 half transfer clear"] pub type Chtif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CTEIF5` reader - channel 5 transfer error clear"] pub type Cteif5R = crate :: BitReader ;
#[doc = "Field `CTEIF5` writer - channel 5 transfer error clear"] pub type Cteif5W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - channel 1 global interrupt clear"]
#[inline (always)] pub fn cgif1 (& self) -> Cgif1R { Cgif1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - channel 1 transfer complete clear"]
#[inline (always)] pub fn ctcif1 (& self) -> Ctcif1R { Ctcif1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - channel 1 half transfer clear"]
#[inline (always)] pub fn chtif1 (& self) -> Chtif1R { Chtif1R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - channel 1 transfer error clear"]
#[inline (always)] pub fn cteif1 (& self) -> Cteif1R { Cteif1R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - channel 2 global interrupt clear"]
#[inline (always)] pub fn cgif2 (& self) -> Cgif2R { Cgif2R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - channel 2 transfer complete clear"]
#[inline (always)] pub fn ctcif2 (& self) -> Ctcif2R { Ctcif2R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - channel 2 half transfer clear"]
#[inline (always)] pub fn chtif2 (& self) -> Chtif2R { Chtif2R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - channel 2 transfer error clear"]
#[inline (always)] pub fn cteif2 (& self) -> Cteif2R { Cteif2R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - channel 3 global interrupt clear"]
#[inline (always)] pub fn cgif3 (& self) -> Cgif3R { Cgif3R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - channel 3 transfer complete clear"]
#[inline (always)] pub fn ctcif3 (& self) -> Ctcif3R { Ctcif3R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - channel 3 half transfer clear"]
#[inline (always)] pub fn chtif3 (& self) -> Chtif3R { Chtif3R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - channel 3 transfer error clear"]
#[inline (always)] pub fn cteif3 (& self) -> Cteif3R { Cteif3R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - channel 4 global interrupt clear"]
#[inline (always)] pub fn cgif4 (& self) -> Cgif4R { Cgif4R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - channel 4 transfer complete clear"]
#[inline (always)] pub fn ctcif4 (& self) -> Ctcif4R { Ctcif4R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - channel 4 half transfer clear"]
#[inline (always)] pub fn chtif4 (& self) -> Chtif4R { Chtif4R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - channel 4 transfer error clear"]
#[inline (always)] pub fn cteif4 (& self) -> Cteif4R { Cteif4R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - channel 5 global interrupt clear"]
#[inline (always)] pub fn cgif5 (& self) -> Cgif5R { Cgif5R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - channel 5 transfer complete clear"]
#[inline (always)] pub fn ctcif5 (& self) -> Ctcif5R { Ctcif5R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - channel 5 half transfer clear"]
#[inline (always)] pub fn chtif5 (& self) -> Chtif5R { Chtif5R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - channel 5 transfer error clear"]
#[inline (always)] pub fn cteif5 (& self) -> Cteif5R { Cteif5R :: new (((self . bits >> 19) & 1) != 0) } } impl W {
#[doc = "Bit 0 - channel 1 global interrupt clear"]
#[inline (always)] pub fn cgif1 (& mut self) -> Cgif1W < '_ , IfcrSpec > { Cgif1W :: new (self , 0) }
#[doc = "Bit 1 - channel 1 transfer complete clear"]
#[inline (always)] pub fn ctcif1 (& mut self) -> Ctcif1W < '_ , IfcrSpec > { Ctcif1W :: new (self , 1) }
#[doc = "Bit 2 - channel 1 half transfer clear"]
#[inline (always)] pub fn chtif1 (& mut self) -> Chtif1W < '_ , IfcrSpec > { Chtif1W :: new (self , 2) }
#[doc = "Bit 3 - channel 1 transfer error clear"]
#[inline (always)] pub fn cteif1 (& mut self) -> Cteif1W < '_ , IfcrSpec > { Cteif1W :: new (self , 3) }
#[doc = "Bit 4 - channel 2 global interrupt clear"]
#[inline (always)] pub fn cgif2 (& mut self) -> Cgif2W < '_ , IfcrSpec > { Cgif2W :: new (self , 4) }
#[doc = "Bit 5 - channel 2 transfer complete clear"]
#[inline (always)] pub fn ctcif2 (& mut self) -> Ctcif2W < '_ , IfcrSpec > { Ctcif2W :: new (self , 5) }
#[doc = "Bit 6 - channel 2 half transfer clear"]
#[inline (always)] pub fn chtif2 (& mut self) -> Chtif2W < '_ , IfcrSpec > { Chtif2W :: new (self , 6) }
#[doc = "Bit 7 - channel 2 transfer error clear"]
#[inline (always)] pub fn cteif2 (& mut self) -> Cteif2W < '_ , IfcrSpec > { Cteif2W :: new (self , 7) }
#[doc = "Bit 8 - channel 3 global interrupt clear"]
#[inline (always)] pub fn cgif3 (& mut self) -> Cgif3W < '_ , IfcrSpec > { Cgif3W :: new (self , 8) }
#[doc = "Bit 9 - channel 3 transfer complete clear"]
#[inline (always)] pub fn ctcif3 (& mut self) -> Ctcif3W < '_ , IfcrSpec > { Ctcif3W :: new (self , 9) }
#[doc = "Bit 10 - channel 3 half transfer clear"]
#[inline (always)] pub fn chtif3 (& mut self) -> Chtif3W < '_ , IfcrSpec > { Chtif3W :: new (self , 10) }
#[doc = "Bit 11 - channel 3 transfer error clear"]
#[inline (always)] pub fn cteif3 (& mut self) -> Cteif3W < '_ , IfcrSpec > { Cteif3W :: new (self , 11) }
#[doc = "Bit 12 - channel 4 global interrupt clear"]
#[inline (always)] pub fn cgif4 (& mut self) -> Cgif4W < '_ , IfcrSpec > { Cgif4W :: new (self , 12) }
#[doc = "Bit 13 - channel 4 transfer complete clear"]
#[inline (always)] pub fn ctcif4 (& mut self) -> Ctcif4W < '_ , IfcrSpec > { Ctcif4W :: new (self , 13) }
#[doc = "Bit 14 - channel 4 half transfer clear"]
#[inline (always)] pub fn chtif4 (& mut self) -> Chtif4W < '_ , IfcrSpec > { Chtif4W :: new (self , 14) }
#[doc = "Bit 15 - channel 4 transfer error clear"]
#[inline (always)] pub fn cteif4 (& mut self) -> Cteif4W < '_ , IfcrSpec > { Cteif4W :: new (self , 15) }
#[doc = "Bit 16 - channel 5 global interrupt clear"]
#[inline (always)] pub fn cgif5 (& mut self) -> Cgif5W < '_ , IfcrSpec > { Cgif5W :: new (self , 16) }
#[doc = "Bit 17 - channel 5 transfer complete clear"]
#[inline (always)] pub fn ctcif5 (& mut self) -> Ctcif5W < '_ , IfcrSpec > { Ctcif5W :: new (self , 17) }
#[doc = "Bit 18 - channel 5 half transfer clear"]
#[inline (always)] pub fn chtif5 (& mut self) -> Chtif5W < '_ , IfcrSpec > { Chtif5W :: new (self , 18) }
#[doc = "Bit 19 - channel 5 transfer error clear"]
#[inline (always)] pub fn cteif5 (& mut self) -> Cteif5W < '_ , IfcrSpec > { Cteif5W :: new (self , 19) } }
#[doc = "IFCR\n\nYou can [`read`](crate::Reg::read) this register and get [`ifcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ifcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IfcrSpec ; impl crate :: RegisterSpec for IfcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ifcr::R`](R) reader structure"] impl crate :: Readable for IfcrSpec { }
#[doc = "`write(|w| ..)` method takes [`ifcr::W`](W) writer structure"] impl crate :: Writable for IfcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IFCR to value 0"] impl crate :: Resettable for IfcrSpec { } }
#[doc = "CCR1 (rw) register accessor: CCR1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "CCR1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARE` reader - Auto-Reload Enable bit"] pub type AreR = crate :: BitReader ;
#[doc = "Field `ARE` writer - Auto-Reload Enable bit"] pub type AreW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& self) -> AreR { AreR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr1Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr1Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr1Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr1Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr1Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr1Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr1Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr1Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr1Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr1Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr1Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr1Spec > { Mem2memW :: new (self , 14) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& mut self) -> AreW < '_ , Ccr1Spec > { AreW :: new (self , 15) } }
#[doc = "CCR1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CCR2 (rw) register accessor: CCR2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "CCR2"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARE` reader - Auto-Reload Enable bit"] pub type AreR = crate :: BitReader ;
#[doc = "Field `ARE` writer - Auto-Reload Enable bit"] pub type AreW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& self) -> AreR { AreR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr2Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr2Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr2Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr2Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr2Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr2Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr2Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr2Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr2Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr2Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr2Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr2Spec > { Mem2memW :: new (self , 14) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& mut self) -> AreW < '_ , Ccr2Spec > { AreW :: new (self , 15) } }
#[doc = "CCR2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CCR3 (rw) register accessor: CCR3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "CCR3"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARE` reader - Auto-Reload Enable bit"] pub type AreR = crate :: BitReader ;
#[doc = "Field `ARE` writer - Auto-Reload Enable bit"] pub type AreW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& self) -> AreR { AreR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr3Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr3Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr3Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr3Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr3Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr3Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr3Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr3Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr3Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr3Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr3Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr3Spec > { Mem2memW :: new (self , 14) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& mut self) -> AreW < '_ , Ccr3Spec > { AreW :: new (self , 15) } }
#[doc = "CCR3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CCR4 (rw) register accessor: CCR4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "CCR4"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARE` reader - Auto-Reload Enable bit"] pub type AreR = crate :: BitReader ;
#[doc = "Field `ARE` writer - Auto-Reload Enable bit"] pub type AreW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& self) -> AreR { AreR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr4Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr4Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr4Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr4Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr4Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr4Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr4Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr4Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr4Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr4Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr4Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr4Spec > { Mem2memW :: new (self , 14) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& mut self) -> AreW < '_ , Ccr4Spec > { AreW :: new (self , 15) } }
#[doc = "CCR4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "CCR5 (rw) register accessor: CCR5\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr5`] module"]
#[doc (alias = "CCR5")] pub type Ccr5 = crate :: Reg < ccr5 :: Ccr5Spec > ;
#[doc = "CCR5"] pub mod ccr5 {
#[doc = "Register `CCR5` reader"] pub type R = crate :: R < Ccr5Spec > ;
#[doc = "Register `CCR5` writer"] pub type W = crate :: W < Ccr5Spec > ;
#[doc = "Field `EN` reader - Channel enable"] pub type EnR = crate :: BitReader ;
#[doc = "Field `EN` writer - Channel enable"] pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TCIE` reader - Transfer complete interrupt enable"] pub type TcieR = crate :: BitReader ;
#[doc = "Field `TCIE` writer - Transfer complete interrupt enable"] pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HTIE` reader - Half transfer interrupt enable"] pub type HtieR = crate :: BitReader ;
#[doc = "Field `HTIE` writer - Half transfer interrupt enable"] pub type HtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TEIE` reader - Transfer error interrupt enable"] pub type TeieR = crate :: BitReader ;
#[doc = "Field `TEIE` writer - Transfer error interrupt enable"] pub type TeieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Data transfer direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Data transfer direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CIRC` reader - Circular mode"] pub type CircR = crate :: BitReader ;
#[doc = "Field `CIRC` writer - Circular mode"] pub type CircW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINC` reader - Peripheral increment mode"] pub type PincR = crate :: BitReader ;
#[doc = "Field `PINC` writer - Peripheral increment mode"] pub type PincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MINC` reader - Memory increment mode"] pub type MincR = crate :: BitReader ;
#[doc = "Field `MINC` writer - Memory increment mode"] pub type MincW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSIZE` reader - Peripheral size"] pub type PsizeR = crate :: FieldReader ;
#[doc = "Field `PSIZE` writer - Peripheral size"] pub type PsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MSIZE` reader - Memory size"] pub type MsizeR = crate :: FieldReader ;
#[doc = "Field `MSIZE` writer - Memory size"] pub type MsizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PL` reader - Channel priority level"] pub type PlR = crate :: FieldReader ;
#[doc = "Field `PL` writer - Channel priority level"] pub type PlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MEM2MEM` reader - Memory to memory mode"] pub type Mem2memR = crate :: BitReader ;
#[doc = "Field `MEM2MEM` writer - Memory to memory mode"] pub type Mem2memW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARE` reader - Auto-Reload Enable bit"] pub type AreR = crate :: BitReader ;
#[doc = "Field `ARE` writer - Auto-Reload Enable bit"] pub type AreW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& self) -> HtieR { HtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& self) -> TeieR { TeieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& self) -> CircR { CircR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& self) -> PincR { PincR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& self) -> MincR { MincR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& self) -> PsizeR { PsizeR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& self) -> MsizeR { MsizeR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& self) -> PlR { PlR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& self) -> Mem2memR { Mem2memR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& self) -> AreR { AreR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Channel enable"]
#[inline (always)] pub fn en (& mut self) -> EnW < '_ , Ccr5Spec > { EnW :: new (self , 0) }
#[doc = "Bit 1 - Transfer complete interrupt enable"]
#[inline (always)] pub fn tcie (& mut self) -> TcieW < '_ , Ccr5Spec > { TcieW :: new (self , 1) }
#[doc = "Bit 2 - Half transfer interrupt enable"]
#[inline (always)] pub fn htie (& mut self) -> HtieW < '_ , Ccr5Spec > { HtieW :: new (self , 2) }
#[doc = "Bit 3 - Transfer error interrupt enable"]
#[inline (always)] pub fn teie (& mut self) -> TeieW < '_ , Ccr5Spec > { TeieW :: new (self , 3) }
#[doc = "Bit 4 - Data transfer direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Ccr5Spec > { DirW :: new (self , 4) }
#[doc = "Bit 5 - Circular mode"]
#[inline (always)] pub fn circ (& mut self) -> CircW < '_ , Ccr5Spec > { CircW :: new (self , 5) }
#[doc = "Bit 6 - Peripheral increment mode"]
#[inline (always)] pub fn pinc (& mut self) -> PincW < '_ , Ccr5Spec > { PincW :: new (self , 6) }
#[doc = "Bit 7 - Memory increment mode"]
#[inline (always)] pub fn minc (& mut self) -> MincW < '_ , Ccr5Spec > { MincW :: new (self , 7) }
#[doc = "Bits 8:9 - Peripheral size"]
#[inline (always)] pub fn psize (& mut self) -> PsizeW < '_ , Ccr5Spec > { PsizeW :: new (self , 8) }
#[doc = "Bits 10:11 - Memory size"]
#[inline (always)] pub fn msize (& mut self) -> MsizeW < '_ , Ccr5Spec > { MsizeW :: new (self , 10) }
#[doc = "Bits 12:13 - Channel priority level"]
#[inline (always)] pub fn pl (& mut self) -> PlW < '_ , Ccr5Spec > { PlW :: new (self , 12) }
#[doc = "Bit 14 - Memory to memory mode"]
#[inline (always)] pub fn mem2mem (& mut self) -> Mem2memW < '_ , Ccr5Spec > { Mem2memW :: new (self , 14) }
#[doc = "Bit 15 - Auto-Reload Enable bit"]
#[inline (always)] pub fn are (& mut self) -> AreW < '_ , Ccr5Spec > { AreW :: new (self , 15) } }
#[doc = "CCR5\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr5Spec ; impl crate :: RegisterSpec for Ccr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr5::R`](R) reader structure"] impl crate :: Readable for Ccr5Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr5::W`](W) writer structure"] impl crate :: Writable for Ccr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR5 to value 0"] impl crate :: Resettable for Ccr5Spec { } }
#[doc = "CNDTR1 (rw) register accessor: CNDTR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr1`] module"]
#[doc (alias = "CNDTR1")] pub type Cndtr1 = crate :: Reg < cndtr1 :: Cndtr1Spec > ;
#[doc = "CNDTR1"] pub mod cndtr1 {
#[doc = "Register `CNDTR1` reader"] pub type R = crate :: R < Cndtr1Spec > ;
#[doc = "Register `CNDTR1` writer"] pub type W = crate :: W < Cndtr1Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr1Spec > { NdtW :: new (self , 0) } }
#[doc = "CNDTR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr1Spec ; impl crate :: RegisterSpec for Cndtr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr1::R`](R) reader structure"] impl crate :: Readable for Cndtr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr1::W`](W) writer structure"] impl crate :: Writable for Cndtr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR1 to value 0"] impl crate :: Resettable for Cndtr1Spec { } }
#[doc = "CNDTR2 (rw) register accessor: CNDTR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr2`] module"]
#[doc (alias = "CNDTR2")] pub type Cndtr2 = crate :: Reg < cndtr2 :: Cndtr2Spec > ;
#[doc = "CNDTR2"] pub mod cndtr2 {
#[doc = "Register `CNDTR2` reader"] pub type R = crate :: R < Cndtr2Spec > ;
#[doc = "Register `CNDTR2` writer"] pub type W = crate :: W < Cndtr2Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr2Spec > { NdtW :: new (self , 0) } }
#[doc = "CNDTR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr2Spec ; impl crate :: RegisterSpec for Cndtr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr2::R`](R) reader structure"] impl crate :: Readable for Cndtr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr2::W`](W) writer structure"] impl crate :: Writable for Cndtr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR2 to value 0"] impl crate :: Resettable for Cndtr2Spec { } }
#[doc = "CNDTR3 (rw) register accessor: CNDTR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr3`] module"]
#[doc (alias = "CNDTR3")] pub type Cndtr3 = crate :: Reg < cndtr3 :: Cndtr3Spec > ;
#[doc = "CNDTR3"] pub mod cndtr3 {
#[doc = "Register `CNDTR3` reader"] pub type R = crate :: R < Cndtr3Spec > ;
#[doc = "Register `CNDTR3` writer"] pub type W = crate :: W < Cndtr3Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr3Spec > { NdtW :: new (self , 0) } }
#[doc = "CNDTR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr3Spec ; impl crate :: RegisterSpec for Cndtr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr3::R`](R) reader structure"] impl crate :: Readable for Cndtr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr3::W`](W) writer structure"] impl crate :: Writable for Cndtr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR3 to value 0"] impl crate :: Resettable for Cndtr3Spec { } }
#[doc = "CNDTR4 (rw) register accessor: CNDTR4\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr4`] module"]
#[doc (alias = "CNDTR4")] pub type Cndtr4 = crate :: Reg < cndtr4 :: Cndtr4Spec > ;
#[doc = "CNDTR4"] pub mod cndtr4 {
#[doc = "Register `CNDTR4` reader"] pub type R = crate :: R < Cndtr4Spec > ;
#[doc = "Register `CNDTR4` writer"] pub type W = crate :: W < Cndtr4Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr4Spec > { NdtW :: new (self , 0) } }
#[doc = "CNDTR4\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr4Spec ; impl crate :: RegisterSpec for Cndtr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr4::R`](R) reader structure"] impl crate :: Readable for Cndtr4Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr4::W`](W) writer structure"] impl crate :: Writable for Cndtr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR4 to value 0"] impl crate :: Resettable for Cndtr4Spec { } }
#[doc = "CNDTR5 (rw) register accessor: CNDTR5\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cndtr5`] module"]
#[doc (alias = "CNDTR5")] pub type Cndtr5 = crate :: Reg < cndtr5 :: Cndtr5Spec > ;
#[doc = "CNDTR5"] pub mod cndtr5 {
#[doc = "Register `CNDTR5` reader"] pub type R = crate :: R < Cndtr5Spec > ;
#[doc = "Register `CNDTR5` writer"] pub type W = crate :: W < Cndtr5Spec > ;
#[doc = "Field `NDT` reader - Number of data to transfer"] pub type NdtR = crate :: FieldReader < u16 > ;
#[doc = "Field `NDT` writer - Number of data to transfer"] pub type NdtW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& self) -> NdtR { NdtR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Number of data to transfer"]
#[inline (always)] pub fn ndt (& mut self) -> NdtW < '_ , Cndtr5Spec > { NdtW :: new (self , 0) } }
#[doc = "CNDTR5\n\nYou can [`read`](crate::Reg::read) this register and get [`cndtr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cndtr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cndtr5Spec ; impl crate :: RegisterSpec for Cndtr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cndtr5::R`](R) reader structure"] impl crate :: Readable for Cndtr5Spec { }
#[doc = "`write(|w| ..)` method takes [`cndtr5::W`](W) writer structure"] impl crate :: Writable for Cndtr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNDTR5 to value 0"] impl crate :: Resettable for Cndtr5Spec { } }
#[doc = "CPAR1 (rw) register accessor: CPAR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar1`] module"]
#[doc (alias = "CPAR1")] pub type Cpar1 = crate :: Reg < cpar1 :: Cpar1Spec > ;
#[doc = "CPAR1"] pub mod cpar1 {
#[doc = "Register `CPAR1` reader"] pub type R = crate :: R < Cpar1Spec > ;
#[doc = "Register `CPAR1` writer"] pub type W = crate :: W < Cpar1Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar1Spec > { PaW :: new (self , 0) } }
#[doc = "CPAR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar1Spec ; impl crate :: RegisterSpec for Cpar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar1::R`](R) reader structure"] impl crate :: Readable for Cpar1Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar1::W`](W) writer structure"] impl crate :: Writable for Cpar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR1 to value 0"] impl crate :: Resettable for Cpar1Spec { } }
#[doc = "CPAR2 (rw) register accessor: CPAR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar2`] module"]
#[doc (alias = "CPAR2")] pub type Cpar2 = crate :: Reg < cpar2 :: Cpar2Spec > ;
#[doc = "CPAR2"] pub mod cpar2 {
#[doc = "Register `CPAR2` reader"] pub type R = crate :: R < Cpar2Spec > ;
#[doc = "Register `CPAR2` writer"] pub type W = crate :: W < Cpar2Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar2Spec > { PaW :: new (self , 0) } }
#[doc = "CPAR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar2Spec ; impl crate :: RegisterSpec for Cpar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar2::R`](R) reader structure"] impl crate :: Readable for Cpar2Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar2::W`](W) writer structure"] impl crate :: Writable for Cpar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR2 to value 0"] impl crate :: Resettable for Cpar2Spec { } }
#[doc = "CPAR3 (rw) register accessor: CPAR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar3`] module"]
#[doc (alias = "CPAR3")] pub type Cpar3 = crate :: Reg < cpar3 :: Cpar3Spec > ;
#[doc = "CPAR3"] pub mod cpar3 {
#[doc = "Register `CPAR3` reader"] pub type R = crate :: R < Cpar3Spec > ;
#[doc = "Register `CPAR3` writer"] pub type W = crate :: W < Cpar3Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar3Spec > { PaW :: new (self , 0) } }
#[doc = "CPAR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar3Spec ; impl crate :: RegisterSpec for Cpar3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar3::R`](R) reader structure"] impl crate :: Readable for Cpar3Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar3::W`](W) writer structure"] impl crate :: Writable for Cpar3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR3 to value 0"] impl crate :: Resettable for Cpar3Spec { } }
#[doc = "CPAR4 (rw) register accessor: CPAR4\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar4`] module"]
#[doc (alias = "CPAR4")] pub type Cpar4 = crate :: Reg < cpar4 :: Cpar4Spec > ;
#[doc = "CPAR4"] pub mod cpar4 {
#[doc = "Register `CPAR4` reader"] pub type R = crate :: R < Cpar4Spec > ;
#[doc = "Register `CPAR4` writer"] pub type W = crate :: W < Cpar4Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar4Spec > { PaW :: new (self , 0) } }
#[doc = "CPAR4\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar4Spec ; impl crate :: RegisterSpec for Cpar4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar4::R`](R) reader structure"] impl crate :: Readable for Cpar4Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar4::W`](W) writer structure"] impl crate :: Writable for Cpar4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR4 to value 0"] impl crate :: Resettable for Cpar4Spec { } }
#[doc = "CPAR5 (rw) register accessor: CPAR5\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpar5`] module"]
#[doc (alias = "CPAR5")] pub type Cpar5 = crate :: Reg < cpar5 :: Cpar5Spec > ;
#[doc = "CPAR5"] pub mod cpar5 {
#[doc = "Register `CPAR5` reader"] pub type R = crate :: R < Cpar5Spec > ;
#[doc = "Register `CPAR5` writer"] pub type W = crate :: W < Cpar5Spec > ;
#[doc = "Field `PA` reader - Peripheral address"] pub type PaR = crate :: FieldReader < u32 > ;
#[doc = "Field `PA` writer - Peripheral address"] pub type PaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& self) -> PaR { PaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Peripheral address"]
#[inline (always)] pub fn pa (& mut self) -> PaW < '_ , Cpar5Spec > { PaW :: new (self , 0) } }
#[doc = "CPAR5\n\nYou can [`read`](crate::Reg::read) this register and get [`cpar5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpar5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cpar5Spec ; impl crate :: RegisterSpec for Cpar5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cpar5::R`](R) reader structure"] impl crate :: Readable for Cpar5Spec { }
#[doc = "`write(|w| ..)` method takes [`cpar5::W`](W) writer structure"] impl crate :: Writable for Cpar5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CPAR5 to value 0"] impl crate :: Resettable for Cpar5Spec { } }
#[doc = "CMAR1 (rw) register accessor: CMAR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar1`] module"]
#[doc (alias = "CMAR1")] pub type Cmar1 = crate :: Reg < cmar1 :: Cmar1Spec > ;
#[doc = "CMAR1"] pub mod cmar1 {
#[doc = "Register `CMAR1` reader"] pub type R = crate :: R < Cmar1Spec > ;
#[doc = "Register `CMAR1` writer"] pub type W = crate :: W < Cmar1Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar1Spec > { MaW :: new (self , 0) } }
#[doc = "CMAR1\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar1Spec ; impl crate :: RegisterSpec for Cmar1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar1::R`](R) reader structure"] impl crate :: Readable for Cmar1Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar1::W`](W) writer structure"] impl crate :: Writable for Cmar1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR1 to value 0"] impl crate :: Resettable for Cmar1Spec { } }
#[doc = "CMAR2 (rw) register accessor: CMAR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar2`] module"]
#[doc (alias = "CMAR2")] pub type Cmar2 = crate :: Reg < cmar2 :: Cmar2Spec > ;
#[doc = "CMAR2"] pub mod cmar2 {
#[doc = "Register `CMAR2` reader"] pub type R = crate :: R < Cmar2Spec > ;
#[doc = "Register `CMAR2` writer"] pub type W = crate :: W < Cmar2Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar2Spec > { MaW :: new (self , 0) } }
#[doc = "CMAR2\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar2Spec ; impl crate :: RegisterSpec for Cmar2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar2::R`](R) reader structure"] impl crate :: Readable for Cmar2Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar2::W`](W) writer structure"] impl crate :: Writable for Cmar2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR2 to value 0"] impl crate :: Resettable for Cmar2Spec { } }
#[doc = "CMAR3 (rw) register accessor: CMAR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar3`] module"]
#[doc (alias = "CMAR3")] pub type Cmar3 = crate :: Reg < cmar3 :: Cmar3Spec > ;
#[doc = "CMAR3"] pub mod cmar3 {
#[doc = "Register `CMAR3` reader"] pub type R = crate :: R < Cmar3Spec > ;
#[doc = "Register `CMAR3` writer"] pub type W = crate :: W < Cmar3Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar3Spec > { MaW :: new (self , 0) } }
#[doc = "CMAR3\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar3Spec ; impl crate :: RegisterSpec for Cmar3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar3::R`](R) reader structure"] impl crate :: Readable for Cmar3Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar3::W`](W) writer structure"] impl crate :: Writable for Cmar3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR3 to value 0"] impl crate :: Resettable for Cmar3Spec { } }
#[doc = "CMAR4 (rw) register accessor: CMAR4\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar4`] module"]
#[doc (alias = "CMAR4")] pub type Cmar4 = crate :: Reg < cmar4 :: Cmar4Spec > ;
#[doc = "CMAR4"] pub mod cmar4 {
#[doc = "Register `CMAR4` reader"] pub type R = crate :: R < Cmar4Spec > ;
#[doc = "Register `CMAR4` writer"] pub type W = crate :: W < Cmar4Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar4Spec > { MaW :: new (self , 0) } }
#[doc = "CMAR4\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar4Spec ; impl crate :: RegisterSpec for Cmar4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar4::R`](R) reader structure"] impl crate :: Readable for Cmar4Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar4::W`](W) writer structure"] impl crate :: Writable for Cmar4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR4 to value 0"] impl crate :: Resettable for Cmar4Spec { } }
#[doc = "CMAR5 (rw) register accessor: CMAR5\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmar5`] module"]
#[doc (alias = "CMAR5")] pub type Cmar5 = crate :: Reg < cmar5 :: Cmar5Spec > ;
#[doc = "CMAR5"] pub mod cmar5 {
#[doc = "Register `CMAR5` reader"] pub type R = crate :: R < Cmar5Spec > ;
#[doc = "Register `CMAR5` writer"] pub type W = crate :: W < Cmar5Spec > ;
#[doc = "Field `MA` reader - Memory address"] pub type MaR = crate :: FieldReader < u32 > ;
#[doc = "Field `MA` writer - Memory address"] pub type MaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& self) -> MaR { MaR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Memory address"]
#[inline (always)] pub fn ma (& mut self) -> MaW < '_ , Cmar5Spec > { MaW :: new (self , 0) } }
#[doc = "CMAR5\n\nYou can [`read`](crate::Reg::read) this register and get [`cmar5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmar5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cmar5Spec ; impl crate :: RegisterSpec for Cmar5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmar5::R`](R) reader structure"] impl crate :: Readable for Cmar5Spec { }
#[doc = "`write(|w| ..)` method takes [`cmar5::W`](W) writer structure"] impl crate :: Writable for Cmar5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMAR5 to value 0"] impl crate :: Resettable for Cmar5Spec { } } }
#[doc = "External interrupt/event controller"] pub type Exti = crate :: Periph < exti :: RegisterBlock , 0x4001_0000 > ; impl core :: fmt :: Debug for Exti { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Exti") . finish () } }
#[doc = "External interrupt/event controller"] pub mod exti {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cfgr : Cfgr , _reserved1 : [u8 ; 0x04] , cr1 : Cr1 , cr2 : Cr2 , cr3 : Cr3 , cr4 : Cr4 , _reserved5 : [u8 ; 0x03e8] , imr : Imr , emr : Emr , rtsr : Rtsr , ftsr : Ftsr , swier : Swier , pr : Pr , } impl RegisterBlock {
#[doc = "0x00 - Configuration register"]
#[inline (always)] pub const fn cfgr (& self) -> & Cfgr { & self . cfgr }
#[doc = "0x08 - External interrupt configuration register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x0c - External interrupt configuration register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x10 - External interrupt configuration register 3"]
#[inline (always)] pub const fn cr3 (& self) -> & Cr3 { & self . cr3 }
#[doc = "0x14 - External interrupt configuration register 4"]
#[inline (always)] pub const fn cr4 (& self) -> & Cr4 { & self . cr4 }
#[doc = "0x400 - Interrupt mask register"]
#[inline (always)] pub const fn imr (& self) -> & Imr { & self . imr }
#[doc = "0x404 - Event mask register"]
#[inline (always)] pub const fn emr (& self) -> & Emr { & self . emr }
#[doc = "0x408 - Rising trigger selection register"]
#[inline (always)] pub const fn rtsr (& self) -> & Rtsr { & self . rtsr }
#[doc = "0x40c - Falling trigger selection register"]
#[inline (always)] pub const fn ftsr (& self) -> & Ftsr { & self . ftsr }
#[doc = "0x410 - Software interrupt event register"]
#[inline (always)] pub const fn swier (& self) -> & Swier { & self . swier }
#[doc = "0x414 - Pending register"]
#[inline (always)] pub const fn pr (& self) -> & Pr { & self . pr } }
#[doc = "CFGR (rw) register accessor: Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
#[doc (alias = "CFGR")] pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ;
#[doc = "Configuration register"] pub mod cfgr {
#[doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ;
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ;
#[doc = "Field `MEM_MODE` reader - MEM_MODE"] pub type MemModeR = crate :: FieldReader ;
#[doc = "Field `MEM_MODE` writer - MEM_MODE"] pub type MemModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ADC_DMA` reader - ADC_DMA_RMP"] pub type AdcDmaR = crate :: BitReader ;
#[doc = "Field `ADC_DMA` writer - ADC_DMA_RMP"] pub type AdcDmaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART1_TX_DMA` reader - UART1_TX_DMA_RMP"] pub type Uart1TxDmaR = crate :: BitReader ;
#[doc = "Field `UART1_TX_DMA` writer - UART1_TX_DMA_RMP"] pub type Uart1TxDmaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART1_RX_DMA` reader - UART1_RX_DMA_RMP"] pub type Uart1RxDmaR = crate :: BitReader ;
#[doc = "Field `UART1_RX_DMA` writer - UART1_RX_DMA_RMP"] pub type Uart1RxDmaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM16_DMA` reader - TIM16_DMA_RMP"] pub type Tim16DmaR = crate :: BitReader ;
#[doc = "Field `TIM16_DMA` writer - TIM16_DMA_RMP"] pub type Tim16DmaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM17_DMA` reader - TIM17_DMA_RMP"] pub type Tim17DmaR = crate :: BitReader ;
#[doc = "Field `TIM17_DMA` writer - TIM17_DMA_RMP"] pub type Tim17DmaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - MEM_MODE"]
#[inline (always)] pub fn mem_mode (& self) -> MemModeR { MemModeR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 8 - ADC_DMA_RMP"]
#[inline (always)] pub fn adc_dma (& self) -> AdcDmaR { AdcDmaR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - UART1_TX_DMA_RMP"]
#[inline (always)] pub fn uart1_tx_dma (& self) -> Uart1TxDmaR { Uart1TxDmaR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - UART1_RX_DMA_RMP"]
#[inline (always)] pub fn uart1_rx_dma (& self) -> Uart1RxDmaR { Uart1RxDmaR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - TIM16_DMA_RMP"]
#[inline (always)] pub fn tim16_dma (& self) -> Tim16DmaR { Tim16DmaR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - TIM17_DMA_RMP"]
#[inline (always)] pub fn tim17_dma (& self) -> Tim17DmaR { Tim17DmaR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - MEM_MODE"]
#[inline (always)] pub fn mem_mode (& mut self) -> MemModeW < '_ , CfgrSpec > { MemModeW :: new (self , 0) }
#[doc = "Bit 8 - ADC_DMA_RMP"]
#[inline (always)] pub fn adc_dma (& mut self) -> AdcDmaW < '_ , CfgrSpec > { AdcDmaW :: new (self , 8) }
#[doc = "Bit 9 - UART1_TX_DMA_RMP"]
#[inline (always)] pub fn uart1_tx_dma (& mut self) -> Uart1TxDmaW < '_ , CfgrSpec > { Uart1TxDmaW :: new (self , 9) }
#[doc = "Bit 10 - UART1_RX_DMA_RMP"]
#[inline (always)] pub fn uart1_rx_dma (& mut self) -> Uart1RxDmaW < '_ , CfgrSpec > { Uart1RxDmaW :: new (self , 10) }
#[doc = "Bit 11 - TIM16_DMA_RMP"]
#[inline (always)] pub fn tim16_dma (& mut self) -> Tim16DmaW < '_ , CfgrSpec > { Tim16DmaW :: new (self , 11) }
#[doc = "Bit 12 - TIM17_DMA_RMP"]
#[inline (always)] pub fn tim17_dma (& mut self) -> Tim17DmaW < '_ , CfgrSpec > { Tim17DmaW :: new (self , 12) } }
#[doc = "Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0"] impl crate :: Resettable for CfgrSpec { } }
#[doc = "CR1 (rw) register accessor: External interrupt configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "External interrupt configuration register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `EXTI0` reader - EXTI0 configuration"] pub type Exti0R = crate :: FieldReader ;
#[doc = "Field `EXTI0` writer - EXTI0 configuration"] pub type Exti0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI1` reader - EXTI1 configuration"] pub type Exti1R = crate :: FieldReader ;
#[doc = "Field `EXTI1` writer - EXTI1 configuration"] pub type Exti1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI2` reader - EXTI2 configuration"] pub type Exti2R = crate :: FieldReader ;
#[doc = "Field `EXTI2` writer - EXTI2 configuration"] pub type Exti2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI3` reader - EXTI3 configuration"] pub type Exti3R = crate :: FieldReader ;
#[doc = "Field `EXTI3` writer - EXTI3 configuration"] pub type Exti3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - EXTI0 configuration"]
#[inline (always)] pub fn exti0 (& self) -> Exti0R { Exti0R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - EXTI1 configuration"]
#[inline (always)] pub fn exti1 (& self) -> Exti1R { Exti1R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - EXTI2 configuration"]
#[inline (always)] pub fn exti2 (& self) -> Exti2R { Exti2R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - EXTI3 configuration"]
#[inline (always)] pub fn exti3 (& self) -> Exti3R { Exti3R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - EXTI0 configuration"]
#[inline (always)] pub fn exti0 (& mut self) -> Exti0W < '_ , Cr1Spec > { Exti0W :: new (self , 0) }
#[doc = "Bits 4:7 - EXTI1 configuration"]
#[inline (always)] pub fn exti1 (& mut self) -> Exti1W < '_ , Cr1Spec > { Exti1W :: new (self , 4) }
#[doc = "Bits 8:11 - EXTI2 configuration"]
#[inline (always)] pub fn exti2 (& mut self) -> Exti2W < '_ , Cr1Spec > { Exti2W :: new (self , 8) }
#[doc = "Bits 12:15 - EXTI3 configuration"]
#[inline (always)] pub fn exti3 (& mut self) -> Exti3W < '_ , Cr1Spec > { Exti3W :: new (self , 12) } }
#[doc = "External interrupt configuration register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: External interrupt configuration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "External interrupt configuration register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `EXTI4` reader - EXTI4 configuration"] pub type Exti4R = crate :: FieldReader ;
#[doc = "Field `EXTI4` writer - EXTI4 configuration"] pub type Exti4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI5` reader - EXTI5 configuration"] pub type Exti5R = crate :: FieldReader ;
#[doc = "Field `EXTI5` writer - EXTI5 configuration"] pub type Exti5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI6` reader - EXTI6 configuration"] pub type Exti6R = crate :: FieldReader ;
#[doc = "Field `EXTI6` writer - EXTI6 configuration"] pub type Exti6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI7` reader - EXTI7 configuration"] pub type Exti7R = crate :: FieldReader ;
#[doc = "Field `EXTI7` writer - EXTI7 configuration"] pub type Exti7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - EXTI4 configuration"]
#[inline (always)] pub fn exti4 (& self) -> Exti4R { Exti4R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - EXTI5 configuration"]
#[inline (always)] pub fn exti5 (& self) -> Exti5R { Exti5R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - EXTI6 configuration"]
#[inline (always)] pub fn exti6 (& self) -> Exti6R { Exti6R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - EXTI7 configuration"]
#[inline (always)] pub fn exti7 (& self) -> Exti7R { Exti7R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - EXTI4 configuration"]
#[inline (always)] pub fn exti4 (& mut self) -> Exti4W < '_ , Cr2Spec > { Exti4W :: new (self , 0) }
#[doc = "Bits 4:7 - EXTI5 configuration"]
#[inline (always)] pub fn exti5 (& mut self) -> Exti5W < '_ , Cr2Spec > { Exti5W :: new (self , 4) }
#[doc = "Bits 8:11 - EXTI6 configuration"]
#[inline (always)] pub fn exti6 (& mut self) -> Exti6W < '_ , Cr2Spec > { Exti6W :: new (self , 8) }
#[doc = "Bits 12:15 - EXTI7 configuration"]
#[inline (always)] pub fn exti7 (& mut self) -> Exti7W < '_ , Cr2Spec > { Exti7W :: new (self , 12) } }
#[doc = "External interrupt configuration register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "CR3 (rw) register accessor: External interrupt configuration register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr3`] module"]
#[doc (alias = "CR3")] pub type Cr3 = crate :: Reg < cr3 :: Cr3Spec > ;
#[doc = "External interrupt configuration register 3"] pub mod cr3 {
#[doc = "Register `CR3` reader"] pub type R = crate :: R < Cr3Spec > ;
#[doc = "Register `CR3` writer"] pub type W = crate :: W < Cr3Spec > ;
#[doc = "Field `EXTI8` reader - EXTI8 configuration"] pub type Exti8R = crate :: FieldReader ;
#[doc = "Field `EXTI8` writer - EXTI8 configuration"] pub type Exti8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI9` reader - EXTI9 configuration"] pub type Exti9R = crate :: FieldReader ;
#[doc = "Field `EXTI9` writer - EXTI9 configuration"] pub type Exti9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI10` reader - EXTI10 configuration"] pub type Exti10R = crate :: FieldReader ;
#[doc = "Field `EXTI10` writer - EXTI10 configuration"] pub type Exti10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI11` reader - EXTI11 configuration"] pub type Exti11R = crate :: FieldReader ;
#[doc = "Field `EXTI11` writer - EXTI11 configuration"] pub type Exti11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - EXTI8 configuration"]
#[inline (always)] pub fn exti8 (& self) -> Exti8R { Exti8R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - EXTI9 configuration"]
#[inline (always)] pub fn exti9 (& self) -> Exti9R { Exti9R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - EXTI10 configuration"]
#[inline (always)] pub fn exti10 (& self) -> Exti10R { Exti10R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - EXTI11 configuration"]
#[inline (always)] pub fn exti11 (& self) -> Exti11R { Exti11R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - EXTI8 configuration"]
#[inline (always)] pub fn exti8 (& mut self) -> Exti8W < '_ , Cr3Spec > { Exti8W :: new (self , 0) }
#[doc = "Bits 4:7 - EXTI9 configuration"]
#[inline (always)] pub fn exti9 (& mut self) -> Exti9W < '_ , Cr3Spec > { Exti9W :: new (self , 4) }
#[doc = "Bits 8:11 - EXTI10 configuration"]
#[inline (always)] pub fn exti10 (& mut self) -> Exti10W < '_ , Cr3Spec > { Exti10W :: new (self , 8) }
#[doc = "Bits 12:15 - EXTI11 configuration"]
#[inline (always)] pub fn exti11 (& mut self) -> Exti11W < '_ , Cr3Spec > { Exti11W :: new (self , 12) } }
#[doc = "External interrupt configuration register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`cr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr3Spec ; impl crate :: RegisterSpec for Cr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr3::R`](R) reader structure"] impl crate :: Readable for Cr3Spec { }
#[doc = "`write(|w| ..)` method takes [`cr3::W`](W) writer structure"] impl crate :: Writable for Cr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR3 to value 0"] impl crate :: Resettable for Cr3Spec { } }
#[doc = "CR4 (rw) register accessor: External interrupt configuration register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`cr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr4`] module"]
#[doc (alias = "CR4")] pub type Cr4 = crate :: Reg < cr4 :: Cr4Spec > ;
#[doc = "External interrupt configuration register 4"] pub mod cr4 {
#[doc = "Register `CR4` reader"] pub type R = crate :: R < Cr4Spec > ;
#[doc = "Register `CR4` writer"] pub type W = crate :: W < Cr4Spec > ;
#[doc = "Field `EXTI12` reader - EXTI12 configuration"] pub type Exti12R = crate :: FieldReader ;
#[doc = "Field `EXTI12` writer - EXTI12 configuration"] pub type Exti12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI13` reader - EXTI13 configuration"] pub type Exti13R = crate :: FieldReader ;
#[doc = "Field `EXTI13` writer - EXTI13 configuration"] pub type Exti13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI14` reader - EXTI14 configuration"] pub type Exti14R = crate :: FieldReader ;
#[doc = "Field `EXTI14` writer - EXTI14 configuration"] pub type Exti14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `EXTI15` reader - EXTI15 configuration"] pub type Exti15R = crate :: FieldReader ;
#[doc = "Field `EXTI15` writer - EXTI15 configuration"] pub type Exti15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - EXTI12 configuration"]
#[inline (always)] pub fn exti12 (& self) -> Exti12R { Exti12R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - EXTI13 configuration"]
#[inline (always)] pub fn exti13 (& self) -> Exti13R { Exti13R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - EXTI14 configuration"]
#[inline (always)] pub fn exti14 (& self) -> Exti14R { Exti14R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - EXTI15 configuration"]
#[inline (always)] pub fn exti15 (& self) -> Exti15R { Exti15R :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - EXTI12 configuration"]
#[inline (always)] pub fn exti12 (& mut self) -> Exti12W < '_ , Cr4Spec > { Exti12W :: new (self , 0) }
#[doc = "Bits 4:7 - EXTI13 configuration"]
#[inline (always)] pub fn exti13 (& mut self) -> Exti13W < '_ , Cr4Spec > { Exti13W :: new (self , 4) }
#[doc = "Bits 8:11 - EXTI14 configuration"]
#[inline (always)] pub fn exti14 (& mut self) -> Exti14W < '_ , Cr4Spec > { Exti14W :: new (self , 8) }
#[doc = "Bits 12:15 - EXTI15 configuration"]
#[inline (always)] pub fn exti15 (& mut self) -> Exti15W < '_ , Cr4Spec > { Exti15W :: new (self , 12) } }
#[doc = "External interrupt configuration register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`cr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr4Spec ; impl crate :: RegisterSpec for Cr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr4::R`](R) reader structure"] impl crate :: Readable for Cr4Spec { }
#[doc = "`write(|w| ..)` method takes [`cr4::W`](W) writer structure"] impl crate :: Writable for Cr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR4 to value 0"] impl crate :: Resettable for Cr4Spec { } }
#[doc = "IMR (rw) register accessor: Interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`imr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`imr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@imr`] module"]
#[doc (alias = "IMR")] pub type Imr = crate :: Reg < imr :: ImrSpec > ;
#[doc = "Interrupt mask register"] pub mod imr {
#[doc = "Register `IMR` reader"] pub type R = crate :: R < ImrSpec > ;
#[doc = "Register `IMR` writer"] pub type W = crate :: W < ImrSpec > ;
#[doc = "Field `IMR0` reader - Interrupt Mask on line 0"] pub type Imr0R = crate :: BitReader ;
#[doc = "Field `IMR0` writer - Interrupt Mask on line 0"] pub type Imr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR1` reader - Interrupt Mask on line 1"] pub type Imr1R = crate :: BitReader ;
#[doc = "Field `IMR1` writer - Interrupt Mask on line 1"] pub type Imr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR2` reader - Interrupt Mask on line 2"] pub type Imr2R = crate :: BitReader ;
#[doc = "Field `IMR2` writer - Interrupt Mask on line 2"] pub type Imr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR3` reader - Interrupt Mask on line 3"] pub type Imr3R = crate :: BitReader ;
#[doc = "Field `IMR3` writer - Interrupt Mask on line 3"] pub type Imr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR4` reader - Interrupt Mask on line 4"] pub type Imr4R = crate :: BitReader ;
#[doc = "Field `IMR4` writer - Interrupt Mask on line 4"] pub type Imr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR5` reader - Interrupt Mask on line 5"] pub type Imr5R = crate :: BitReader ;
#[doc = "Field `IMR5` writer - Interrupt Mask on line 5"] pub type Imr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR6` reader - Interrupt Mask on line 6"] pub type Imr6R = crate :: BitReader ;
#[doc = "Field `IMR6` writer - Interrupt Mask on line 6"] pub type Imr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR7` reader - Interrupt Mask on line 7"] pub type Imr7R = crate :: BitReader ;
#[doc = "Field `IMR7` writer - Interrupt Mask on line 7"] pub type Imr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR8` reader - Interrupt Mask on line 8"] pub type Imr8R = crate :: BitReader ;
#[doc = "Field `IMR8` writer - Interrupt Mask on line 8"] pub type Imr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR9` reader - Interrupt Mask on line 9"] pub type Imr9R = crate :: BitReader ;
#[doc = "Field `IMR9` writer - Interrupt Mask on line 9"] pub type Imr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR10` reader - Interrupt Mask on line 10"] pub type Imr10R = crate :: BitReader ;
#[doc = "Field `IMR10` writer - Interrupt Mask on line 10"] pub type Imr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR11` reader - Interrupt Mask on line 11"] pub type Imr11R = crate :: BitReader ;
#[doc = "Field `IMR11` writer - Interrupt Mask on line 11"] pub type Imr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR12` reader - Interrupt Mask on line 12"] pub type Imr12R = crate :: BitReader ;
#[doc = "Field `IMR12` writer - Interrupt Mask on line 12"] pub type Imr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR13` reader - Interrupt Mask on line 13"] pub type Imr13R = crate :: BitReader ;
#[doc = "Field `IMR13` writer - Interrupt Mask on line 13"] pub type Imr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR14` reader - Interrupt Mask on line 14"] pub type Imr14R = crate :: BitReader ;
#[doc = "Field `IMR14` writer - Interrupt Mask on line 14"] pub type Imr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR15` reader - Interrupt Mask on line 15"] pub type Imr15R = crate :: BitReader ;
#[doc = "Field `IMR15` writer - Interrupt Mask on line 15"] pub type Imr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR16` reader - Interrupt Mask on line 16"] pub type Imr16R = crate :: BitReader ;
#[doc = "Field `IMR16` writer - Interrupt Mask on line 16"] pub type Imr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR19` reader - Interrupt Mask on line 19"] pub type Imr19R = crate :: BitReader ;
#[doc = "Field `IMR19` writer - Interrupt Mask on line 19"] pub type Imr19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IMR24` reader - Interrupt Mask on line 24"] pub type Imr24R = crate :: BitReader ;
#[doc = "Field `IMR24` writer - Interrupt Mask on line 24"] pub type Imr24W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Interrupt Mask on line 0"]
#[inline (always)] pub fn imr0 (& self) -> Imr0R { Imr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Interrupt Mask on line 1"]
#[inline (always)] pub fn imr1 (& self) -> Imr1R { Imr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Interrupt Mask on line 2"]
#[inline (always)] pub fn imr2 (& self) -> Imr2R { Imr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Interrupt Mask on line 3"]
#[inline (always)] pub fn imr3 (& self) -> Imr3R { Imr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Interrupt Mask on line 4"]
#[inline (always)] pub fn imr4 (& self) -> Imr4R { Imr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Interrupt Mask on line 5"]
#[inline (always)] pub fn imr5 (& self) -> Imr5R { Imr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Interrupt Mask on line 6"]
#[inline (always)] pub fn imr6 (& self) -> Imr6R { Imr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Interrupt Mask on line 7"]
#[inline (always)] pub fn imr7 (& self) -> Imr7R { Imr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Interrupt Mask on line 8"]
#[inline (always)] pub fn imr8 (& self) -> Imr8R { Imr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Interrupt Mask on line 9"]
#[inline (always)] pub fn imr9 (& self) -> Imr9R { Imr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Interrupt Mask on line 10"]
#[inline (always)] pub fn imr10 (& self) -> Imr10R { Imr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Interrupt Mask on line 11"]
#[inline (always)] pub fn imr11 (& self) -> Imr11R { Imr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Interrupt Mask on line 12"]
#[inline (always)] pub fn imr12 (& self) -> Imr12R { Imr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Interrupt Mask on line 13"]
#[inline (always)] pub fn imr13 (& self) -> Imr13R { Imr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Interrupt Mask on line 14"]
#[inline (always)] pub fn imr14 (& self) -> Imr14R { Imr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Interrupt Mask on line 15"]
#[inline (always)] pub fn imr15 (& self) -> Imr15R { Imr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Interrupt Mask on line 16"]
#[inline (always)] pub fn imr16 (& self) -> Imr16R { Imr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 19 - Interrupt Mask on line 19"]
#[inline (always)] pub fn imr19 (& self) -> Imr19R { Imr19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 24 - Interrupt Mask on line 24"]
#[inline (always)] pub fn imr24 (& self) -> Imr24R { Imr24R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Interrupt Mask on line 0"]
#[inline (always)] pub fn imr0 (& mut self) -> Imr0W < '_ , ImrSpec > { Imr0W :: new (self , 0) }
#[doc = "Bit 1 - Interrupt Mask on line 1"]
#[inline (always)] pub fn imr1 (& mut self) -> Imr1W < '_ , ImrSpec > { Imr1W :: new (self , 1) }
#[doc = "Bit 2 - Interrupt Mask on line 2"]
#[inline (always)] pub fn imr2 (& mut self) -> Imr2W < '_ , ImrSpec > { Imr2W :: new (self , 2) }
#[doc = "Bit 3 - Interrupt Mask on line 3"]
#[inline (always)] pub fn imr3 (& mut self) -> Imr3W < '_ , ImrSpec > { Imr3W :: new (self , 3) }
#[doc = "Bit 4 - Interrupt Mask on line 4"]
#[inline (always)] pub fn imr4 (& mut self) -> Imr4W < '_ , ImrSpec > { Imr4W :: new (self , 4) }
#[doc = "Bit 5 - Interrupt Mask on line 5"]
#[inline (always)] pub fn imr5 (& mut self) -> Imr5W < '_ , ImrSpec > { Imr5W :: new (self , 5) }
#[doc = "Bit 6 - Interrupt Mask on line 6"]
#[inline (always)] pub fn imr6 (& mut self) -> Imr6W < '_ , ImrSpec > { Imr6W :: new (self , 6) }
#[doc = "Bit 7 - Interrupt Mask on line 7"]
#[inline (always)] pub fn imr7 (& mut self) -> Imr7W < '_ , ImrSpec > { Imr7W :: new (self , 7) }
#[doc = "Bit 8 - Interrupt Mask on line 8"]
#[inline (always)] pub fn imr8 (& mut self) -> Imr8W < '_ , ImrSpec > { Imr8W :: new (self , 8) }
#[doc = "Bit 9 - Interrupt Mask on line 9"]
#[inline (always)] pub fn imr9 (& mut self) -> Imr9W < '_ , ImrSpec > { Imr9W :: new (self , 9) }
#[doc = "Bit 10 - Interrupt Mask on line 10"]
#[inline (always)] pub fn imr10 (& mut self) -> Imr10W < '_ , ImrSpec > { Imr10W :: new (self , 10) }
#[doc = "Bit 11 - Interrupt Mask on line 11"]
#[inline (always)] pub fn imr11 (& mut self) -> Imr11W < '_ , ImrSpec > { Imr11W :: new (self , 11) }
#[doc = "Bit 12 - Interrupt Mask on line 12"]
#[inline (always)] pub fn imr12 (& mut self) -> Imr12W < '_ , ImrSpec > { Imr12W :: new (self , 12) }
#[doc = "Bit 13 - Interrupt Mask on line 13"]
#[inline (always)] pub fn imr13 (& mut self) -> Imr13W < '_ , ImrSpec > { Imr13W :: new (self , 13) }
#[doc = "Bit 14 - Interrupt Mask on line 14"]
#[inline (always)] pub fn imr14 (& mut self) -> Imr14W < '_ , ImrSpec > { Imr14W :: new (self , 14) }
#[doc = "Bit 15 - Interrupt Mask on line 15"]
#[inline (always)] pub fn imr15 (& mut self) -> Imr15W < '_ , ImrSpec > { Imr15W :: new (self , 15) }
#[doc = "Bit 16 - Interrupt Mask on line 16"]
#[inline (always)] pub fn imr16 (& mut self) -> Imr16W < '_ , ImrSpec > { Imr16W :: new (self , 16) }
#[doc = "Bit 19 - Interrupt Mask on line 19"]
#[inline (always)] pub fn imr19 (& mut self) -> Imr19W < '_ , ImrSpec > { Imr19W :: new (self , 19) }
#[doc = "Bit 24 - Interrupt Mask on line 24"]
#[inline (always)] pub fn imr24 (& mut self) -> Imr24W < '_ , ImrSpec > { Imr24W :: new (self , 24) } }
#[doc = "Interrupt mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`imr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`imr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ImrSpec ; impl crate :: RegisterSpec for ImrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`imr::R`](R) reader structure"] impl crate :: Readable for ImrSpec { }
#[doc = "`write(|w| ..)` method takes [`imr::W`](W) writer structure"] impl crate :: Writable for ImrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IMR to value 0"] impl crate :: Resettable for ImrSpec { } }
#[doc = "EMR (rw) register accessor: Event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`emr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`emr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@emr`] module"]
#[doc (alias = "EMR")] pub type Emr = crate :: Reg < emr :: EmrSpec > ;
#[doc = "Event mask register"] pub mod emr {
#[doc = "Register `EMR` reader"] pub type R = crate :: R < EmrSpec > ;
#[doc = "Register `EMR` writer"] pub type W = crate :: W < EmrSpec > ;
#[doc = "Field `EMR0` reader - Event Mask on line 0"] pub type Emr0R = crate :: BitReader ;
#[doc = "Field `EMR0` writer - Event Mask on line 0"] pub type Emr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR1` reader - Event Mask on line 1"] pub type Emr1R = crate :: BitReader ;
#[doc = "Field `EMR1` writer - Event Mask on line 1"] pub type Emr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR2` reader - Event Mask on line 2"] pub type Emr2R = crate :: BitReader ;
#[doc = "Field `EMR2` writer - Event Mask on line 2"] pub type Emr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR3` reader - Event Mask on line 3"] pub type Emr3R = crate :: BitReader ;
#[doc = "Field `EMR3` writer - Event Mask on line 3"] pub type Emr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR4` reader - Event Mask on line 4"] pub type Emr4R = crate :: BitReader ;
#[doc = "Field `EMR4` writer - Event Mask on line 4"] pub type Emr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR5` reader - Event Mask on line 5"] pub type Emr5R = crate :: BitReader ;
#[doc = "Field `EMR5` writer - Event Mask on line 5"] pub type Emr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR6` reader - Event Mask on line 6"] pub type Emr6R = crate :: BitReader ;
#[doc = "Field `EMR6` writer - Event Mask on line 6"] pub type Emr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR7` reader - Event Mask on line 7"] pub type Emr7R = crate :: BitReader ;
#[doc = "Field `EMR7` writer - Event Mask on line 7"] pub type Emr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR8` reader - Event Mask on line 8"] pub type Emr8R = crate :: BitReader ;
#[doc = "Field `EMR8` writer - Event Mask on line 8"] pub type Emr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR9` reader - Event Mask on line 9"] pub type Emr9R = crate :: BitReader ;
#[doc = "Field `EMR9` writer - Event Mask on line 9"] pub type Emr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR10` reader - Event Mask on line 10"] pub type Emr10R = crate :: BitReader ;
#[doc = "Field `EMR10` writer - Event Mask on line 10"] pub type Emr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR11` reader - Event Mask on line 11"] pub type Emr11R = crate :: BitReader ;
#[doc = "Field `EMR11` writer - Event Mask on line 11"] pub type Emr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR12` reader - Event Mask on line 12"] pub type Emr12R = crate :: BitReader ;
#[doc = "Field `EMR12` writer - Event Mask on line 12"] pub type Emr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR13` reader - Event Mask on line 13"] pub type Emr13R = crate :: BitReader ;
#[doc = "Field `EMR13` writer - Event Mask on line 13"] pub type Emr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR14` reader - Event Mask on line 14"] pub type Emr14R = crate :: BitReader ;
#[doc = "Field `EMR14` writer - Event Mask on line 14"] pub type Emr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR15` reader - Event Mask on line 15"] pub type Emr15R = crate :: BitReader ;
#[doc = "Field `EMR15` writer - Event Mask on line 15"] pub type Emr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR16` reader - Event Mask on line 16"] pub type Emr16R = crate :: BitReader ;
#[doc = "Field `EMR16` writer - Event Mask on line 16"] pub type Emr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR19` reader - Event Mask on line 19"] pub type Emr19R = crate :: BitReader ;
#[doc = "Field `EMR19` writer - Event Mask on line 19"] pub type Emr19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMR24` reader - Event Mask on line 24"] pub type Emr24R = crate :: BitReader ;
#[doc = "Field `EMR24` writer - Event Mask on line 24"] pub type Emr24W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Event Mask on line 0"]
#[inline (always)] pub fn emr0 (& self) -> Emr0R { Emr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Event Mask on line 1"]
#[inline (always)] pub fn emr1 (& self) -> Emr1R { Emr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Event Mask on line 2"]
#[inline (always)] pub fn emr2 (& self) -> Emr2R { Emr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Event Mask on line 3"]
#[inline (always)] pub fn emr3 (& self) -> Emr3R { Emr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Event Mask on line 4"]
#[inline (always)] pub fn emr4 (& self) -> Emr4R { Emr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Event Mask on line 5"]
#[inline (always)] pub fn emr5 (& self) -> Emr5R { Emr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Event Mask on line 6"]
#[inline (always)] pub fn emr6 (& self) -> Emr6R { Emr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Event Mask on line 7"]
#[inline (always)] pub fn emr7 (& self) -> Emr7R { Emr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Event Mask on line 8"]
#[inline (always)] pub fn emr8 (& self) -> Emr8R { Emr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Event Mask on line 9"]
#[inline (always)] pub fn emr9 (& self) -> Emr9R { Emr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Event Mask on line 10"]
#[inline (always)] pub fn emr10 (& self) -> Emr10R { Emr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Event Mask on line 11"]
#[inline (always)] pub fn emr11 (& self) -> Emr11R { Emr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Event Mask on line 12"]
#[inline (always)] pub fn emr12 (& self) -> Emr12R { Emr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Event Mask on line 13"]
#[inline (always)] pub fn emr13 (& self) -> Emr13R { Emr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Event Mask on line 14"]
#[inline (always)] pub fn emr14 (& self) -> Emr14R { Emr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Event Mask on line 15"]
#[inline (always)] pub fn emr15 (& self) -> Emr15R { Emr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Event Mask on line 16"]
#[inline (always)] pub fn emr16 (& self) -> Emr16R { Emr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 19 - Event Mask on line 19"]
#[inline (always)] pub fn emr19 (& self) -> Emr19R { Emr19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 24 - Event Mask on line 24"]
#[inline (always)] pub fn emr24 (& self) -> Emr24R { Emr24R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Event Mask on line 0"]
#[inline (always)] pub fn emr0 (& mut self) -> Emr0W < '_ , EmrSpec > { Emr0W :: new (self , 0) }
#[doc = "Bit 1 - Event Mask on line 1"]
#[inline (always)] pub fn emr1 (& mut self) -> Emr1W < '_ , EmrSpec > { Emr1W :: new (self , 1) }
#[doc = "Bit 2 - Event Mask on line 2"]
#[inline (always)] pub fn emr2 (& mut self) -> Emr2W < '_ , EmrSpec > { Emr2W :: new (self , 2) }
#[doc = "Bit 3 - Event Mask on line 3"]
#[inline (always)] pub fn emr3 (& mut self) -> Emr3W < '_ , EmrSpec > { Emr3W :: new (self , 3) }
#[doc = "Bit 4 - Event Mask on line 4"]
#[inline (always)] pub fn emr4 (& mut self) -> Emr4W < '_ , EmrSpec > { Emr4W :: new (self , 4) }
#[doc = "Bit 5 - Event Mask on line 5"]
#[inline (always)] pub fn emr5 (& mut self) -> Emr5W < '_ , EmrSpec > { Emr5W :: new (self , 5) }
#[doc = "Bit 6 - Event Mask on line 6"]
#[inline (always)] pub fn emr6 (& mut self) -> Emr6W < '_ , EmrSpec > { Emr6W :: new (self , 6) }
#[doc = "Bit 7 - Event Mask on line 7"]
#[inline (always)] pub fn emr7 (& mut self) -> Emr7W < '_ , EmrSpec > { Emr7W :: new (self , 7) }
#[doc = "Bit 8 - Event Mask on line 8"]
#[inline (always)] pub fn emr8 (& mut self) -> Emr8W < '_ , EmrSpec > { Emr8W :: new (self , 8) }
#[doc = "Bit 9 - Event Mask on line 9"]
#[inline (always)] pub fn emr9 (& mut self) -> Emr9W < '_ , EmrSpec > { Emr9W :: new (self , 9) }
#[doc = "Bit 10 - Event Mask on line 10"]
#[inline (always)] pub fn emr10 (& mut self) -> Emr10W < '_ , EmrSpec > { Emr10W :: new (self , 10) }
#[doc = "Bit 11 - Event Mask on line 11"]
#[inline (always)] pub fn emr11 (& mut self) -> Emr11W < '_ , EmrSpec > { Emr11W :: new (self , 11) }
#[doc = "Bit 12 - Event Mask on line 12"]
#[inline (always)] pub fn emr12 (& mut self) -> Emr12W < '_ , EmrSpec > { Emr12W :: new (self , 12) }
#[doc = "Bit 13 - Event Mask on line 13"]
#[inline (always)] pub fn emr13 (& mut self) -> Emr13W < '_ , EmrSpec > { Emr13W :: new (self , 13) }
#[doc = "Bit 14 - Event Mask on line 14"]
#[inline (always)] pub fn emr14 (& mut self) -> Emr14W < '_ , EmrSpec > { Emr14W :: new (self , 14) }
#[doc = "Bit 15 - Event Mask on line 15"]
#[inline (always)] pub fn emr15 (& mut self) -> Emr15W < '_ , EmrSpec > { Emr15W :: new (self , 15) }
#[doc = "Bit 16 - Event Mask on line 16"]
#[inline (always)] pub fn emr16 (& mut self) -> Emr16W < '_ , EmrSpec > { Emr16W :: new (self , 16) }
#[doc = "Bit 19 - Event Mask on line 19"]
#[inline (always)] pub fn emr19 (& mut self) -> Emr19W < '_ , EmrSpec > { Emr19W :: new (self , 19) }
#[doc = "Bit 24 - Event Mask on line 24"]
#[inline (always)] pub fn emr24 (& mut self) -> Emr24W < '_ , EmrSpec > { Emr24W :: new (self , 24) } }
#[doc = "Event mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`emr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`emr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EmrSpec ; impl crate :: RegisterSpec for EmrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`emr::R`](R) reader structure"] impl crate :: Readable for EmrSpec { }
#[doc = "`write(|w| ..)` method takes [`emr::W`](W) writer structure"] impl crate :: Writable for EmrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EMR to value 0"] impl crate :: Resettable for EmrSpec { } }
#[doc = "RTSR (rw) register accessor: Rising trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtsr`] module"]
#[doc (alias = "RTSR")] pub type Rtsr = crate :: Reg < rtsr :: RtsrSpec > ;
#[doc = "Rising trigger selection register"] pub mod rtsr {
#[doc = "Register `RTSR` reader"] pub type R = crate :: R < RtsrSpec > ;
#[doc = "Register `RTSR` writer"] pub type W = crate :: W < RtsrSpec > ;
#[doc = "Field `TR0` reader - Rising trigger event configuration bit of line 0"] pub type Tr0R = crate :: BitReader ;
#[doc = "Field `TR0` writer - Rising trigger event configuration bit of line 0"] pub type Tr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR1` reader - Rising trigger event configuration bit of line 1"] pub type Tr1R = crate :: BitReader ;
#[doc = "Field `TR1` writer - Rising trigger event configuration bit of line 1"] pub type Tr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR2` reader - Rising trigger event configuration bit of line 2"] pub type Tr2R = crate :: BitReader ;
#[doc = "Field `TR2` writer - Rising trigger event configuration bit of line 2"] pub type Tr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR3` reader - Rising trigger event configuration bit of line 3"] pub type Tr3R = crate :: BitReader ;
#[doc = "Field `TR3` writer - Rising trigger event configuration bit of line 3"] pub type Tr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR4` reader - Rising trigger event configuration bit of line 4"] pub type Tr4R = crate :: BitReader ;
#[doc = "Field `TR4` writer - Rising trigger event configuration bit of line 4"] pub type Tr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR5` reader - Rising trigger event configuration bit of line 5"] pub type Tr5R = crate :: BitReader ;
#[doc = "Field `TR5` writer - Rising trigger event configuration bit of line 5"] pub type Tr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR6` reader - Rising trigger event configuration bit of line 6"] pub type Tr6R = crate :: BitReader ;
#[doc = "Field `TR6` writer - Rising trigger event configuration bit of line 6"] pub type Tr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR7` reader - Rising trigger event configuration bit of line 7"] pub type Tr7R = crate :: BitReader ;
#[doc = "Field `TR7` writer - Rising trigger event configuration bit of line 7"] pub type Tr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR8` reader - Rising trigger event configuration bit of line 8"] pub type Tr8R = crate :: BitReader ;
#[doc = "Field `TR8` writer - Rising trigger event configuration bit of line 8"] pub type Tr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR9` reader - Rising trigger event configuration bit of line 9"] pub type Tr9R = crate :: BitReader ;
#[doc = "Field `TR9` writer - Rising trigger event configuration bit of line 9"] pub type Tr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR10` reader - Rising trigger event configuration bit of line 10"] pub type Tr10R = crate :: BitReader ;
#[doc = "Field `TR10` writer - Rising trigger event configuration bit of line 10"] pub type Tr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR11` reader - Rising trigger event configuration bit of line 11"] pub type Tr11R = crate :: BitReader ;
#[doc = "Field `TR11` writer - Rising trigger event configuration bit of line 11"] pub type Tr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR12` reader - Rising trigger event configuration bit of line 12"] pub type Tr12R = crate :: BitReader ;
#[doc = "Field `TR12` writer - Rising trigger event configuration bit of line 12"] pub type Tr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR13` reader - Rising trigger event configuration bit of line 13"] pub type Tr13R = crate :: BitReader ;
#[doc = "Field `TR13` writer - Rising trigger event configuration bit of line 13"] pub type Tr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR14` reader - Rising trigger event configuration bit of line 14"] pub type Tr14R = crate :: BitReader ;
#[doc = "Field `TR14` writer - Rising trigger event configuration bit of line 14"] pub type Tr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR15` reader - Rising trigger event configuration bit of line 15"] pub type Tr15R = crate :: BitReader ;
#[doc = "Field `TR15` writer - Rising trigger event configuration bit of line 15"] pub type Tr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR16` reader - Rising trigger event configuration bit of line 16"] pub type Tr16R = crate :: BitReader ;
#[doc = "Field `TR16` writer - Rising trigger event configuration bit of line 16"] pub type Tr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR19` reader - Rising trigger event configuration bit of line 19"] pub type Tr19R = crate :: BitReader ;
#[doc = "Field `TR19` writer - Rising trigger event configuration bit of line 19"] pub type Tr19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR24` reader - Rising trigger event configuration bit of line 24"] pub type Tr24R = crate :: BitReader ;
#[doc = "Field `TR24` writer - Rising trigger event configuration bit of line 24"] pub type Tr24W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Rising trigger event configuration bit of line 0"]
#[inline (always)] pub fn tr0 (& self) -> Tr0R { Tr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Rising trigger event configuration bit of line 1"]
#[inline (always)] pub fn tr1 (& self) -> Tr1R { Tr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Rising trigger event configuration bit of line 2"]
#[inline (always)] pub fn tr2 (& self) -> Tr2R { Tr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Rising trigger event configuration bit of line 3"]
#[inline (always)] pub fn tr3 (& self) -> Tr3R { Tr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Rising trigger event configuration bit of line 4"]
#[inline (always)] pub fn tr4 (& self) -> Tr4R { Tr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Rising trigger event configuration bit of line 5"]
#[inline (always)] pub fn tr5 (& self) -> Tr5R { Tr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Rising trigger event configuration bit of line 6"]
#[inline (always)] pub fn tr6 (& self) -> Tr6R { Tr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Rising trigger event configuration bit of line 7"]
#[inline (always)] pub fn tr7 (& self) -> Tr7R { Tr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Rising trigger event configuration bit of line 8"]
#[inline (always)] pub fn tr8 (& self) -> Tr8R { Tr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Rising trigger event configuration bit of line 9"]
#[inline (always)] pub fn tr9 (& self) -> Tr9R { Tr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Rising trigger event configuration bit of line 10"]
#[inline (always)] pub fn tr10 (& self) -> Tr10R { Tr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Rising trigger event configuration bit of line 11"]
#[inline (always)] pub fn tr11 (& self) -> Tr11R { Tr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Rising trigger event configuration bit of line 12"]
#[inline (always)] pub fn tr12 (& self) -> Tr12R { Tr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Rising trigger event configuration bit of line 13"]
#[inline (always)] pub fn tr13 (& self) -> Tr13R { Tr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Rising trigger event configuration bit of line 14"]
#[inline (always)] pub fn tr14 (& self) -> Tr14R { Tr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Rising trigger event configuration bit of line 15"]
#[inline (always)] pub fn tr15 (& self) -> Tr15R { Tr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Rising trigger event configuration bit of line 16"]
#[inline (always)] pub fn tr16 (& self) -> Tr16R { Tr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 19 - Rising trigger event configuration bit of line 19"]
#[inline (always)] pub fn tr19 (& self) -> Tr19R { Tr19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 24 - Rising trigger event configuration bit of line 24"]
#[inline (always)] pub fn tr24 (& self) -> Tr24R { Tr24R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Rising trigger event configuration bit of line 0"]
#[inline (always)] pub fn tr0 (& mut self) -> Tr0W < '_ , RtsrSpec > { Tr0W :: new (self , 0) }
#[doc = "Bit 1 - Rising trigger event configuration bit of line 1"]
#[inline (always)] pub fn tr1 (& mut self) -> Tr1W < '_ , RtsrSpec > { Tr1W :: new (self , 1) }
#[doc = "Bit 2 - Rising trigger event configuration bit of line 2"]
#[inline (always)] pub fn tr2 (& mut self) -> Tr2W < '_ , RtsrSpec > { Tr2W :: new (self , 2) }
#[doc = "Bit 3 - Rising trigger event configuration bit of line 3"]
#[inline (always)] pub fn tr3 (& mut self) -> Tr3W < '_ , RtsrSpec > { Tr3W :: new (self , 3) }
#[doc = "Bit 4 - Rising trigger event configuration bit of line 4"]
#[inline (always)] pub fn tr4 (& mut self) -> Tr4W < '_ , RtsrSpec > { Tr4W :: new (self , 4) }
#[doc = "Bit 5 - Rising trigger event configuration bit of line 5"]
#[inline (always)] pub fn tr5 (& mut self) -> Tr5W < '_ , RtsrSpec > { Tr5W :: new (self , 5) }
#[doc = "Bit 6 - Rising trigger event configuration bit of line 6"]
#[inline (always)] pub fn tr6 (& mut self) -> Tr6W < '_ , RtsrSpec > { Tr6W :: new (self , 6) }
#[doc = "Bit 7 - Rising trigger event configuration bit of line 7"]
#[inline (always)] pub fn tr7 (& mut self) -> Tr7W < '_ , RtsrSpec > { Tr7W :: new (self , 7) }
#[doc = "Bit 8 - Rising trigger event configuration bit of line 8"]
#[inline (always)] pub fn tr8 (& mut self) -> Tr8W < '_ , RtsrSpec > { Tr8W :: new (self , 8) }
#[doc = "Bit 9 - Rising trigger event configuration bit of line 9"]
#[inline (always)] pub fn tr9 (& mut self) -> Tr9W < '_ , RtsrSpec > { Tr9W :: new (self , 9) }
#[doc = "Bit 10 - Rising trigger event configuration bit of line 10"]
#[inline (always)] pub fn tr10 (& mut self) -> Tr10W < '_ , RtsrSpec > { Tr10W :: new (self , 10) }
#[doc = "Bit 11 - Rising trigger event configuration bit of line 11"]
#[inline (always)] pub fn tr11 (& mut self) -> Tr11W < '_ , RtsrSpec > { Tr11W :: new (self , 11) }
#[doc = "Bit 12 - Rising trigger event configuration bit of line 12"]
#[inline (always)] pub fn tr12 (& mut self) -> Tr12W < '_ , RtsrSpec > { Tr12W :: new (self , 12) }
#[doc = "Bit 13 - Rising trigger event configuration bit of line 13"]
#[inline (always)] pub fn tr13 (& mut self) -> Tr13W < '_ , RtsrSpec > { Tr13W :: new (self , 13) }
#[doc = "Bit 14 - Rising trigger event configuration bit of line 14"]
#[inline (always)] pub fn tr14 (& mut self) -> Tr14W < '_ , RtsrSpec > { Tr14W :: new (self , 14) }
#[doc = "Bit 15 - Rising trigger event configuration bit of line 15"]
#[inline (always)] pub fn tr15 (& mut self) -> Tr15W < '_ , RtsrSpec > { Tr15W :: new (self , 15) }
#[doc = "Bit 16 - Rising trigger event configuration bit of line 16"]
#[inline (always)] pub fn tr16 (& mut self) -> Tr16W < '_ , RtsrSpec > { Tr16W :: new (self , 16) }
#[doc = "Bit 19 - Rising trigger event configuration bit of line 19"]
#[inline (always)] pub fn tr19 (& mut self) -> Tr19W < '_ , RtsrSpec > { Tr19W :: new (self , 19) }
#[doc = "Bit 24 - Rising trigger event configuration bit of line 24"]
#[inline (always)] pub fn tr24 (& mut self) -> Tr24W < '_ , RtsrSpec > { Tr24W :: new (self , 24) } }
#[doc = "Rising trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RtsrSpec ; impl crate :: RegisterSpec for RtsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rtsr::R`](R) reader structure"] impl crate :: Readable for RtsrSpec { }
#[doc = "`write(|w| ..)` method takes [`rtsr::W`](W) writer structure"] impl crate :: Writable for RtsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTSR to value 0"] impl crate :: Resettable for RtsrSpec { } }
#[doc = "FTSR (rw) register accessor: Falling trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`ftsr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ftsr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ftsr`] module"]
#[doc (alias = "FTSR")] pub type Ftsr = crate :: Reg < ftsr :: FtsrSpec > ;
#[doc = "Falling trigger selection register"] pub mod ftsr {
#[doc = "Register `FTSR` reader"] pub type R = crate :: R < FtsrSpec > ;
#[doc = "Register `FTSR` writer"] pub type W = crate :: W < FtsrSpec > ;
#[doc = "Field `TR0` reader - Falling trigger event configuration bit of line 0"] pub type Tr0R = crate :: BitReader ;
#[doc = "Field `TR0` writer - Falling trigger event configuration bit of line 0"] pub type Tr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR1` reader - Falling trigger event configuration bit of line 1"] pub type Tr1R = crate :: BitReader ;
#[doc = "Field `TR1` writer - Falling trigger event configuration bit of line 1"] pub type Tr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR2` reader - Falling trigger event configuration bit of line 2"] pub type Tr2R = crate :: BitReader ;
#[doc = "Field `TR2` writer - Falling trigger event configuration bit of line 2"] pub type Tr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR3` reader - Falling trigger event configuration bit of line 3"] pub type Tr3R = crate :: BitReader ;
#[doc = "Field `TR3` writer - Falling trigger event configuration bit of line 3"] pub type Tr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR4` reader - Falling trigger event configuration bit of line 4"] pub type Tr4R = crate :: BitReader ;
#[doc = "Field `TR4` writer - Falling trigger event configuration bit of line 4"] pub type Tr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR5` reader - Falling trigger event configuration bit of line 5"] pub type Tr5R = crate :: BitReader ;
#[doc = "Field `TR5` writer - Falling trigger event configuration bit of line 5"] pub type Tr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR6` reader - Falling trigger event configuration bit of line 6"] pub type Tr6R = crate :: BitReader ;
#[doc = "Field `TR6` writer - Falling trigger event configuration bit of line 6"] pub type Tr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR7` reader - Falling trigger event configuration bit of line 7"] pub type Tr7R = crate :: BitReader ;
#[doc = "Field `TR7` writer - Falling trigger event configuration bit of line 7"] pub type Tr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR8` reader - Falling trigger event configuration bit of line 8"] pub type Tr8R = crate :: BitReader ;
#[doc = "Field `TR8` writer - Falling trigger event configuration bit of line 8"] pub type Tr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR9` reader - Falling trigger event configuration bit of line 9"] pub type Tr9R = crate :: BitReader ;
#[doc = "Field `TR9` writer - Falling trigger event configuration bit of line 9"] pub type Tr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR10` reader - Falling trigger event configuration bit of line 10"] pub type Tr10R = crate :: BitReader ;
#[doc = "Field `TR10` writer - Falling trigger event configuration bit of line 10"] pub type Tr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR11` reader - Falling trigger event configuration bit of line 11"] pub type Tr11R = crate :: BitReader ;
#[doc = "Field `TR11` writer - Falling trigger event configuration bit of line 11"] pub type Tr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR12` reader - Falling trigger event configuration bit of line 12"] pub type Tr12R = crate :: BitReader ;
#[doc = "Field `TR12` writer - Falling trigger event configuration bit of line 12"] pub type Tr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR13` reader - Falling trigger event configuration bit of line 13"] pub type Tr13R = crate :: BitReader ;
#[doc = "Field `TR13` writer - Falling trigger event configuration bit of line 13"] pub type Tr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR14` reader - Falling trigger event configuration bit of line 14"] pub type Tr14R = crate :: BitReader ;
#[doc = "Field `TR14` writer - Falling trigger event configuration bit of line 14"] pub type Tr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR15` reader - Falling trigger event configuration bit of line 15"] pub type Tr15R = crate :: BitReader ;
#[doc = "Field `TR15` writer - Falling trigger event configuration bit of line 15"] pub type Tr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR16` reader - Falling trigger event configuration bit of line 16"] pub type Tr16R = crate :: BitReader ;
#[doc = "Field `TR16` writer - Falling trigger event configuration bit of line 16"] pub type Tr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR19` reader - Falling trigger event configuration bit of line 19"] pub type Tr19R = crate :: BitReader ;
#[doc = "Field `TR19` writer - Falling trigger event configuration bit of line 19"] pub type Tr19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TR24` reader - Falling trigger event configuration bit of line 24"] pub type Tr24R = crate :: BitReader ;
#[doc = "Field `TR24` writer - Falling trigger event configuration bit of line 24"] pub type Tr24W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Falling trigger event configuration bit of line 0"]
#[inline (always)] pub fn tr0 (& self) -> Tr0R { Tr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Falling trigger event configuration bit of line 1"]
#[inline (always)] pub fn tr1 (& self) -> Tr1R { Tr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Falling trigger event configuration bit of line 2"]
#[inline (always)] pub fn tr2 (& self) -> Tr2R { Tr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Falling trigger event configuration bit of line 3"]
#[inline (always)] pub fn tr3 (& self) -> Tr3R { Tr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Falling trigger event configuration bit of line 4"]
#[inline (always)] pub fn tr4 (& self) -> Tr4R { Tr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Falling trigger event configuration bit of line 5"]
#[inline (always)] pub fn tr5 (& self) -> Tr5R { Tr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Falling trigger event configuration bit of line 6"]
#[inline (always)] pub fn tr6 (& self) -> Tr6R { Tr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Falling trigger event configuration bit of line 7"]
#[inline (always)] pub fn tr7 (& self) -> Tr7R { Tr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Falling trigger event configuration bit of line 8"]
#[inline (always)] pub fn tr8 (& self) -> Tr8R { Tr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Falling trigger event configuration bit of line 9"]
#[inline (always)] pub fn tr9 (& self) -> Tr9R { Tr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Falling trigger event configuration bit of line 10"]
#[inline (always)] pub fn tr10 (& self) -> Tr10R { Tr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Falling trigger event configuration bit of line 11"]
#[inline (always)] pub fn tr11 (& self) -> Tr11R { Tr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Falling trigger event configuration bit of line 12"]
#[inline (always)] pub fn tr12 (& self) -> Tr12R { Tr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Falling trigger event configuration bit of line 13"]
#[inline (always)] pub fn tr13 (& self) -> Tr13R { Tr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Falling trigger event configuration bit of line 14"]
#[inline (always)] pub fn tr14 (& self) -> Tr14R { Tr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Falling trigger event configuration bit of line 15"]
#[inline (always)] pub fn tr15 (& self) -> Tr15R { Tr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Falling trigger event configuration bit of line 16"]
#[inline (always)] pub fn tr16 (& self) -> Tr16R { Tr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 19 - Falling trigger event configuration bit of line 19"]
#[inline (always)] pub fn tr19 (& self) -> Tr19R { Tr19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 24 - Falling trigger event configuration bit of line 24"]
#[inline (always)] pub fn tr24 (& self) -> Tr24R { Tr24R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Falling trigger event configuration bit of line 0"]
#[inline (always)] pub fn tr0 (& mut self) -> Tr0W < '_ , FtsrSpec > { Tr0W :: new (self , 0) }
#[doc = "Bit 1 - Falling trigger event configuration bit of line 1"]
#[inline (always)] pub fn tr1 (& mut self) -> Tr1W < '_ , FtsrSpec > { Tr1W :: new (self , 1) }
#[doc = "Bit 2 - Falling trigger event configuration bit of line 2"]
#[inline (always)] pub fn tr2 (& mut self) -> Tr2W < '_ , FtsrSpec > { Tr2W :: new (self , 2) }
#[doc = "Bit 3 - Falling trigger event configuration bit of line 3"]
#[inline (always)] pub fn tr3 (& mut self) -> Tr3W < '_ , FtsrSpec > { Tr3W :: new (self , 3) }
#[doc = "Bit 4 - Falling trigger event configuration bit of line 4"]
#[inline (always)] pub fn tr4 (& mut self) -> Tr4W < '_ , FtsrSpec > { Tr4W :: new (self , 4) }
#[doc = "Bit 5 - Falling trigger event configuration bit of line 5"]
#[inline (always)] pub fn tr5 (& mut self) -> Tr5W < '_ , FtsrSpec > { Tr5W :: new (self , 5) }
#[doc = "Bit 6 - Falling trigger event configuration bit of line 6"]
#[inline (always)] pub fn tr6 (& mut self) -> Tr6W < '_ , FtsrSpec > { Tr6W :: new (self , 6) }
#[doc = "Bit 7 - Falling trigger event configuration bit of line 7"]
#[inline (always)] pub fn tr7 (& mut self) -> Tr7W < '_ , FtsrSpec > { Tr7W :: new (self , 7) }
#[doc = "Bit 8 - Falling trigger event configuration bit of line 8"]
#[inline (always)] pub fn tr8 (& mut self) -> Tr8W < '_ , FtsrSpec > { Tr8W :: new (self , 8) }
#[doc = "Bit 9 - Falling trigger event configuration bit of line 9"]
#[inline (always)] pub fn tr9 (& mut self) -> Tr9W < '_ , FtsrSpec > { Tr9W :: new (self , 9) }
#[doc = "Bit 10 - Falling trigger event configuration bit of line 10"]
#[inline (always)] pub fn tr10 (& mut self) -> Tr10W < '_ , FtsrSpec > { Tr10W :: new (self , 10) }
#[doc = "Bit 11 - Falling trigger event configuration bit of line 11"]
#[inline (always)] pub fn tr11 (& mut self) -> Tr11W < '_ , FtsrSpec > { Tr11W :: new (self , 11) }
#[doc = "Bit 12 - Falling trigger event configuration bit of line 12"]
#[inline (always)] pub fn tr12 (& mut self) -> Tr12W < '_ , FtsrSpec > { Tr12W :: new (self , 12) }
#[doc = "Bit 13 - Falling trigger event configuration bit of line 13"]
#[inline (always)] pub fn tr13 (& mut self) -> Tr13W < '_ , FtsrSpec > { Tr13W :: new (self , 13) }
#[doc = "Bit 14 - Falling trigger event configuration bit of line 14"]
#[inline (always)] pub fn tr14 (& mut self) -> Tr14W < '_ , FtsrSpec > { Tr14W :: new (self , 14) }
#[doc = "Bit 15 - Falling trigger event configuration bit of line 15"]
#[inline (always)] pub fn tr15 (& mut self) -> Tr15W < '_ , FtsrSpec > { Tr15W :: new (self , 15) }
#[doc = "Bit 16 - Falling trigger event configuration bit of line 16"]
#[inline (always)] pub fn tr16 (& mut self) -> Tr16W < '_ , FtsrSpec > { Tr16W :: new (self , 16) }
#[doc = "Bit 19 - Falling trigger event configuration bit of line 19"]
#[inline (always)] pub fn tr19 (& mut self) -> Tr19W < '_ , FtsrSpec > { Tr19W :: new (self , 19) }
#[doc = "Bit 24 - Falling trigger event configuration bit of line 24"]
#[inline (always)] pub fn tr24 (& mut self) -> Tr24W < '_ , FtsrSpec > { Tr24W :: new (self , 24) } }
#[doc = "Falling trigger selection register\n\nYou can [`read`](crate::Reg::read) this register and get [`ftsr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ftsr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FtsrSpec ; impl crate :: RegisterSpec for FtsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ftsr::R`](R) reader structure"] impl crate :: Readable for FtsrSpec { }
#[doc = "`write(|w| ..)` method takes [`ftsr::W`](W) writer structure"] impl crate :: Writable for FtsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FTSR to value 0"] impl crate :: Resettable for FtsrSpec { } }
#[doc = "SWIER (rw) register accessor: Software interrupt event register\n\nYou can [`read`](crate::Reg::read) this register and get [`swier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@swier`] module"]
#[doc (alias = "SWIER")] pub type Swier = crate :: Reg < swier :: SwierSpec > ;
#[doc = "Software interrupt event register"] pub mod swier {
#[doc = "Register `SWIER` reader"] pub type R = crate :: R < SwierSpec > ;
#[doc = "Register `SWIER` writer"] pub type W = crate :: W < SwierSpec > ;
#[doc = "Field `SWIER0` reader - Software interrupt on line 0"] pub type Swier0R = crate :: BitReader ;
#[doc = "Field `SWIER0` writer - Software interrupt on line 0"] pub type Swier0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER1` reader - Software interrupt on line 1"] pub type Swier1R = crate :: BitReader ;
#[doc = "Field `SWIER1` writer - Software interrupt on line 1"] pub type Swier1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER2` reader - Software interrupt on line 2"] pub type Swier2R = crate :: BitReader ;
#[doc = "Field `SWIER2` writer - Software interrupt on line 2"] pub type Swier2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER3` reader - Software interrupt on line 3"] pub type Swier3R = crate :: BitReader ;
#[doc = "Field `SWIER3` writer - Software interrupt on line 3"] pub type Swier3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER4` reader - Software interrupt on line 4"] pub type Swier4R = crate :: BitReader ;
#[doc = "Field `SWIER4` writer - Software interrupt on line 4"] pub type Swier4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER5` reader - Software interrupt on line 5"] pub type Swier5R = crate :: BitReader ;
#[doc = "Field `SWIER5` writer - Software interrupt on line 5"] pub type Swier5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER6` reader - Software interrupt on line 6"] pub type Swier6R = crate :: BitReader ;
#[doc = "Field `SWIER6` writer - Software interrupt on line 6"] pub type Swier6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER7` reader - Software interrupt on line 7"] pub type Swier7R = crate :: BitReader ;
#[doc = "Field `SWIER7` writer - Software interrupt on line 7"] pub type Swier7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER8` reader - Software interrupt on line 8"] pub type Swier8R = crate :: BitReader ;
#[doc = "Field `SWIER8` writer - Software interrupt on line 8"] pub type Swier8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER9` reader - Software interrupt on line 9"] pub type Swier9R = crate :: BitReader ;
#[doc = "Field `SWIER9` writer - Software interrupt on line 9"] pub type Swier9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER10` reader - Software interrupt on line 10"] pub type Swier10R = crate :: BitReader ;
#[doc = "Field `SWIER10` writer - Software interrupt on line 10"] pub type Swier10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER11` reader - Software interrupt on line 11"] pub type Swier11R = crate :: BitReader ;
#[doc = "Field `SWIER11` writer - Software interrupt on line 11"] pub type Swier11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER12` reader - Software interrupt on line 12"] pub type Swier12R = crate :: BitReader ;
#[doc = "Field `SWIER12` writer - Software interrupt on line 12"] pub type Swier12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER13` reader - Software interrupt on line 13"] pub type Swier13R = crate :: BitReader ;
#[doc = "Field `SWIER13` writer - Software interrupt on line 13"] pub type Swier13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER14` reader - Software interrupt on line 14"] pub type Swier14R = crate :: BitReader ;
#[doc = "Field `SWIER14` writer - Software interrupt on line 14"] pub type Swier14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER15` reader - Software interrupt on line 15"] pub type Swier15R = crate :: BitReader ;
#[doc = "Field `SWIER15` writer - Software interrupt on line 15"] pub type Swier15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER16` reader - Software interrupt on line 16"] pub type Swier16R = crate :: BitReader ;
#[doc = "Field `SWIER16` writer - Software interrupt on line 16"] pub type Swier16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER19` reader - Software interrupt on line 19"] pub type Swier19R = crate :: BitReader ;
#[doc = "Field `SWIER19` writer - Software interrupt on line 19"] pub type Swier19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIER24` reader - Software interrupt on line 24"] pub type Swier24R = crate :: BitReader ;
#[doc = "Field `SWIER24` writer - Software interrupt on line 24"] pub type Swier24W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Software interrupt on line 0"]
#[inline (always)] pub fn swier0 (& self) -> Swier0R { Swier0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Software interrupt on line 1"]
#[inline (always)] pub fn swier1 (& self) -> Swier1R { Swier1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Software interrupt on line 2"]
#[inline (always)] pub fn swier2 (& self) -> Swier2R { Swier2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Software interrupt on line 3"]
#[inline (always)] pub fn swier3 (& self) -> Swier3R { Swier3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Software interrupt on line 4"]
#[inline (always)] pub fn swier4 (& self) -> Swier4R { Swier4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Software interrupt on line 5"]
#[inline (always)] pub fn swier5 (& self) -> Swier5R { Swier5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Software interrupt on line 6"]
#[inline (always)] pub fn swier6 (& self) -> Swier6R { Swier6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Software interrupt on line 7"]
#[inline (always)] pub fn swier7 (& self) -> Swier7R { Swier7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Software interrupt on line 8"]
#[inline (always)] pub fn swier8 (& self) -> Swier8R { Swier8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Software interrupt on line 9"]
#[inline (always)] pub fn swier9 (& self) -> Swier9R { Swier9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Software interrupt on line 10"]
#[inline (always)] pub fn swier10 (& self) -> Swier10R { Swier10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Software interrupt on line 11"]
#[inline (always)] pub fn swier11 (& self) -> Swier11R { Swier11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Software interrupt on line 12"]
#[inline (always)] pub fn swier12 (& self) -> Swier12R { Swier12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Software interrupt on line 13"]
#[inline (always)] pub fn swier13 (& self) -> Swier13R { Swier13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Software interrupt on line 14"]
#[inline (always)] pub fn swier14 (& self) -> Swier14R { Swier14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Software interrupt on line 15"]
#[inline (always)] pub fn swier15 (& self) -> Swier15R { Swier15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Software interrupt on line 16"]
#[inline (always)] pub fn swier16 (& self) -> Swier16R { Swier16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 19 - Software interrupt on line 19"]
#[inline (always)] pub fn swier19 (& self) -> Swier19R { Swier19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 24 - Software interrupt on line 24"]
#[inline (always)] pub fn swier24 (& self) -> Swier24R { Swier24R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Software interrupt on line 0"]
#[inline (always)] pub fn swier0 (& mut self) -> Swier0W < '_ , SwierSpec > { Swier0W :: new (self , 0) }
#[doc = "Bit 1 - Software interrupt on line 1"]
#[inline (always)] pub fn swier1 (& mut self) -> Swier1W < '_ , SwierSpec > { Swier1W :: new (self , 1) }
#[doc = "Bit 2 - Software interrupt on line 2"]
#[inline (always)] pub fn swier2 (& mut self) -> Swier2W < '_ , SwierSpec > { Swier2W :: new (self , 2) }
#[doc = "Bit 3 - Software interrupt on line 3"]
#[inline (always)] pub fn swier3 (& mut self) -> Swier3W < '_ , SwierSpec > { Swier3W :: new (self , 3) }
#[doc = "Bit 4 - Software interrupt on line 4"]
#[inline (always)] pub fn swier4 (& mut self) -> Swier4W < '_ , SwierSpec > { Swier4W :: new (self , 4) }
#[doc = "Bit 5 - Software interrupt on line 5"]
#[inline (always)] pub fn swier5 (& mut self) -> Swier5W < '_ , SwierSpec > { Swier5W :: new (self , 5) }
#[doc = "Bit 6 - Software interrupt on line 6"]
#[inline (always)] pub fn swier6 (& mut self) -> Swier6W < '_ , SwierSpec > { Swier6W :: new (self , 6) }
#[doc = "Bit 7 - Software interrupt on line 7"]
#[inline (always)] pub fn swier7 (& mut self) -> Swier7W < '_ , SwierSpec > { Swier7W :: new (self , 7) }
#[doc = "Bit 8 - Software interrupt on line 8"]
#[inline (always)] pub fn swier8 (& mut self) -> Swier8W < '_ , SwierSpec > { Swier8W :: new (self , 8) }
#[doc = "Bit 9 - Software interrupt on line 9"]
#[inline (always)] pub fn swier9 (& mut self) -> Swier9W < '_ , SwierSpec > { Swier9W :: new (self , 9) }
#[doc = "Bit 10 - Software interrupt on line 10"]
#[inline (always)] pub fn swier10 (& mut self) -> Swier10W < '_ , SwierSpec > { Swier10W :: new (self , 10) }
#[doc = "Bit 11 - Software interrupt on line 11"]
#[inline (always)] pub fn swier11 (& mut self) -> Swier11W < '_ , SwierSpec > { Swier11W :: new (self , 11) }
#[doc = "Bit 12 - Software interrupt on line 12"]
#[inline (always)] pub fn swier12 (& mut self) -> Swier12W < '_ , SwierSpec > { Swier12W :: new (self , 12) }
#[doc = "Bit 13 - Software interrupt on line 13"]
#[inline (always)] pub fn swier13 (& mut self) -> Swier13W < '_ , SwierSpec > { Swier13W :: new (self , 13) }
#[doc = "Bit 14 - Software interrupt on line 14"]
#[inline (always)] pub fn swier14 (& mut self) -> Swier14W < '_ , SwierSpec > { Swier14W :: new (self , 14) }
#[doc = "Bit 15 - Software interrupt on line 15"]
#[inline (always)] pub fn swier15 (& mut self) -> Swier15W < '_ , SwierSpec > { Swier15W :: new (self , 15) }
#[doc = "Bit 16 - Software interrupt on line 16"]
#[inline (always)] pub fn swier16 (& mut self) -> Swier16W < '_ , SwierSpec > { Swier16W :: new (self , 16) }
#[doc = "Bit 19 - Software interrupt on line 19"]
#[inline (always)] pub fn swier19 (& mut self) -> Swier19W < '_ , SwierSpec > { Swier19W :: new (self , 19) }
#[doc = "Bit 24 - Software interrupt on line 24"]
#[inline (always)] pub fn swier24 (& mut self) -> Swier24W < '_ , SwierSpec > { Swier24W :: new (self , 24) } }
#[doc = "Software interrupt event register\n\nYou can [`read`](crate::Reg::read) this register and get [`swier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`swier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SwierSpec ; impl crate :: RegisterSpec for SwierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`swier::R`](R) reader structure"] impl crate :: Readable for SwierSpec { }
#[doc = "`write(|w| ..)` method takes [`swier::W`](W) writer structure"] impl crate :: Writable for SwierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SWIER to value 0"] impl crate :: Resettable for SwierSpec { } }
#[doc = "PR (rw) register accessor: Pending register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pr`] module"]
#[doc (alias = "PR")] pub type Pr = crate :: Reg < pr :: PrSpec > ;
#[doc = "Pending register"] pub mod pr {
#[doc = "Register `PR` reader"] pub type R = crate :: R < PrSpec > ;
#[doc = "Register `PR` writer"] pub type W = crate :: W < PrSpec > ;
#[doc = "Field `PR0` reader - Pending bit"] pub type Pr0R = crate :: BitReader ;
#[doc = "Field `PR0` writer - Pending bit"] pub type Pr0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR1` reader - Pending bit"] pub type Pr1R = crate :: BitReader ;
#[doc = "Field `PR1` writer - Pending bit"] pub type Pr1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR2` reader - Pending bit"] pub type Pr2R = crate :: BitReader ;
#[doc = "Field `PR2` writer - Pending bit"] pub type Pr2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR3` reader - Pending bit"] pub type Pr3R = crate :: BitReader ;
#[doc = "Field `PR3` writer - Pending bit"] pub type Pr3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR4` reader - Pending bit"] pub type Pr4R = crate :: BitReader ;
#[doc = "Field `PR4` writer - Pending bit"] pub type Pr4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR5` reader - Pending bit"] pub type Pr5R = crate :: BitReader ;
#[doc = "Field `PR5` writer - Pending bit"] pub type Pr5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR6` reader - Pending bit"] pub type Pr6R = crate :: BitReader ;
#[doc = "Field `PR6` writer - Pending bit"] pub type Pr6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR7` reader - Pending bit"] pub type Pr7R = crate :: BitReader ;
#[doc = "Field `PR7` writer - Pending bit"] pub type Pr7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR8` reader - Pending bit"] pub type Pr8R = crate :: BitReader ;
#[doc = "Field `PR8` writer - Pending bit"] pub type Pr8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR9` reader - Pending bit"] pub type Pr9R = crate :: BitReader ;
#[doc = "Field `PR9` writer - Pending bit"] pub type Pr9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR10` reader - Pending bit"] pub type Pr10R = crate :: BitReader ;
#[doc = "Field `PR10` writer - Pending bit"] pub type Pr10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR11` reader - Pending bit"] pub type Pr11R = crate :: BitReader ;
#[doc = "Field `PR11` writer - Pending bit"] pub type Pr11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR12` reader - Pending bit"] pub type Pr12R = crate :: BitReader ;
#[doc = "Field `PR12` writer - Pending bit"] pub type Pr12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR13` reader - Pending bit"] pub type Pr13R = crate :: BitReader ;
#[doc = "Field `PR13` writer - Pending bit"] pub type Pr13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR14` reader - Pending bit"] pub type Pr14R = crate :: BitReader ;
#[doc = "Field `PR14` writer - Pending bit"] pub type Pr14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR15` reader - Pending bit"] pub type Pr15R = crate :: BitReader ;
#[doc = "Field `PR15` writer - Pending bit"] pub type Pr15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR16` reader - Pending bit"] pub type Pr16R = crate :: BitReader ;
#[doc = "Field `PR16` writer - Pending bit"] pub type Pr16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR19` reader - Pending bit"] pub type Pr19R = crate :: BitReader ;
#[doc = "Field `PR19` writer - Pending bit"] pub type Pr19W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PR24` reader - Pending bit"] pub type Pr24R = crate :: BitReader ;
#[doc = "Field `PR24` writer - Pending bit"] pub type Pr24W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Pending bit"]
#[inline (always)] pub fn pr0 (& self) -> Pr0R { Pr0R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Pending bit"]
#[inline (always)] pub fn pr1 (& self) -> Pr1R { Pr1R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Pending bit"]
#[inline (always)] pub fn pr2 (& self) -> Pr2R { Pr2R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Pending bit"]
#[inline (always)] pub fn pr3 (& self) -> Pr3R { Pr3R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Pending bit"]
#[inline (always)] pub fn pr4 (& self) -> Pr4R { Pr4R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Pending bit"]
#[inline (always)] pub fn pr5 (& self) -> Pr5R { Pr5R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Pending bit"]
#[inline (always)] pub fn pr6 (& self) -> Pr6R { Pr6R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Pending bit"]
#[inline (always)] pub fn pr7 (& self) -> Pr7R { Pr7R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Pending bit"]
#[inline (always)] pub fn pr8 (& self) -> Pr8R { Pr8R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Pending bit"]
#[inline (always)] pub fn pr9 (& self) -> Pr9R { Pr9R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Pending bit"]
#[inline (always)] pub fn pr10 (& self) -> Pr10R { Pr10R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Pending bit"]
#[inline (always)] pub fn pr11 (& self) -> Pr11R { Pr11R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Pending bit"]
#[inline (always)] pub fn pr12 (& self) -> Pr12R { Pr12R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Pending bit"]
#[inline (always)] pub fn pr13 (& self) -> Pr13R { Pr13R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Pending bit"]
#[inline (always)] pub fn pr14 (& self) -> Pr14R { Pr14R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Pending bit"]
#[inline (always)] pub fn pr15 (& self) -> Pr15R { Pr15R :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Pending bit"]
#[inline (always)] pub fn pr16 (& self) -> Pr16R { Pr16R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 19 - Pending bit"]
#[inline (always)] pub fn pr19 (& self) -> Pr19R { Pr19R :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 24 - Pending bit"]
#[inline (always)] pub fn pr24 (& self) -> Pr24R { Pr24R :: new (((self . bits >> 24) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Pending bit"]
#[inline (always)] pub fn pr0 (& mut self) -> Pr0W < '_ , PrSpec > { Pr0W :: new (self , 0) }
#[doc = "Bit 1 - Pending bit"]
#[inline (always)] pub fn pr1 (& mut self) -> Pr1W < '_ , PrSpec > { Pr1W :: new (self , 1) }
#[doc = "Bit 2 - Pending bit"]
#[inline (always)] pub fn pr2 (& mut self) -> Pr2W < '_ , PrSpec > { Pr2W :: new (self , 2) }
#[doc = "Bit 3 - Pending bit"]
#[inline (always)] pub fn pr3 (& mut self) -> Pr3W < '_ , PrSpec > { Pr3W :: new (self , 3) }
#[doc = "Bit 4 - Pending bit"]
#[inline (always)] pub fn pr4 (& mut self) -> Pr4W < '_ , PrSpec > { Pr4W :: new (self , 4) }
#[doc = "Bit 5 - Pending bit"]
#[inline (always)] pub fn pr5 (& mut self) -> Pr5W < '_ , PrSpec > { Pr5W :: new (self , 5) }
#[doc = "Bit 6 - Pending bit"]
#[inline (always)] pub fn pr6 (& mut self) -> Pr6W < '_ , PrSpec > { Pr6W :: new (self , 6) }
#[doc = "Bit 7 - Pending bit"]
#[inline (always)] pub fn pr7 (& mut self) -> Pr7W < '_ , PrSpec > { Pr7W :: new (self , 7) }
#[doc = "Bit 8 - Pending bit"]
#[inline (always)] pub fn pr8 (& mut self) -> Pr8W < '_ , PrSpec > { Pr8W :: new (self , 8) }
#[doc = "Bit 9 - Pending bit"]
#[inline (always)] pub fn pr9 (& mut self) -> Pr9W < '_ , PrSpec > { Pr9W :: new (self , 9) }
#[doc = "Bit 10 - Pending bit"]
#[inline (always)] pub fn pr10 (& mut self) -> Pr10W < '_ , PrSpec > { Pr10W :: new (self , 10) }
#[doc = "Bit 11 - Pending bit"]
#[inline (always)] pub fn pr11 (& mut self) -> Pr11W < '_ , PrSpec > { Pr11W :: new (self , 11) }
#[doc = "Bit 12 - Pending bit"]
#[inline (always)] pub fn pr12 (& mut self) -> Pr12W < '_ , PrSpec > { Pr12W :: new (self , 12) }
#[doc = "Bit 13 - Pending bit"]
#[inline (always)] pub fn pr13 (& mut self) -> Pr13W < '_ , PrSpec > { Pr13W :: new (self , 13) }
#[doc = "Bit 14 - Pending bit"]
#[inline (always)] pub fn pr14 (& mut self) -> Pr14W < '_ , PrSpec > { Pr14W :: new (self , 14) }
#[doc = "Bit 15 - Pending bit"]
#[inline (always)] pub fn pr15 (& mut self) -> Pr15W < '_ , PrSpec > { Pr15W :: new (self , 15) }
#[doc = "Bit 16 - Pending bit"]
#[inline (always)] pub fn pr16 (& mut self) -> Pr16W < '_ , PrSpec > { Pr16W :: new (self , 16) }
#[doc = "Bit 19 - Pending bit"]
#[inline (always)] pub fn pr19 (& mut self) -> Pr19W < '_ , PrSpec > { Pr19W :: new (self , 19) }
#[doc = "Bit 24 - Pending bit"]
#[inline (always)] pub fn pr24 (& mut self) -> Pr24W < '_ , PrSpec > { Pr24W :: new (self , 24) } }
#[doc = "Pending register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrSpec ; impl crate :: RegisterSpec for PrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pr::R`](R) reader structure"] impl crate :: Readable for PrSpec { }
#[doc = "`write(|w| ..)` method takes [`pr::W`](W) writer structure"] impl crate :: Writable for PrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PR to value 0"] impl crate :: Resettable for PrSpec { } } }
#[doc = "FLASH"] pub type Flash = crate :: Periph < flash :: RegisterBlock , 0x4002_2000 > ; impl core :: fmt :: Debug for Flash { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Flash") . finish () } }
#[doc = "FLASH"] pub mod flash {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { acr : Acr , keyr : Keyr , optkeyr : Optkeyr , sr : Sr , cr : Cr , ar : Ar , _reserved6 : [u8 ; 0x04] , obr : Obr , wrpr : Wrpr , } impl RegisterBlock {
#[doc = "0x00 - Flash access control register"]
#[inline (always)] pub const fn acr (& self) -> & Acr { & self . acr }
#[doc = "0x04 - Flash key"]
#[inline (always)] pub const fn keyr (& self) -> & Keyr { & self . keyr }
#[doc = "0x08 - Option byte key"]
#[inline (always)] pub const fn optkeyr (& self) -> & Optkeyr { & self . optkeyr }
#[doc = "0x0c - Flash status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x10 - Flash control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x14 - Flash address register"]
#[inline (always)] pub const fn ar (& self) -> & Ar { & self . ar }
#[doc = "0x1c - Option byte register"]
#[inline (always)] pub const fn obr (& self) -> & Obr { & self . obr }
#[doc = "0x20 - Write protect register"]
#[inline (always)] pub const fn wrpr (& self) -> & Wrpr { & self . wrpr } }
#[doc = "ACR (rw) register accessor: Flash access control register\n\nYou can [`read`](crate::Reg::read) this register and get [`acr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@acr`] module"]
#[doc (alias = "ACR")] pub type Acr = crate :: Reg < acr :: AcrSpec > ;
#[doc = "Flash access control register"] pub mod acr {
#[doc = "Register `ACR` reader"] pub type R = crate :: R < AcrSpec > ;
#[doc = "Register `ACR` writer"] pub type W = crate :: W < AcrSpec > ;
#[doc = "Field `LATENCY` reader - Latency"] pub type LatencyR = crate :: FieldReader ;
#[doc = "Field `LATENCY` writer - Latency"] pub type LatencyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `HLFCYA` reader - Flash half cycle access enable"] pub type HlfcyaR = crate :: BitReader ;
#[doc = "Field `HLFCYA` writer - Flash half cycle access enable"] pub type HlfcyaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PRFTBE` reader - Prefetch buffer enable"] pub type PrftbeR = crate :: BitReader ;
#[doc = "Field `PRFTBE` writer - Prefetch buffer enable"] pub type PrftbeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Latency"]
#[inline (always)] pub fn latency (& self) -> LatencyR { LatencyR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - Flash half cycle access enable"]
#[inline (always)] pub fn hlfcya (& self) -> HlfcyaR { HlfcyaR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Prefetch buffer enable"]
#[inline (always)] pub fn prftbe (& self) -> PrftbeR { PrftbeR :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Latency"]
#[inline (always)] pub fn latency (& mut self) -> LatencyW < '_ , AcrSpec > { LatencyW :: new (self , 0) }
#[doc = "Bit 3 - Flash half cycle access enable"]
#[inline (always)] pub fn hlfcya (& mut self) -> HlfcyaW < '_ , AcrSpec > { HlfcyaW :: new (self , 3) }
#[doc = "Bit 4 - Prefetch buffer enable"]
#[inline (always)] pub fn prftbe (& mut self) -> PrftbeW < '_ , AcrSpec > { PrftbeW :: new (self , 4) } }
#[doc = "Flash access control register\n\nYou can [`read`](crate::Reg::read) this register and get [`acr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AcrSpec ; impl crate :: RegisterSpec for AcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`acr::R`](R) reader structure"] impl crate :: Readable for AcrSpec { }
#[doc = "`write(|w| ..)` method takes [`acr::W`](W) writer structure"] impl crate :: Writable for AcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ACR to value 0x18"] impl crate :: Resettable for AcrSpec { const RESET_VALUE : u32 = 0x18 ; } }
#[doc = "KEYR (w) register accessor: Flash key\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@keyr`] module"]
#[doc (alias = "KEYR")] pub type Keyr = crate :: Reg < keyr :: KeyrSpec > ;
#[doc = "Flash key"] pub mod keyr {
#[doc = "Register `KEYR` writer"] pub type W = crate :: W < KeyrSpec > ;
#[doc = "Field `FKEYR` writer - Flash key"] pub type FkeyrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl W {
#[doc = "Bits 0:31 - Flash key"]
#[inline (always)] pub fn fkeyr (& mut self) -> FkeyrW < '_ , KeyrSpec > { FkeyrW :: new (self , 0) } }
#[doc = "Flash key\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`keyr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct KeyrSpec ; impl crate :: RegisterSpec for KeyrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`keyr::W`](W) writer structure"] impl crate :: Writable for KeyrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KEYR to value 0"] impl crate :: Resettable for KeyrSpec { } }
#[doc = "OPTKEYR (w) register accessor: Option byte key\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`optkeyr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@optkeyr`] module"]
#[doc (alias = "OPTKEYR")] pub type Optkeyr = crate :: Reg < optkeyr :: OptkeyrSpec > ;
#[doc = "Option byte key"] pub mod optkeyr {
#[doc = "Register `OPTKEYR` writer"] pub type W = crate :: W < OptkeyrSpec > ;
#[doc = "Field `OPTKEYR` writer - Option byte key"] pub type OptkeyrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl W {
#[doc = "Bits 0:31 - Option byte key"]
#[inline (always)] pub fn optkeyr (& mut self) -> OptkeyrW < '_ , OptkeyrSpec > { OptkeyrW :: new (self , 0) } }
#[doc = "Option byte key\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`optkeyr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OptkeyrSpec ; impl crate :: RegisterSpec for OptkeyrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`optkeyr::W`](W) writer structure"] impl crate :: Writable for OptkeyrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OPTKEYR to value 0"] impl crate :: Resettable for OptkeyrSpec { } }
#[doc = "SR (rw) register accessor: Flash status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Flash status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `BSY` reader - Busy"] pub type BsyR = crate :: BitReader ;
#[doc = "Field `BSY` writer - Busy"] pub type BsyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PGERR` reader - Programming error"] pub type PgerrR = crate :: BitReader ;
#[doc = "Field `PGERR` writer - Programming error"] pub type PgerrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WRPRTERR` reader - Write protection error"] pub type WrprterrR = crate :: BitReader ;
#[doc = "Field `WRPRTERR` writer - Write protection error"] pub type WrprterrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOP` reader - End of operation"] pub type EopR = crate :: BitReader ;
#[doc = "Field `EOP` writer - End of operation"] pub type EopW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Busy"]
#[inline (always)] pub fn bsy (& self) -> BsyR { BsyR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - Programming error"]
#[inline (always)] pub fn pgerr (& self) -> PgerrR { PgerrR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - Write protection error"]
#[inline (always)] pub fn wrprterr (& self) -> WrprterrR { WrprterrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - End of operation"]
#[inline (always)] pub fn eop (& self) -> EopR { EopR :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Busy"]
#[inline (always)] pub fn bsy (& mut self) -> BsyW < '_ , SrSpec > { BsyW :: new (self , 0) }
#[doc = "Bit 2 - Programming error"]
#[inline (always)] pub fn pgerr (& mut self) -> PgerrW < '_ , SrSpec > { PgerrW :: new (self , 2) }
#[doc = "Bit 4 - Write protection error"]
#[inline (always)] pub fn wrprterr (& mut self) -> WrprterrW < '_ , SrSpec > { WrprterrW :: new (self , 4) }
#[doc = "Bit 5 - End of operation"]
#[inline (always)] pub fn eop (& mut self) -> EopW < '_ , SrSpec > { EopW :: new (self , 5) } }
#[doc = "Flash status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "CR (rw) register accessor: Flash control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Flash control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `PG` reader - Programming"] pub type PgR = crate :: BitReader ;
#[doc = "Field `PG` writer - Programming"] pub type PgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PER` reader - Page erase"] pub type PerR = crate :: BitReader ;
#[doc = "Field `PER` writer - Page erase"] pub type PerW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MER` reader - Mass erase"] pub type MerR = crate :: BitReader ;
#[doc = "Field `MER` writer - Mass erase"] pub type MerW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTPG` reader - Option byte programming"] pub type OptpgR = crate :: BitReader ;
#[doc = "Field `OPTPG` writer - Option byte programming"] pub type OptpgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTER` reader - Option byte erase"] pub type OpterR = crate :: BitReader ;
#[doc = "Field `OPTER` writer - Option byte erase"] pub type OpterW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STRT` reader - Start"] pub type StrtR = crate :: BitReader ;
#[doc = "Field `STRT` writer - Start"] pub type StrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LOCK` reader - Lock"] pub type LockR = crate :: BitReader ;
#[doc = "Field `LOCK` writer - Lock"] pub type LockW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPTWRE` reader - Option byte write enable"] pub type OptwreR = crate :: BitReader ;
#[doc = "Field `OPTWRE` writer - Option byte write enable"] pub type OptwreW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ERRIE` reader - Error interrupt enable"] pub type ErrieR = crate :: BitReader ;
#[doc = "Field `ERRIE` writer - Error interrupt enable"] pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOPIE` reader - End of operation interrupt enable"] pub type EopieR = crate :: BitReader ;
#[doc = "Field `EOPIE` writer - End of operation interrupt enable"] pub type EopieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Programming"]
#[inline (always)] pub fn pg (& self) -> PgR { PgR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Page erase"]
#[inline (always)] pub fn per (& self) -> PerR { PerR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Mass erase"]
#[inline (always)] pub fn mer (& self) -> MerR { MerR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - Option byte programming"]
#[inline (always)] pub fn optpg (& self) -> OptpgR { OptpgR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Option byte erase"]
#[inline (always)] pub fn opter (& self) -> OpterR { OpterR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Start"]
#[inline (always)] pub fn strt (& self) -> StrtR { StrtR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Lock"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - Option byte write enable"]
#[inline (always)] pub fn optwre (& self) -> OptwreR { OptwreR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Error interrupt enable"]
#[inline (always)] pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 12 - End of operation interrupt enable"]
#[inline (always)] pub fn eopie (& self) -> EopieR { EopieR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Programming"]
#[inline (always)] pub fn pg (& mut self) -> PgW < '_ , CrSpec > { PgW :: new (self , 0) }
#[doc = "Bit 1 - Page erase"]
#[inline (always)] pub fn per (& mut self) -> PerW < '_ , CrSpec > { PerW :: new (self , 1) }
#[doc = "Bit 2 - Mass erase"]
#[inline (always)] pub fn mer (& mut self) -> MerW < '_ , CrSpec > { MerW :: new (self , 2) }
#[doc = "Bit 4 - Option byte programming"]
#[inline (always)] pub fn optpg (& mut self) -> OptpgW < '_ , CrSpec > { OptpgW :: new (self , 4) }
#[doc = "Bit 5 - Option byte erase"]
#[inline (always)] pub fn opter (& mut self) -> OpterW < '_ , CrSpec > { OpterW :: new (self , 5) }
#[doc = "Bit 6 - Start"]
#[inline (always)] pub fn strt (& mut self) -> StrtW < '_ , CrSpec > { StrtW :: new (self , 6) }
#[doc = "Bit 7 - Lock"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , CrSpec > { LockW :: new (self , 7) }
#[doc = "Bit 9 - Option byte write enable"]
#[inline (always)] pub fn optwre (& mut self) -> OptwreW < '_ , CrSpec > { OptwreW :: new (self , 9) }
#[doc = "Bit 10 - Error interrupt enable"]
#[inline (always)] pub fn errie (& mut self) -> ErrieW < '_ , CrSpec > { ErrieW :: new (self , 10) }
#[doc = "Bit 12 - End of operation interrupt enable"]
#[inline (always)] pub fn eopie (& mut self) -> EopieW < '_ , CrSpec > { EopieW :: new (self , 12) } }
#[doc = "Flash control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x80"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x80 ; } }
#[doc = "AR (w) register accessor: Flash address register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ar::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ar`] module"]
#[doc (alias = "AR")] pub type Ar = crate :: Reg < ar :: ArSpec > ;
#[doc = "Flash address register"] pub mod ar {
#[doc = "Register `AR` writer"] pub type W = crate :: W < ArSpec > ;
#[doc = "Field `FAR` writer - Flash Address"] pub type FarW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl W {
#[doc = "Bits 0:31 - Flash Address"]
#[inline (always)] pub fn far (& mut self) -> FarW < '_ , ArSpec > { FarW :: new (self , 0) } }
#[doc = "Flash address register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ar::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArSpec ; impl crate :: RegisterSpec for ArSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`ar::W`](W) writer structure"] impl crate :: Writable for ArSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AR to value 0"] impl crate :: Resettable for ArSpec { } }
#[doc = "OBR (r) register accessor: Option byte register\n\nYou can [`read`](crate::Reg::read) this register and get [`obr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@obr`] module"]
#[doc (alias = "OBR")] pub type Obr = crate :: Reg < obr :: ObrSpec > ;
#[doc = "Option byte register"] pub mod obr {
#[doc = "Register `OBR` reader"] pub type R = crate :: R < ObrSpec > ;
#[doc = "Field `OPTERR` reader - Option byte error"] pub type OpterrR = crate :: BitReader ;
#[doc = "Field `WDG_SW` reader - WDG_SW"] pub type WdgSwR = crate :: BitReader ;
#[doc = "Field `nRST_STOP` reader - nRST_STOP"] pub type NRstStopR = crate :: BitReader ;
#[doc = "Field `nRST_STDBY` reader - nRST_STDBY"] pub type NRstStdbyR = crate :: BitReader ;
#[doc = "Field `nBOOT1` reader - nBOOT1"] pub type NBoot1R = crate :: BitReader ;
#[doc = "Field `Data0` reader - Data0"] pub type Data0R = crate :: FieldReader ;
#[doc = "Field `Data1` reader - Data1"] pub type Data1R = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Option byte error"]
#[inline (always)] pub fn opterr (& self) -> OpterrR { OpterrR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - WDG_SW"]
#[inline (always)] pub fn wdg_sw (& self) -> WdgSwR { WdgSwR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - nRST_STOP"]
#[inline (always)] pub fn n_rst_stop (& self) -> NRstStopR { NRstStopR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - nRST_STDBY"]
#[inline (always)] pub fn n_rst_stdby (& self) -> NRstStdbyR { NRstStdbyR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - nBOOT1"]
#[inline (always)] pub fn n_boot1 (& self) -> NBoot1R { NBoot1R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bits 10:17 - Data0"]
#[inline (always)] pub fn data0 (& self) -> Data0R { Data0R :: new (((self . bits >> 10) & 0xff) as u8) }
#[doc = "Bits 18:25 - Data1"]
#[inline (always)] pub fn data1 (& self) -> Data1R { Data1R :: new (((self . bits >> 18) & 0xff) as u8) } }
#[doc = "Option byte register\n\nYou can [`read`](crate::Reg::read) this register and get [`obr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ObrSpec ; impl crate :: RegisterSpec for ObrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`obr::R`](R) reader structure"] impl crate :: Readable for ObrSpec { }
#[doc = "`reset()` method sets OBR to value 0x03ff_fc1c"] impl crate :: Resettable for ObrSpec { const RESET_VALUE : u32 = 0x03ff_fc1c ; } }
#[doc = "WRPR (r) register accessor: Write protect register\n\nYou can [`read`](crate::Reg::read) this register and get [`wrpr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wrpr`] module"]
#[doc (alias = "WRPR")] pub type Wrpr = crate :: Reg < wrpr :: WrprSpec > ;
#[doc = "Write protect register"] pub mod wrpr {
#[doc = "Register `WRPR` reader"] pub type R = crate :: R < WrprSpec > ;
#[doc = "Field `WRP` reader - Write protect"] pub type WrpR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Write protect"]
#[inline (always)] pub fn wrp (& self) -> WrpR { WrpR :: new (self . bits) } }
#[doc = "Write protect register\n\nYou can [`read`](crate::Reg::read) this register and get [`wrpr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct WrprSpec ; impl crate :: RegisterSpec for WrprSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`wrpr::R`](R) reader structure"] impl crate :: Readable for WrprSpec { }
#[doc = "`reset()` method sets WRPR to value 0xffff_ffff"] impl crate :: Resettable for WrprSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } } }
#[doc = "General purpose I/O"] pub type Gpioa = crate :: Periph < gpioa :: RegisterBlock , 0x4800_0000 > ; impl core :: fmt :: Debug for Gpioa { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioa") . finish () } }
#[doc = "General purpose I/O"] pub mod gpioa {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { crl : Crl , crh : Crh , idr : Idr , odr : Odr , bsrr : Bsrr , brr : Brr , lckr : Lckr , _reserved7 : [u8 ; 0x04] , afrl : Afrl , afrh : Afrh , } impl RegisterBlock {
#[doc = "0x00 - configuration low register"]
#[inline (always)] pub const fn crl (& self) -> & Crl { & self . crl }
#[doc = "0x04 - configuration high register"]
#[inline (always)] pub const fn crh (& self) -> & Crh { & self . crh }
#[doc = "0x08 - input data register"]
#[inline (always)] pub const fn idr (& self) -> & Idr { & self . idr }
#[doc = "0x0c - output data register"]
#[inline (always)] pub const fn odr (& self) -> & Odr { & self . odr }
#[doc = "0x10 - bit set/reset register"]
#[inline (always)] pub const fn bsrr (& self) -> & Bsrr { & self . bsrr }
#[doc = "0x14 - bit reset register"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr }
#[doc = "0x18 - Port configuration lock register"]
#[inline (always)] pub const fn lckr (& self) -> & Lckr { & self . lckr }
#[doc = "0x20 - Port Multiplexing Function Low Register"]
#[inline (always)] pub const fn afrl (& self) -> & Afrl { & self . afrl }
#[doc = "0x24 - Port Multiplexing Function High Register"]
#[inline (always)] pub const fn afrh (& self) -> & Afrh { & self . afrh } }
#[doc = "CRL (rw) register accessor: configuration low register\n\nYou can [`read`](crate::Reg::read) this register and get [`crl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crl`] module"]
#[doc (alias = "CRL")] pub type Crl = crate :: Reg < crl :: CrlSpec > ;
#[doc = "configuration low register"] pub mod crl {
#[doc = "Register `CRL` reader"] pub type R = crate :: R < CrlSpec > ;
#[doc = "Register `CRL` writer"] pub type W = crate :: W < CrlSpec > ;
#[doc = "Field `MODE0` reader - Port 0 mode bits"] pub type Mode0R = crate :: FieldReader ;
#[doc = "Field `MODE0` writer - Port 0 mode bits"] pub type Mode0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF0` reader - Port 0 configuration bits"] pub type Cnf0R = crate :: FieldReader ;
#[doc = "Field `CNF0` writer - Port 0 configuration bits"] pub type Cnf0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE1` reader - Port 1 mode bits"] pub type Mode1R = crate :: FieldReader ;
#[doc = "Field `MODE1` writer - Port 1 mode bits"] pub type Mode1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF1` reader - Port 1 configuration bits"] pub type Cnf1R = crate :: FieldReader ;
#[doc = "Field `CNF1` writer - Port 1 configuration bits"] pub type Cnf1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE2` reader - Port 2 mode bits"] pub type Mode2R = crate :: FieldReader ;
#[doc = "Field `MODE2` writer - Port 2 mode bits"] pub type Mode2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF2` reader - Port 2 configuration bits"] pub type Cnf2R = crate :: FieldReader ;
#[doc = "Field `CNF2` writer - Port 2 configuration bits"] pub type Cnf2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE3` reader - Port 3 mode bits"] pub type Mode3R = crate :: FieldReader ;
#[doc = "Field `MODE3` writer - Port 3 mode bits"] pub type Mode3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF3` reader - Port 3 configuration bits"] pub type Cnf3R = crate :: FieldReader ;
#[doc = "Field `CNF3` writer - Port 3 configuration bits"] pub type Cnf3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE4` reader - Port 4 mode bits"] pub type Mode4R = crate :: FieldReader ;
#[doc = "Field `MODE4` writer - Port 4 mode bits"] pub type Mode4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF4` reader - Port 4 configuration bits"] pub type Cnf4R = crate :: FieldReader ;
#[doc = "Field `CNF4` writer - Port 4 configuration bits"] pub type Cnf4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE5` reader - Port 5 mode bits"] pub type Mode5R = crate :: FieldReader ;
#[doc = "Field `MODE5` writer - Port 5 mode bits"] pub type Mode5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF5` reader - Port 5 configuration bits"] pub type Cnf5R = crate :: FieldReader ;
#[doc = "Field `CNF5` writer - Port 5 configuration bits"] pub type Cnf5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE6` reader - Port 6 mode bits"] pub type Mode6R = crate :: FieldReader ;
#[doc = "Field `MODE6` writer - Port 6 mode bits"] pub type Mode6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF6` reader - Port 6 configuration bits"] pub type Cnf6R = crate :: FieldReader ;
#[doc = "Field `CNF6` writer - Port 6 configuration bits"] pub type Cnf6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE7` reader - Port 7 mode bits"] pub type Mode7R = crate :: FieldReader ;
#[doc = "Field `MODE7` writer - Port 7 mode bits"] pub type Mode7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF7` reader - Port 7 configuration bits"] pub type Cnf7R = crate :: FieldReader ;
#[doc = "Field `CNF7` writer - Port 7 configuration bits"] pub type Cnf7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port 0 mode bits"]
#[inline (always)] pub fn mode0 (& self) -> Mode0R { Mode0R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port 0 configuration bits"]
#[inline (always)] pub fn cnf0 (& self) -> Cnf0R { Cnf0R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port 1 mode bits"]
#[inline (always)] pub fn mode1 (& self) -> Mode1R { Mode1R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port 1 configuration bits"]
#[inline (always)] pub fn cnf1 (& self) -> Cnf1R { Cnf1R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port 2 mode bits"]
#[inline (always)] pub fn mode2 (& self) -> Mode2R { Mode2R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port 2 configuration bits"]
#[inline (always)] pub fn cnf2 (& self) -> Cnf2R { Cnf2R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port 3 mode bits"]
#[inline (always)] pub fn mode3 (& self) -> Mode3R { Mode3R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port 3 configuration bits"]
#[inline (always)] pub fn cnf3 (& self) -> Cnf3R { Cnf3R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port 4 mode bits"]
#[inline (always)] pub fn mode4 (& self) -> Mode4R { Mode4R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port 4 configuration bits"]
#[inline (always)] pub fn cnf4 (& self) -> Cnf4R { Cnf4R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port 5 mode bits"]
#[inline (always)] pub fn mode5 (& self) -> Mode5R { Mode5R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port 5 configuration bits"]
#[inline (always)] pub fn cnf5 (& self) -> Cnf5R { Cnf5R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port 6 mode bits"]
#[inline (always)] pub fn mode6 (& self) -> Mode6R { Mode6R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port 6 configuration bits"]
#[inline (always)] pub fn cnf6 (& self) -> Cnf6R { Cnf6R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port 7 mode bits"]
#[inline (always)] pub fn mode7 (& self) -> Mode7R { Mode7R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port 7 configuration bits"]
#[inline (always)] pub fn cnf7 (& self) -> Cnf7R { Cnf7R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port 0 mode bits"]
#[inline (always)] pub fn mode0 (& mut self) -> Mode0W < '_ , CrlSpec > { Mode0W :: new (self , 0) }
#[doc = "Bits 2:3 - Port 0 configuration bits"]
#[inline (always)] pub fn cnf0 (& mut self) -> Cnf0W < '_ , CrlSpec > { Cnf0W :: new (self , 2) }
#[doc = "Bits 4:5 - Port 1 mode bits"]
#[inline (always)] pub fn mode1 (& mut self) -> Mode1W < '_ , CrlSpec > { Mode1W :: new (self , 4) }
#[doc = "Bits 6:7 - Port 1 configuration bits"]
#[inline (always)] pub fn cnf1 (& mut self) -> Cnf1W < '_ , CrlSpec > { Cnf1W :: new (self , 6) }
#[doc = "Bits 8:9 - Port 2 mode bits"]
#[inline (always)] pub fn mode2 (& mut self) -> Mode2W < '_ , CrlSpec > { Mode2W :: new (self , 8) }
#[doc = "Bits 10:11 - Port 2 configuration bits"]
#[inline (always)] pub fn cnf2 (& mut self) -> Cnf2W < '_ , CrlSpec > { Cnf2W :: new (self , 10) }
#[doc = "Bits 12:13 - Port 3 mode bits"]
#[inline (always)] pub fn mode3 (& mut self) -> Mode3W < '_ , CrlSpec > { Mode3W :: new (self , 12) }
#[doc = "Bits 14:15 - Port 3 configuration bits"]
#[inline (always)] pub fn cnf3 (& mut self) -> Cnf3W < '_ , CrlSpec > { Cnf3W :: new (self , 14) }
#[doc = "Bits 16:17 - Port 4 mode bits"]
#[inline (always)] pub fn mode4 (& mut self) -> Mode4W < '_ , CrlSpec > { Mode4W :: new (self , 16) }
#[doc = "Bits 18:19 - Port 4 configuration bits"]
#[inline (always)] pub fn cnf4 (& mut self) -> Cnf4W < '_ , CrlSpec > { Cnf4W :: new (self , 18) }
#[doc = "Bits 20:21 - Port 5 mode bits"]
#[inline (always)] pub fn mode5 (& mut self) -> Mode5W < '_ , CrlSpec > { Mode5W :: new (self , 20) }
#[doc = "Bits 22:23 - Port 5 configuration bits"]
#[inline (always)] pub fn cnf5 (& mut self) -> Cnf5W < '_ , CrlSpec > { Cnf5W :: new (self , 22) }
#[doc = "Bits 24:25 - Port 6 mode bits"]
#[inline (always)] pub fn mode6 (& mut self) -> Mode6W < '_ , CrlSpec > { Mode6W :: new (self , 24) }
#[doc = "Bits 26:27 - Port 6 configuration bits"]
#[inline (always)] pub fn cnf6 (& mut self) -> Cnf6W < '_ , CrlSpec > { Cnf6W :: new (self , 26) }
#[doc = "Bits 28:29 - Port 7 mode bits"]
#[inline (always)] pub fn mode7 (& mut self) -> Mode7W < '_ , CrlSpec > { Mode7W :: new (self , 28) }
#[doc = "Bits 30:31 - Port 7 configuration bits"]
#[inline (always)] pub fn cnf7 (& mut self) -> Cnf7W < '_ , CrlSpec > { Cnf7W :: new (self , 30) } }
#[doc = "configuration low register\n\nYou can [`read`](crate::Reg::read) this register and get [`crl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrlSpec ; impl crate :: RegisterSpec for CrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`crl::R`](R) reader structure"] impl crate :: Readable for CrlSpec { }
#[doc = "`write(|w| ..)` method takes [`crl::W`](W) writer structure"] impl crate :: Writable for CrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CRL to value 0x4444_4844"] impl crate :: Resettable for CrlSpec { const RESET_VALUE : u32 = 0x4444_4844 ; } }
#[doc = "CRH (rw) register accessor: configuration high register\n\nYou can [`read`](crate::Reg::read) this register and get [`crh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@crh`] module"]
#[doc (alias = "CRH")] pub type Crh = crate :: Reg < crh :: CrhSpec > ;
#[doc = "configuration high register"] pub mod crh {
#[doc = "Register `CRH` reader"] pub type R = crate :: R < CrhSpec > ;
#[doc = "Register `CRH` writer"] pub type W = crate :: W < CrhSpec > ;
#[doc = "Field `MODE8` reader - Port 8 mode bits"] pub type Mode8R = crate :: FieldReader ;
#[doc = "Field `MODE8` writer - Port 8 mode bits"] pub type Mode8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF8` reader - Port 8 configuration bits"] pub type Cnf8R = crate :: FieldReader ;
#[doc = "Field `CNF8` writer - Port 8 configuration bits"] pub type Cnf8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE9` reader - Port 9 mode bits"] pub type Mode9R = crate :: FieldReader ;
#[doc = "Field `MODE9` writer - Port 9 mode bits"] pub type Mode9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF9` reader - Port 9 configuration bits"] pub type Cnf9R = crate :: FieldReader ;
#[doc = "Field `CNF9` writer - Port 9 configuration bits"] pub type Cnf9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE10` reader - Port 10 mode bits"] pub type Mode10R = crate :: FieldReader ;
#[doc = "Field `MODE10` writer - Port 10 mode bits"] pub type Mode10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF10` reader - Port 10 configuration bits"] pub type Cnf10R = crate :: FieldReader ;
#[doc = "Field `CNF10` writer - Port 10 configuration bits"] pub type Cnf10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE11` reader - Port 11 mode bits"] pub type Mode11R = crate :: FieldReader ;
#[doc = "Field `MODE11` writer - Port 11 mode bits"] pub type Mode11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF11` reader - Port 11 configuration bits"] pub type Cnf11R = crate :: FieldReader ;
#[doc = "Field `CNF11` writer - Port 11 configuration bits"] pub type Cnf11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE12` reader - Port 12 mode bits"] pub type Mode12R = crate :: FieldReader ;
#[doc = "Field `MODE12` writer - Port 12 mode bits"] pub type Mode12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF12` reader - Port 12 configuration bits"] pub type Cnf12R = crate :: FieldReader ;
#[doc = "Field `CNF12` writer - Port 12 configuration bits"] pub type Cnf12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE13` reader - Port 13 mode bits"] pub type Mode13R = crate :: FieldReader ;
#[doc = "Field `MODE13` writer - Port 13 mode bits"] pub type Mode13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF13` reader - Port 13 configuration bits"] pub type Cnf13R = crate :: FieldReader ;
#[doc = "Field `CNF13` writer - Port 13 configuration bits"] pub type Cnf13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE14` reader - Port 14 mode bits"] pub type Mode14R = crate :: FieldReader ;
#[doc = "Field `MODE14` writer - Port 14 mode bits"] pub type Mode14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF14` reader - Port 14 configuration bits"] pub type Cnf14R = crate :: FieldReader ;
#[doc = "Field `CNF14` writer - Port 14 configuration bits"] pub type Cnf14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MODE15` reader - Port 15 mode bits"] pub type Mode15R = crate :: FieldReader ;
#[doc = "Field `MODE15` writer - Port 15 mode bits"] pub type Mode15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CNF15` reader - Port 15 configuration bits"] pub type Cnf15R = crate :: FieldReader ;
#[doc = "Field `CNF15` writer - Port 15 configuration bits"] pub type Cnf15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - Port 8 mode bits"]
#[inline (always)] pub fn mode8 (& self) -> Mode8R { Mode8R :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Port 8 configuration bits"]
#[inline (always)] pub fn cnf8 (& self) -> Cnf8R { Cnf8R :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:5 - Port 9 mode bits"]
#[inline (always)] pub fn mode9 (& self) -> Mode9R { Mode9R :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bits 6:7 - Port 9 configuration bits"]
#[inline (always)] pub fn cnf9 (& self) -> Cnf9R { Cnf9R :: new (((self . bits >> 6) & 3) as u8) }
#[doc = "Bits 8:9 - Port 10 mode bits"]
#[inline (always)] pub fn mode10 (& self) -> Mode10R { Mode10R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Port 10 configuration bits"]
#[inline (always)] pub fn cnf10 (& self) -> Cnf10R { Cnf10R :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:13 - Port 11 mode bits"]
#[inline (always)] pub fn mode11 (& self) -> Mode11R { Mode11R :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bits 14:15 - Port 11 configuration bits"]
#[inline (always)] pub fn cnf11 (& self) -> Cnf11R { Cnf11R :: new (((self . bits >> 14) & 3) as u8) }
#[doc = "Bits 16:17 - Port 12 mode bits"]
#[inline (always)] pub fn mode12 (& self) -> Mode12R { Mode12R :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bits 18:19 - Port 12 configuration bits"]
#[inline (always)] pub fn cnf12 (& self) -> Cnf12R { Cnf12R :: new (((self . bits >> 18) & 3) as u8) }
#[doc = "Bits 20:21 - Port 13 mode bits"]
#[inline (always)] pub fn mode13 (& self) -> Mode13R { Mode13R :: new (((self . bits >> 20) & 3) as u8) }
#[doc = "Bits 22:23 - Port 13 configuration bits"]
#[inline (always)] pub fn cnf13 (& self) -> Cnf13R { Cnf13R :: new (((self . bits >> 22) & 3) as u8) }
#[doc = "Bits 24:25 - Port 14 mode bits"]
#[inline (always)] pub fn mode14 (& self) -> Mode14R { Mode14R :: new (((self . bits >> 24) & 3) as u8) }
#[doc = "Bits 26:27 - Port 14 configuration bits"]
#[inline (always)] pub fn cnf14 (& self) -> Cnf14R { Cnf14R :: new (((self . bits >> 26) & 3) as u8) }
#[doc = "Bits 28:29 - Port 15 mode bits"]
#[inline (always)] pub fn mode15 (& self) -> Mode15R { Mode15R :: new (((self . bits >> 28) & 3) as u8) }
#[doc = "Bits 30:31 - Port 15 configuration bits"]
#[inline (always)] pub fn cnf15 (& self) -> Cnf15R { Cnf15R :: new (((self . bits >> 30) & 3) as u8) } } impl W {
#[doc = "Bits 0:1 - Port 8 mode bits"]
#[inline (always)] pub fn mode8 (& mut self) -> Mode8W < '_ , CrhSpec > { Mode8W :: new (self , 0) }
#[doc = "Bits 2:3 - Port 8 configuration bits"]
#[inline (always)] pub fn cnf8 (& mut self) -> Cnf8W < '_ , CrhSpec > { Cnf8W :: new (self , 2) }
#[doc = "Bits 4:5 - Port 9 mode bits"]
#[inline (always)] pub fn mode9 (& mut self) -> Mode9W < '_ , CrhSpec > { Mode9W :: new (self , 4) }
#[doc = "Bits 6:7 - Port 9 configuration bits"]
#[inline (always)] pub fn cnf9 (& mut self) -> Cnf9W < '_ , CrhSpec > { Cnf9W :: new (self , 6) }
#[doc = "Bits 8:9 - Port 10 mode bits"]
#[inline (always)] pub fn mode10 (& mut self) -> Mode10W < '_ , CrhSpec > { Mode10W :: new (self , 8) }
#[doc = "Bits 10:11 - Port 10 configuration bits"]
#[inline (always)] pub fn cnf10 (& mut self) -> Cnf10W < '_ , CrhSpec > { Cnf10W :: new (self , 10) }
#[doc = "Bits 12:13 - Port 11 mode bits"]
#[inline (always)] pub fn mode11 (& mut self) -> Mode11W < '_ , CrhSpec > { Mode11W :: new (self , 12) }
#[doc = "Bits 14:15 - Port 11 configuration bits"]
#[inline (always)] pub fn cnf11 (& mut self) -> Cnf11W < '_ , CrhSpec > { Cnf11W :: new (self , 14) }
#[doc = "Bits 16:17 - Port 12 mode bits"]
#[inline (always)] pub fn mode12 (& mut self) -> Mode12W < '_ , CrhSpec > { Mode12W :: new (self , 16) }
#[doc = "Bits 18:19 - Port 12 configuration bits"]
#[inline (always)] pub fn cnf12 (& mut self) -> Cnf12W < '_ , CrhSpec > { Cnf12W :: new (self , 18) }
#[doc = "Bits 20:21 - Port 13 mode bits"]
#[inline (always)] pub fn mode13 (& mut self) -> Mode13W < '_ , CrhSpec > { Mode13W :: new (self , 20) }
#[doc = "Bits 22:23 - Port 13 configuration bits"]
#[inline (always)] pub fn cnf13 (& mut self) -> Cnf13W < '_ , CrhSpec > { Cnf13W :: new (self , 22) }
#[doc = "Bits 24:25 - Port 14 mode bits"]
#[inline (always)] pub fn mode14 (& mut self) -> Mode14W < '_ , CrhSpec > { Mode14W :: new (self , 24) }
#[doc = "Bits 26:27 - Port 14 configuration bits"]
#[inline (always)] pub fn cnf14 (& mut self) -> Cnf14W < '_ , CrhSpec > { Cnf14W :: new (self , 26) }
#[doc = "Bits 28:29 - Port 15 mode bits"]
#[inline (always)] pub fn mode15 (& mut self) -> Mode15W < '_ , CrhSpec > { Mode15W :: new (self , 28) }
#[doc = "Bits 30:31 - Port 15 configuration bits"]
#[inline (always)] pub fn cnf15 (& mut self) -> Cnf15W < '_ , CrhSpec > { Cnf15W :: new (self , 30) } }
#[doc = "configuration high register\n\nYou can [`read`](crate::Reg::read) this register and get [`crh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`crh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrhSpec ; impl crate :: RegisterSpec for CrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`crh::R`](R) reader structure"] impl crate :: Readable for CrhSpec { }
#[doc = "`write(|w| ..)` method takes [`crh::W`](W) writer structure"] impl crate :: Writable for CrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CRH to value 0x4444_4484"] impl crate :: Resettable for CrhSpec { const RESET_VALUE : u32 = 0x4444_4484 ; } }
#[doc = "IDR (r) register accessor: input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idr`] module"]
#[doc (alias = "IDR")] pub type Idr = crate :: Reg < idr :: IdrSpec > ;
#[doc = "input data register"] pub mod idr {
#[doc = "Register `IDR` reader"] pub type R = crate :: R < IdrSpec > ;
#[doc = "Field `IDR` reader - Port input data"] pub type IdrR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - Port input data"]
#[inline (always)] pub fn idr (& self) -> IdrR { IdrR :: new ((self . bits & 0xffff) as u16) } }
#[doc = "input data register\n\nYou can [`read`](crate::Reg::read) this register and get [`idr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IdrSpec ; impl crate :: RegisterSpec for IdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`idr::R`](R) reader structure"] impl crate :: Readable for IdrSpec { }
#[doc = "`reset()` method sets IDR to value 0"] impl crate :: Resettable for IdrSpec { } }
#[doc = "ODR (rw) register accessor: output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@odr`] module"]
#[doc (alias = "ODR")] pub type Odr = crate :: Reg < odr :: OdrSpec > ;
#[doc = "output data register"] pub mod odr {
#[doc = "Register `ODR` reader"] pub type R = crate :: R < OdrSpec > ;
#[doc = "Register `ODR` writer"] pub type W = crate :: W < OdrSpec > ;
#[doc = "Field `ODR` reader - Port output data"] pub type OdrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ODR` writer - Port output data"] pub type OdrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Port output data"]
#[inline (always)] pub fn odr (& self) -> OdrR { OdrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Port output data"]
#[inline (always)] pub fn odr (& mut self) -> OdrW < '_ , OdrSpec > { OdrW :: new (self , 0) } }
#[doc = "output data register\n\nYou can [`read`](crate::Reg::read) this register and get [`odr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`odr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OdrSpec ; impl crate :: RegisterSpec for OdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`odr::R`](R) reader structure"] impl crate :: Readable for OdrSpec { }
#[doc = "`write(|w| ..)` method takes [`odr::W`](W) writer structure"] impl crate :: Writable for OdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ODR to value 0x0204"] impl crate :: Resettable for OdrSpec { const RESET_VALUE : u32 = 0x0204 ; } }
#[doc = "BSRR (w) register accessor: bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bsrr`] module"]
#[doc (alias = "BSRR")] pub type Bsrr = crate :: Reg < bsrr :: BsrrSpec > ;
#[doc = "bit set/reset register"] pub mod bsrr {
#[doc = "Register `BSRR` writer"] pub type W = crate :: W < BsrrSpec > ;
#[doc = "Field `BS0` writer - Port x Set bit 0"] pub type Bs0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS1` writer - Port x Set bit 1"] pub type Bs1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS2` writer - Port x Set bit 2"] pub type Bs2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS3` writer - Port x Set bit 3"] pub type Bs3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS4` writer - Port x Set bit 4"] pub type Bs4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS5` writer - Port x Set bit 5"] pub type Bs5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS6` writer - Port x Set bit 6"] pub type Bs6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS7` writer - Port x Set bit 7"] pub type Bs7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS8` writer - Port x Set bit 8"] pub type Bs8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS9` writer - Port x Set bit 9"] pub type Bs9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS10` writer - Port x Set bit 10"] pub type Bs10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS11` writer - Port x Set bit 11"] pub type Bs11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS12` writer - Port x Set bit 12"] pub type Bs12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS13` writer - Port x Set bit 13"] pub type Bs13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS14` writer - Port x Set bit 14"] pub type Bs14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BS15` writer - Port x Set bit 15"] pub type Bs15W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR0` writer - Port x Reset bit 0"] pub type Br0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR1` writer - Port x Reset bit 1"] pub type Br1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR2` writer - Port x Reset bit 2"] pub type Br2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR3` writer - Port x Reset bit 3"] pub type Br3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR4` writer - Port x Reset bit 4"] pub type Br4W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR5` writer - Port x Reset bit 5"] pub type Br5W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR6` writer - Port x Reset bit 6"] pub type Br6W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR7` writer - Port x Reset bit 7"] pub type Br7W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR8` writer - Port x Reset bit 8"] pub type Br8W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR9` writer - Port x Reset bit 9"] pub type Br9W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR10` writer - Port x Reset bit 10"] pub type Br10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR11` writer - Port x Reset bit 11"] pub type Br11W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR12` writer - Port x Reset bit 12"] pub type Br12W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR13` writer - Port x Reset bit 13"] pub type Br13W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR14` writer - Port x Reset bit 14"] pub type Br14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BR15` writer - Port x Reset bit 15"] pub type Br15W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Port x Set bit 0"]
#[inline (always)] pub fn bs0 (& mut self) -> Bs0W < '_ , BsrrSpec > { Bs0W :: new (self , 0) }
#[doc = "Bit 1 - Port x Set bit 1"]
#[inline (always)] pub fn bs1 (& mut self) -> Bs1W < '_ , BsrrSpec > { Bs1W :: new (self , 1) }
#[doc = "Bit 2 - Port x Set bit 2"]
#[inline (always)] pub fn bs2 (& mut self) -> Bs2W < '_ , BsrrSpec > { Bs2W :: new (self , 2) }
#[doc = "Bit 3 - Port x Set bit 3"]
#[inline (always)] pub fn bs3 (& mut self) -> Bs3W < '_ , BsrrSpec > { Bs3W :: new (self , 3) }
#[doc = "Bit 4 - Port x Set bit 4"]
#[inline (always)] pub fn bs4 (& mut self) -> Bs4W < '_ , BsrrSpec > { Bs4W :: new (self , 4) }
#[doc = "Bit 5 - Port x Set bit 5"]
#[inline (always)] pub fn bs5 (& mut self) -> Bs5W < '_ , BsrrSpec > { Bs5W :: new (self , 5) }
#[doc = "Bit 6 - Port x Set bit 6"]
#[inline (always)] pub fn bs6 (& mut self) -> Bs6W < '_ , BsrrSpec > { Bs6W :: new (self , 6) }
#[doc = "Bit 7 - Port x Set bit 7"]
#[inline (always)] pub fn bs7 (& mut self) -> Bs7W < '_ , BsrrSpec > { Bs7W :: new (self , 7) }
#[doc = "Bit 8 - Port x Set bit 8"]
#[inline (always)] pub fn bs8 (& mut self) -> Bs8W < '_ , BsrrSpec > { Bs8W :: new (self , 8) }
#[doc = "Bit 9 - Port x Set bit 9"]
#[inline (always)] pub fn bs9 (& mut self) -> Bs9W < '_ , BsrrSpec > { Bs9W :: new (self , 9) }
#[doc = "Bit 10 - Port x Set bit 10"]
#[inline (always)] pub fn bs10 (& mut self) -> Bs10W < '_ , BsrrSpec > { Bs10W :: new (self , 10) }
#[doc = "Bit 11 - Port x Set bit 11"]
#[inline (always)] pub fn bs11 (& mut self) -> Bs11W < '_ , BsrrSpec > { Bs11W :: new (self , 11) }
#[doc = "Bit 12 - Port x Set bit 12"]
#[inline (always)] pub fn bs12 (& mut self) -> Bs12W < '_ , BsrrSpec > { Bs12W :: new (self , 12) }
#[doc = "Bit 13 - Port x Set bit 13"]
#[inline (always)] pub fn bs13 (& mut self) -> Bs13W < '_ , BsrrSpec > { Bs13W :: new (self , 13) }
#[doc = "Bit 14 - Port x Set bit 14"]
#[inline (always)] pub fn bs14 (& mut self) -> Bs14W < '_ , BsrrSpec > { Bs14W :: new (self , 14) }
#[doc = "Bit 15 - Port x Set bit 15"]
#[inline (always)] pub fn bs15 (& mut self) -> Bs15W < '_ , BsrrSpec > { Bs15W :: new (self , 15) }
#[doc = "Bit 16 - Port x Reset bit 0"]
#[inline (always)] pub fn br0 (& mut self) -> Br0W < '_ , BsrrSpec > { Br0W :: new (self , 16) }
#[doc = "Bit 17 - Port x Reset bit 1"]
#[inline (always)] pub fn br1 (& mut self) -> Br1W < '_ , BsrrSpec > { Br1W :: new (self , 17) }
#[doc = "Bit 18 - Port x Reset bit 2"]
#[inline (always)] pub fn br2 (& mut self) -> Br2W < '_ , BsrrSpec > { Br2W :: new (self , 18) }
#[doc = "Bit 19 - Port x Reset bit 3"]
#[inline (always)] pub fn br3 (& mut self) -> Br3W < '_ , BsrrSpec > { Br3W :: new (self , 19) }
#[doc = "Bit 20 - Port x Reset bit 4"]
#[inline (always)] pub fn br4 (& mut self) -> Br4W < '_ , BsrrSpec > { Br4W :: new (self , 20) }
#[doc = "Bit 21 - Port x Reset bit 5"]
#[inline (always)] pub fn br5 (& mut self) -> Br5W < '_ , BsrrSpec > { Br5W :: new (self , 21) }
#[doc = "Bit 22 - Port x Reset bit 6"]
#[inline (always)] pub fn br6 (& mut self) -> Br6W < '_ , BsrrSpec > { Br6W :: new (self , 22) }
#[doc = "Bit 23 - Port x Reset bit 7"]
#[inline (always)] pub fn br7 (& mut self) -> Br7W < '_ , BsrrSpec > { Br7W :: new (self , 23) }
#[doc = "Bit 24 - Port x Reset bit 8"]
#[inline (always)] pub fn br8 (& mut self) -> Br8W < '_ , BsrrSpec > { Br8W :: new (self , 24) }
#[doc = "Bit 25 - Port x Reset bit 9"]
#[inline (always)] pub fn br9 (& mut self) -> Br9W < '_ , BsrrSpec > { Br9W :: new (self , 25) }
#[doc = "Bit 26 - Port x Reset bit 10"]
#[inline (always)] pub fn br10 (& mut self) -> Br10W < '_ , BsrrSpec > { Br10W :: new (self , 26) }
#[doc = "Bit 27 - Port x Reset bit 11"]
#[inline (always)] pub fn br11 (& mut self) -> Br11W < '_ , BsrrSpec > { Br11W :: new (self , 27) }
#[doc = "Bit 28 - Port x Reset bit 12"]
#[inline (always)] pub fn br12 (& mut self) -> Br12W < '_ , BsrrSpec > { Br12W :: new (self , 28) }
#[doc = "Bit 29 - Port x Reset bit 13"]
#[inline (always)] pub fn br13 (& mut self) -> Br13W < '_ , BsrrSpec > { Br13W :: new (self , 29) }
#[doc = "Bit 30 - Port x Reset bit 14"]
#[inline (always)] pub fn br14 (& mut self) -> Br14W < '_ , BsrrSpec > { Br14W :: new (self , 30) }
#[doc = "Bit 31 - Port x Reset bit 15"]
#[inline (always)] pub fn br15 (& mut self) -> Br15W < '_ , BsrrSpec > { Br15W :: new (self , 31) } }
#[doc = "bit set/reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bsrr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BsrrSpec ; impl crate :: RegisterSpec for BsrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`bsrr::W`](W) writer structure"] impl crate :: Writable for BsrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BSRR to value 0"] impl crate :: Resettable for BsrrSpec { } }
#[doc = "BRR (w) register accessor: bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "bit reset register"] pub mod brr {
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `BR` writer - Port x Reset bit y"] pub type BrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - Port x Reset bit y"]
#[inline (always)] pub fn br (& mut self) -> BrW < '_ , BrrSpec > { BrW :: new (self , 0) } }
#[doc = "bit reset register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0"] impl crate :: Resettable for BrrSpec { } }
#[doc = "LCKR (rw) register accessor: Port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lckr`] module"]
#[doc (alias = "LCKR")] pub type Lckr = crate :: Reg < lckr :: LckrSpec > ;
#[doc = "Port configuration lock register"] pub mod lckr {
#[doc = "Register `LCKR` reader"] pub type R = crate :: R < LckrSpec > ;
#[doc = "Register `LCKR` writer"] pub type W = crate :: W < LckrSpec > ;
#[doc = "Field `LCK` reader - Port x Lock bit y"] pub type LckR = crate :: FieldReader < u16 > ;
#[doc = "Field `LCK` writer - Port x Lock bit y"] pub type LckW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ;
#[doc = "Field `LCKK` reader - Lock key"] pub type LckkR = crate :: BitReader ;
#[doc = "Field `LCKK` writer - Lock key"] pub type LckkW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:15 - Port x Lock bit y"]
#[inline (always)] pub fn lck (& self) -> LckR { LckR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bit 16 - Lock key"]
#[inline (always)] pub fn lckk (& self) -> LckkR { LckkR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bits 0:15 - Port x Lock bit y"]
#[inline (always)] pub fn lck (& mut self) -> LckW < '_ , LckrSpec > { LckW :: new (self , 0) }
#[doc = "Bit 16 - Lock key"]
#[inline (always)] pub fn lckk (& mut self) -> LckkW < '_ , LckrSpec > { LckkW :: new (self , 16) } }
#[doc = "Port configuration lock register\n\nYou can [`read`](crate::Reg::read) this register and get [`lckr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lckr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LckrSpec ; impl crate :: RegisterSpec for LckrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`lckr::R`](R) reader structure"] impl crate :: Readable for LckrSpec { }
#[doc = "`write(|w| ..)` method takes [`lckr::W`](W) writer structure"] impl crate :: Writable for LckrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCKR to value 0"] impl crate :: Resettable for LckrSpec { } }
#[doc = "AFRL (rw) register accessor: Port Multiplexing Function Low Register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrl`] module"]
#[doc (alias = "AFRL")] pub type Afrl = crate :: Reg < afrl :: AfrlSpec > ;
#[doc = "Port Multiplexing Function Low Register"] pub mod afrl {
#[doc = "Register `AFRL` reader"] pub type R = crate :: R < AfrlSpec > ;
#[doc = "Register `AFRL` writer"] pub type W = crate :: W < AfrlSpec > ;
#[doc = "Field `AFR0` reader - Multiplexing function selection for bit 0 of portx"] pub type Afr0R = crate :: FieldReader ;
#[doc = "Field `AFR0` writer - Multiplexing function selection for bit 0 of portx"] pub type Afr0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR1` reader - Multiplexing function selection for bit 1 of portx"] pub type Afr1R = crate :: FieldReader ;
#[doc = "Field `AFR1` writer - Multiplexing function selection for bit 1 of portx"] pub type Afr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR2` reader - Multiplexing function selection for bit 2 of portx"] pub type Afr2R = crate :: FieldReader ;
#[doc = "Field `AFR2` writer - Multiplexing function selection for bit 2 of portx"] pub type Afr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR3` reader - Multiplexing function selection for bit 3 of portx"] pub type Afr3R = crate :: FieldReader ;
#[doc = "Field `AFR3` writer - Multiplexing function selection for bit 3 of portx"] pub type Afr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR4` reader - Multiplexing function selection for bit 4 of portx"] pub type Afr4R = crate :: FieldReader ;
#[doc = "Field `AFR4` writer - Multiplexing function selection for bit 4 of portx"] pub type Afr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR5` reader - Multiplexing function selection for bit 5 of portx"] pub type Afr5R = crate :: FieldReader ;
#[doc = "Field `AFR5` writer - Multiplexing function selection for bit 5 of portx"] pub type Afr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR6` reader - Multiplexing function selection for bit 6 of portx"] pub type Afr6R = crate :: FieldReader ;
#[doc = "Field `AFR6` writer - Multiplexing function selection for bit 6 of portx"] pub type Afr6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR7` reader - Multiplexing function selection for bit 7 of portx"] pub type Afr7R = crate :: FieldReader ;
#[doc = "Field `AFR7` writer - Multiplexing function selection for bit 7 of portx"] pub type Afr7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Multiplexing function selection for bit 0 of portx"]
#[inline (always)] pub fn afr0 (& self) -> Afr0R { Afr0R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Multiplexing function selection for bit 1 of portx"]
#[inline (always)] pub fn afr1 (& self) -> Afr1R { Afr1R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Multiplexing function selection for bit 2 of portx"]
#[inline (always)] pub fn afr2 (& self) -> Afr2R { Afr2R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Multiplexing function selection for bit 3 of portx"]
#[inline (always)] pub fn afr3 (& self) -> Afr3R { Afr3R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Multiplexing function selection for bit 4 of portx"]
#[inline (always)] pub fn afr4 (& self) -> Afr4R { Afr4R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Multiplexing function selection for bit 5 of portx"]
#[inline (always)] pub fn afr5 (& self) -> Afr5R { Afr5R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Multiplexing function selection for bit 6 of portx"]
#[inline (always)] pub fn afr6 (& self) -> Afr6R { Afr6R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Multiplexing function selection for bit 7 of portx"]
#[inline (always)] pub fn afr7 (& self) -> Afr7R { Afr7R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Multiplexing function selection for bit 0 of portx"]
#[inline (always)] pub fn afr0 (& mut self) -> Afr0W < '_ , AfrlSpec > { Afr0W :: new (self , 0) }
#[doc = "Bits 4:7 - Multiplexing function selection for bit 1 of portx"]
#[inline (always)] pub fn afr1 (& mut self) -> Afr1W < '_ , AfrlSpec > { Afr1W :: new (self , 4) }
#[doc = "Bits 8:11 - Multiplexing function selection for bit 2 of portx"]
#[inline (always)] pub fn afr2 (& mut self) -> Afr2W < '_ , AfrlSpec > { Afr2W :: new (self , 8) }
#[doc = "Bits 12:15 - Multiplexing function selection for bit 3 of portx"]
#[inline (always)] pub fn afr3 (& mut self) -> Afr3W < '_ , AfrlSpec > { Afr3W :: new (self , 12) }
#[doc = "Bits 16:19 - Multiplexing function selection for bit 4 of portx"]
#[inline (always)] pub fn afr4 (& mut self) -> Afr4W < '_ , AfrlSpec > { Afr4W :: new (self , 16) }
#[doc = "Bits 20:23 - Multiplexing function selection for bit 5 of portx"]
#[inline (always)] pub fn afr5 (& mut self) -> Afr5W < '_ , AfrlSpec > { Afr5W :: new (self , 20) }
#[doc = "Bits 24:27 - Multiplexing function selection for bit 6 of portx"]
#[inline (always)] pub fn afr6 (& mut self) -> Afr6W < '_ , AfrlSpec > { Afr6W :: new (self , 24) }
#[doc = "Bits 28:31 - Multiplexing function selection for bit 7 of portx"]
#[inline (always)] pub fn afr7 (& mut self) -> Afr7W < '_ , AfrlSpec > { Afr7W :: new (self , 28) } }
#[doc = "Port Multiplexing Function Low Register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrlSpec ; impl crate :: RegisterSpec for AfrlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrl::R`](R) reader structure"] impl crate :: Readable for AfrlSpec { }
#[doc = "`write(|w| ..)` method takes [`afrl::W`](W) writer structure"] impl crate :: Writable for AfrlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRL to value 0"] impl crate :: Resettable for AfrlSpec { } }
#[doc = "AFRH (rw) register accessor: Port Multiplexing Function High Register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@afrh`] module"]
#[doc (alias = "AFRH")] pub type Afrh = crate :: Reg < afrh :: AfrhSpec > ;
#[doc = "Port Multiplexing Function High Register"] pub mod afrh {
#[doc = "Register `AFRH` reader"] pub type R = crate :: R < AfrhSpec > ;
#[doc = "Register `AFRH` writer"] pub type W = crate :: W < AfrhSpec > ;
#[doc = "Field `AFR8` reader - Multiplexing function selection for bit 8 of portx"] pub type Afr8R = crate :: FieldReader ;
#[doc = "Field `AFR8` writer - Multiplexing function selection for bit 8 of portx"] pub type Afr8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR9` reader - Multiplexing function selection for bit 9 of portx"] pub type Afr9R = crate :: FieldReader ;
#[doc = "Field `AFR9` writer - Multiplexing function selection for bit 9 of portx"] pub type Afr9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR10` reader - Multiplexing function selection for bit 10 of portx"] pub type Afr10R = crate :: FieldReader ;
#[doc = "Field `AFR10` writer - Multiplexing function selection for bit 10 of portx"] pub type Afr10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR11` reader - Multiplexing function selection for bit 11 of portx"] pub type Afr11R = crate :: FieldReader ;
#[doc = "Field `AFR11` writer - Multiplexing function selection for bit 11 of portx"] pub type Afr11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR12` reader - Multiplexing function selection for bit 12 of portx"] pub type Afr12R = crate :: FieldReader ;
#[doc = "Field `AFR12` writer - Multiplexing function selection for bit 12 of portx"] pub type Afr12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR13` reader - Multiplexing function selection for bit 13 of portx"] pub type Afr13R = crate :: FieldReader ;
#[doc = "Field `AFR13` writer - Multiplexing function selection for bit 13 of portx"] pub type Afr13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR14` reader - Multiplexing function selection for bit 14 of portx"] pub type Afr14R = crate :: FieldReader ;
#[doc = "Field `AFR14` writer - Multiplexing function selection for bit 14 of portx"] pub type Afr14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `AFR15` reader - Multiplexing function selection for bit 15 of portx"] pub type Afr15R = crate :: FieldReader ;
#[doc = "Field `AFR15` writer - Multiplexing function selection for bit 15 of portx"] pub type Afr15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Multiplexing function selection for bit 8 of portx"]
#[inline (always)] pub fn afr8 (& self) -> Afr8R { Afr8R :: new ((self . bits & 0x0f) as u8) }
#[doc = "Bits 4:7 - Multiplexing function selection for bit 9 of portx"]
#[inline (always)] pub fn afr9 (& self) -> Afr9R { Afr9R :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Multiplexing function selection for bit 10 of portx"]
#[inline (always)] pub fn afr10 (& self) -> Afr10R { Afr10R :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:15 - Multiplexing function selection for bit 11 of portx"]
#[inline (always)] pub fn afr11 (& self) -> Afr11R { Afr11R :: new (((self . bits >> 12) & 0x0f) as u8) }
#[doc = "Bits 16:19 - Multiplexing function selection for bit 12 of portx"]
#[inline (always)] pub fn afr12 (& self) -> Afr12R { Afr12R :: new (((self . bits >> 16) & 0x0f) as u8) }
#[doc = "Bits 20:23 - Multiplexing function selection for bit 13 of portx"]
#[inline (always)] pub fn afr13 (& self) -> Afr13R { Afr13R :: new (((self . bits >> 20) & 0x0f) as u8) }
#[doc = "Bits 24:27 - Multiplexing function selection for bit 14 of portx"]
#[inline (always)] pub fn afr14 (& self) -> Afr14R { Afr14R :: new (((self . bits >> 24) & 0x0f) as u8) }
#[doc = "Bits 28:31 - Multiplexing function selection for bit 15 of portx"]
#[inline (always)] pub fn afr15 (& self) -> Afr15R { Afr15R :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Multiplexing function selection for bit 8 of portx"]
#[inline (always)] pub fn afr8 (& mut self) -> Afr8W < '_ , AfrhSpec > { Afr8W :: new (self , 0) }
#[doc = "Bits 4:7 - Multiplexing function selection for bit 9 of portx"]
#[inline (always)] pub fn afr9 (& mut self) -> Afr9W < '_ , AfrhSpec > { Afr9W :: new (self , 4) }
#[doc = "Bits 8:11 - Multiplexing function selection for bit 10 of portx"]
#[inline (always)] pub fn afr10 (& mut self) -> Afr10W < '_ , AfrhSpec > { Afr10W :: new (self , 8) }
#[doc = "Bits 12:15 - Multiplexing function selection for bit 11 of portx"]
#[inline (always)] pub fn afr11 (& mut self) -> Afr11W < '_ , AfrhSpec > { Afr11W :: new (self , 12) }
#[doc = "Bits 16:19 - Multiplexing function selection for bit 12 of portx"]
#[inline (always)] pub fn afr12 (& mut self) -> Afr12W < '_ , AfrhSpec > { Afr12W :: new (self , 16) }
#[doc = "Bits 20:23 - Multiplexing function selection for bit 13 of portx"]
#[inline (always)] pub fn afr13 (& mut self) -> Afr13W < '_ , AfrhSpec > { Afr13W :: new (self , 20) }
#[doc = "Bits 24:27 - Multiplexing function selection for bit 14 of portx"]
#[inline (always)] pub fn afr14 (& mut self) -> Afr14W < '_ , AfrhSpec > { Afr14W :: new (self , 24) }
#[doc = "Bits 28:31 - Multiplexing function selection for bit 15 of portx"]
#[inline (always)] pub fn afr15 (& mut self) -> Afr15W < '_ , AfrhSpec > { Afr15W :: new (self , 28) } }
#[doc = "Port Multiplexing Function High Register\n\nYou can [`read`](crate::Reg::read) this register and get [`afrh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`afrh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AfrhSpec ; impl crate :: RegisterSpec for AfrhSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`afrh::R`](R) reader structure"] impl crate :: Readable for AfrhSpec { }
#[doc = "`write(|w| ..)` method takes [`afrh::W`](W) writer structure"] impl crate :: Writable for AfrhSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AFRH to value 0"] impl crate :: Resettable for AfrhSpec { } } }
#[doc = "General purpose I/O"] pub type Gpiob = crate :: Periph < gpioa :: RegisterBlock , 0x4800_0400 > ; impl core :: fmt :: Debug for Gpiob { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiob") . finish () } }
#[doc = "General purpose I/O"] pub use self :: gpioa as gpiob ;
#[doc = "General purpose I/O"] pub type Gpioc = crate :: Periph < gpioa :: RegisterBlock , 0x4800_0800 > ; impl core :: fmt :: Debug for Gpioc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioc") . finish () } }
#[doc = "General purpose I/O"] pub use self :: gpioa as gpioc ;
#[doc = "General purpose I/O"] pub type Gpiod = crate :: Periph < gpioa :: RegisterBlock , 0x4800_0c00 > ; impl core :: fmt :: Debug for Gpiod { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpiod") . finish () } }
#[doc = "General purpose I/O"] pub use self :: gpioa as gpiod ;
#[doc = "Inter integrated circuit"] pub type I2c1 = crate :: Periph < i2c1 :: RegisterBlock , 0x4000_5400 > ; impl core :: fmt :: Debug for I2c1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c1") . finish () } }
#[doc = "Inter integrated circuit"] pub mod i2c1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , tar : Tar , sar : Sar , _reserved3 : [u8 ; 0x04] , dr : Dr , sshr : Sshr , sslr : Sslr , fshr : Fshr , fslr : Fslr , _reserved8 : [u8 ; 0x08] , isr : Isr , imr : Imr , rawisr : Rawisr , rxtlr : Rxtlr , txtlr : Txtlr , icr : Icr , rx_under : RxUnder , rx_over : RxOver , tx_over : TxOver , rd_req : RdReq , tx_abrt : TxAbrt , rx_done : RxDone , activ : Activ , stop : Stop , start : Start , gc : Gc , enr : Enr , sr : Sr , txflr : Txflr , rxflr : Rxflr , hold : Hold , _reserved29 : [u8 ; 0x08] , dma : Dma , _reserved30 : [u8 ; 0x08] , setup : Setup , gcr : Gcr , } impl RegisterBlock {
#[doc = "0x00 - Control Register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - Target Register"]
#[inline (always)] pub const fn tar (& self) -> & Tar { & self . tar }
#[doc = "0x08 - Slave Address Register"]
#[inline (always)] pub const fn sar (& self) -> & Sar { & self . sar }
#[doc = "0x10 - Data Command Register"]
#[inline (always)] pub const fn dr (& self) -> & Dr { & self . dr }
#[doc = "0x14 - SCL High Period Count for Std. Speed Register"]
#[inline (always)] pub const fn sshr (& self) -> & Sshr { & self . sshr }
#[doc = "0x18 - SCL Low Period Count for Std. Speed Register"]
#[inline (always)] pub const fn sslr (& self) -> & Sslr { & self . sslr }
#[doc = "0x1c - SCL High Period Count for Fast Speed Register"]
#[inline (always)] pub const fn fshr (& self) -> & Fshr { & self . fshr }
#[doc = "0x20 - SCL Low Period Count for Fast Speed Register"]
#[inline (always)] pub const fn fslr (& self) -> & Fslr { & self . fslr }
#[doc = "0x2c - Interrupt Status Register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x30 - Interrupt Mask Register"]
#[inline (always)] pub const fn imr (& self) -> & Imr { & self . imr }
#[doc = "0x34 - RAW Interrupt Status Register"]
#[inline (always)] pub const fn rawisr (& self) -> & Rawisr { & self . rawisr }
#[doc = "0x38 - Receive FIFO Threshold Level Register"]
#[inline (always)] pub const fn rxtlr (& self) -> & Rxtlr { & self . rxtlr }
#[doc = "0x3c - Transmit FIFO Threshold Level Register"]
#[inline (always)] pub const fn txtlr (& self) -> & Txtlr { & self . txtlr }
#[doc = "0x40 - Clear All Interrupt Register"]
#[inline (always)] pub const fn icr (& self) -> & Icr { & self . icr }
#[doc = "0x44 - Clear RX_UNDER Interrupt Register"]
#[inline (always)] pub const fn rx_under (& self) -> & RxUnder { & self . rx_under }
#[doc = "0x48 - Clear RX_OVER Interrupt Register"]
#[inline (always)] pub const fn rx_over (& self) -> & RxOver { & self . rx_over }
#[doc = "0x4c - Clear TX_OVER Interrupt Register"]
#[inline (always)] pub const fn tx_over (& self) -> & TxOver { & self . tx_over }
#[doc = "0x50 - Clear RD_REQ Interrupt Register"]
#[inline (always)] pub const fn rd_req (& self) -> & RdReq { & self . rd_req }
#[doc = "0x54 - Clear TX_ABRT Interrupt Register"]
#[inline (always)] pub const fn tx_abrt (& self) -> & TxAbrt { & self . tx_abrt }
#[doc = "0x58 - Clear RX_DONE Interrupt Register"]
#[inline (always)] pub const fn rx_done (& self) -> & RxDone { & self . rx_done }
#[doc = "0x5c - Clear ACTIVITY Interrupt Register"]
#[inline (always)] pub const fn activ (& self) -> & Activ { & self . activ }
#[doc = "0x60 - Clear STOP_DET Interrupt Register"]
#[inline (always)] pub const fn stop (& self) -> & Stop { & self . stop }
#[doc = "0x64 - Clear START_DET Interrupt Register"]
#[inline (always)] pub const fn start (& self) -> & Start { & self . start }
#[doc = "0x68 - Clear GEN_CALL Interrupt Register"]
#[inline (always)] pub const fn gc (& self) -> & Gc { & self . gc }
#[doc = "0x6c - Enable Register"]
#[inline (always)] pub const fn enr (& self) -> & Enr { & self . enr }
#[doc = "0x70 - Status Register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x74 - Transmit FIFO Level Register"]
#[inline (always)] pub const fn txflr (& self) -> & Txflr { & self . txflr }
#[doc = "0x78 - Receive FIFO Level Register"]
#[inline (always)] pub const fn rxflr (& self) -> & Rxflr { & self . rxflr }
#[doc = "0x7c - SDA Hold Time Register"]
#[inline (always)] pub const fn hold (& self) -> & Hold { & self . hold }
#[doc = "0x88 - DMA Control Register"]
#[inline (always)] pub const fn dma (& self) -> & Dma { & self . dma }
#[doc = "0x94 - SDA Setup Time Register"]
#[inline (always)] pub const fn setup (& self) -> & Setup { & self . setup }
#[doc = "0x98 - ACK General Call Register"]
#[inline (always)] pub const fn gcr (& self) -> & Gcr { & self . gcr } }
#[doc = "CR (rw) register accessor: Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control Register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `MASTER` reader - This bit controls whether the DW_apb_i2c master is enabled"] pub type MasterR = crate :: BitReader ;
#[doc = "Field `MASTER` writer - This bit controls whether the DW_apb_i2c master is enabled"] pub type MasterW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPEED` reader - These bits control at which speed the DW_apb_i2c operates"] pub type SpeedR = crate :: FieldReader ;
#[doc = "Field `SPEED` writer - These bits control at which speed the DW_apb_i2c operates"] pub type SpeedW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SLAVE10` reader - When acting as a alsve"] pub type Slave10R = crate :: BitReader ;
#[doc = "Field `SLAVE10` writer - When acting as a alsve"] pub type Slave10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MASTER10` reader - Address mode when acting as a master"] pub type Master10R = crate :: BitReader ;
#[doc = "Field `MASTER10` writer - Address mode when acting as a master"] pub type Master10W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `REPEN` reader - Determines whether RESTART comdtions may be sent when acting as a master"] pub type RepenR = crate :: BitReader ;
#[doc = "Field `REPEN` writer - Determines whether RESTART comdtions may be sent when acting as a master"] pub type RepenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DISSLAVE` reader - This bit controls whether I2C has its slave diabled"] pub type DisslaveR = crate :: BitReader ;
#[doc = "Field `DISSLAVE` writer - This bit controls whether I2C has its slave diabled"] pub type DisslaveW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOPINT` reader - STOP_DET_IFADDRESSED"] pub type StopintR = crate :: BitReader ;
#[doc = "Field `STOPINT` writer - STOP_DET_IFADDRESSED"] pub type StopintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EMPINT` reader - This bit controls the generation of the TX_EMPTY interrupt"] pub type EmpintR = crate :: BitReader ;
#[doc = "Field `EMPINT` writer - This bit controls the generation of the TX_EMPTY interrupt"] pub type EmpintW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOP` reader - Whether to generate a STOP signal after sending or receiving"] pub type StopR = crate :: BitReader ;
#[doc = "Field `STOP` writer - Whether to generate a STOP signal after sending or receiving"] pub type StopW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RESTART` reader - Whether to generate a RESTART signal after sending or receiving"] pub type RestartR = crate :: BitReader ;
#[doc = "Field `RESTART` writer - Whether to generate a RESTART signal after sending or receiving"] pub type RestartW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - This bit controls whether the DW_apb_i2c master is enabled"]
#[inline (always)] pub fn master (& self) -> MasterR { MasterR :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:2 - These bits control at which speed the DW_apb_i2c operates"]
#[inline (always)] pub fn speed (& self) -> SpeedR { SpeedR :: new (((self . bits >> 1) & 3) as u8) }
#[doc = "Bit 3 - When acting as a alsve"]
#[inline (always)] pub fn slave10 (& self) -> Slave10R { Slave10R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Address mode when acting as a master"]
#[inline (always)] pub fn master10 (& self) -> Master10R { Master10R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Determines whether RESTART comdtions may be sent when acting as a master"]
#[inline (always)] pub fn repen (& self) -> RepenR { RepenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - This bit controls whether I2C has its slave diabled"]
#[inline (always)] pub fn disslave (& self) -> DisslaveR { DisslaveR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - STOP_DET_IFADDRESSED"]
#[inline (always)] pub fn stopint (& self) -> StopintR { StopintR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - This bit controls the generation of the TX_EMPTY interrupt"]
#[inline (always)] pub fn empint (& self) -> EmpintR { EmpintR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Whether to generate a STOP signal after sending or receiving"]
#[inline (always)] pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Whether to generate a RESTART signal after sending or receiving"]
#[inline (always)] pub fn restart (& self) -> RestartR { RestartR :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bit 0 - This bit controls whether the DW_apb_i2c master is enabled"]
#[inline (always)] pub fn master (& mut self) -> MasterW < '_ , CrSpec > { MasterW :: new (self , 0) }
#[doc = "Bits 1:2 - These bits control at which speed the DW_apb_i2c operates"]
#[inline (always)] pub fn speed (& mut self) -> SpeedW < '_ , CrSpec > { SpeedW :: new (self , 1) }
#[doc = "Bit 3 - When acting as a alsve"]
#[inline (always)] pub fn slave10 (& mut self) -> Slave10W < '_ , CrSpec > { Slave10W :: new (self , 3) }
#[doc = "Bit 4 - Address mode when acting as a master"]
#[inline (always)] pub fn master10 (& mut self) -> Master10W < '_ , CrSpec > { Master10W :: new (self , 4) }
#[doc = "Bit 5 - Determines whether RESTART comdtions may be sent when acting as a master"]
#[inline (always)] pub fn repen (& mut self) -> RepenW < '_ , CrSpec > { RepenW :: new (self , 5) }
#[doc = "Bit 6 - This bit controls whether I2C has its slave diabled"]
#[inline (always)] pub fn disslave (& mut self) -> DisslaveW < '_ , CrSpec > { DisslaveW :: new (self , 6) }
#[doc = "Bit 7 - STOP_DET_IFADDRESSED"]
#[inline (always)] pub fn stopint (& mut self) -> StopintW < '_ , CrSpec > { StopintW :: new (self , 7) }
#[doc = "Bit 8 - This bit controls the generation of the TX_EMPTY interrupt"]
#[inline (always)] pub fn empint (& mut self) -> EmpintW < '_ , CrSpec > { EmpintW :: new (self , 8) }
#[doc = "Bit 9 - Whether to generate a STOP signal after sending or receiving"]
#[inline (always)] pub fn stop (& mut self) -> StopW < '_ , CrSpec > { StopW :: new (self , 9) }
#[doc = "Bit 10 - Whether to generate a RESTART signal after sending or receiving"]
#[inline (always)] pub fn restart (& mut self) -> RestartW < '_ , CrSpec > { RestartW :: new (self , 10) } }
#[doc = "Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x7f"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x7f ; } }
#[doc = "TAR (rw) register accessor: Target Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tar`] module"]
#[doc (alias = "TAR")] pub type Tar = crate :: Reg < tar :: TarSpec > ;
#[doc = "Target Register"] pub mod tar {
#[doc = "Register `TAR` reader"] pub type R = crate :: R < TarSpec > ;
#[doc = "Register `TAR` writer"] pub type W = crate :: W < TarSpec > ;
#[doc = "Field `ADDR` reader - This is the target address for any master transaction"] pub type AddrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR` writer - This is the target address for any master transaction"] pub type AddrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ;
#[doc = "Field `GC` reader - If bit 11(SPECIAL)is set to 1"] pub type GcR = crate :: BitReader ;
#[doc = "Field `GC` writer - If bit 11(SPECIAL)is set to 1"] pub type GcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPECIAL` reader - This bit indicates whether software performs a General Call or START BYTE conmmend"] pub type SpecialR = crate :: BitReader ;
#[doc = "Field `SPECIAL` writer - This bit indicates whether software performs a General Call or START BYTE conmmend"] pub type SpecialW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:9 - This is the target address for any master transaction"]
#[inline (always)] pub fn addr (& self) -> AddrR { AddrR :: new ((self . bits & 0x03ff) as u16) }
#[doc = "Bit 10 - If bit 11(SPECIAL)is set to 1"]
#[inline (always)] pub fn gc (& self) -> GcR { GcR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - This bit indicates whether software performs a General Call or START BYTE conmmend"]
#[inline (always)] pub fn special (& self) -> SpecialR { SpecialR :: new (((self . bits >> 11) & 1) != 0) } } impl W {
#[doc = "Bits 0:9 - This is the target address for any master transaction"]
#[inline (always)] pub fn addr (& mut self) -> AddrW < '_ , TarSpec > { AddrW :: new (self , 0) }
#[doc = "Bit 10 - If bit 11(SPECIAL)is set to 1"]
#[inline (always)] pub fn gc (& mut self) -> GcW < '_ , TarSpec > { GcW :: new (self , 10) }
#[doc = "Bit 11 - This bit indicates whether software performs a General Call or START BYTE conmmend"]
#[inline (always)] pub fn special (& mut self) -> SpecialW < '_ , TarSpec > { SpecialW :: new (self , 11) } }
#[doc = "Target Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TarSpec ; impl crate :: RegisterSpec for TarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tar::R`](R) reader structure"] impl crate :: Readable for TarSpec { }
#[doc = "`write(|w| ..)` method takes [`tar::W`](W) writer structure"] impl crate :: Writable for TarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TAR to value 0x55"] impl crate :: Resettable for TarSpec { const RESET_VALUE : u32 = 0x55 ; } }
#[doc = "SAR (rw) register accessor: Slave Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sar`] module"]
#[doc (alias = "SAR")] pub type Sar = crate :: Reg < sar :: SarSpec > ;
#[doc = "Slave Address Register"] pub mod sar {
#[doc = "Register `SAR` reader"] pub type R = crate :: R < SarSpec > ;
#[doc = "Register `SAR` writer"] pub type W = crate :: W < SarSpec > ;
#[doc = "Field `ADDR` reader - The SAR holds the slave address when the i2c is operation as a slave"] pub type AddrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ADDR` writer - The SAR holds the slave address when the i2c is operation as a slave"] pub type AddrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R {
#[doc = "Bits 0:9 - The SAR holds the slave address when the i2c is operation as a slave"]
#[inline (always)] pub fn addr (& self) -> AddrR { AddrR :: new ((self . bits & 0x03ff) as u16) } } impl W {
#[doc = "Bits 0:9 - The SAR holds the slave address when the i2c is operation as a slave"]
#[inline (always)] pub fn addr (& mut self) -> AddrW < '_ , SarSpec > { AddrW :: new (self , 0) } }
#[doc = "Slave Address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SarSpec ; impl crate :: RegisterSpec for SarSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sar::R`](R) reader structure"] impl crate :: Readable for SarSpec { }
#[doc = "`write(|w| ..)` method takes [`sar::W`](W) writer structure"] impl crate :: Writable for SarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SAR to value 0x55"] impl crate :: Resettable for SarSpec { const RESET_VALUE : u32 = 0x55 ; } }
#[doc = "DR (rw) register accessor: Data Command Register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dr`] module"]
#[doc (alias = "DR")] pub type Dr = crate :: Reg < dr :: DrSpec > ;
#[doc = "Data Command Register"] pub mod dr {
#[doc = "Register `DR` reader"] pub type R = crate :: R < DrSpec > ;
#[doc = "Register `DR` writer"] pub type W = crate :: W < DrSpec > ;
#[doc = "Field `DAT` reader - This register contains the data to be transimitted or received on the i2c bus."] pub type DatR = crate :: FieldReader ;
#[doc = "Field `DAT` writer - This register contains the data to be transimitted or received on the i2c bus."] pub type DatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `CMD` reader - This bit controls whether a read or a write is perormed"] pub type CmdR = crate :: BitReader ;
#[doc = "Field `CMD` writer - This bit controls whether a read or a write is perormed"] pub type CmdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - This register contains the data to be transimitted or received on the i2c bus."]
#[inline (always)] pub fn dat (& self) -> DatR { DatR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - This bit controls whether a read or a write is perormed"]
#[inline (always)] pub fn cmd (& self) -> CmdR { CmdR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - This register contains the data to be transimitted or received on the i2c bus."]
#[inline (always)] pub fn dat (& mut self) -> DatW < '_ , DrSpec > { DatW :: new (self , 0) }
#[doc = "Bit 8 - This bit controls whether a read or a write is perormed"]
#[inline (always)] pub fn cmd (& mut self) -> CmdW < '_ , DrSpec > { CmdW :: new (self , 8) } }
#[doc = "Data Command Register\n\nYou can [`read`](crate::Reg::read) this register and get [`dr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DrSpec ; impl crate :: RegisterSpec for DrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dr::R`](R) reader structure"] impl crate :: Readable for DrSpec { }
#[doc = "`write(|w| ..)` method takes [`dr::W`](W) writer structure"] impl crate :: Writable for DrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DR to value 0x01"] impl crate :: Resettable for DrSpec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "SSHR (rw) register accessor: SCL High Period Count for Std. Speed Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sshr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sshr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sshr`] module"]
#[doc (alias = "SSHR")] pub type Sshr = crate :: Reg < sshr :: SshrSpec > ;
#[doc = "SCL High Period Count for Std. Speed Register"] pub mod sshr {
#[doc = "Register `SSHR` reader"] pub type R = crate :: R < SshrSpec > ;
#[doc = "Register `SSHR` writer"] pub type W = crate :: W < SshrSpec > ;
#[doc = "Field `CNT` reader - This register sets the SCL clock high period count for standard speed"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - This register sets the SCL clock high period count for standard speed"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - This register sets the SCL clock high period count for standard speed"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - This register sets the SCL clock high period count for standard speed"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , SshrSpec > { CntW :: new (self , 0) } }
#[doc = "SCL High Period Count for Std. Speed Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sshr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sshr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SshrSpec ; impl crate :: RegisterSpec for SshrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sshr::R`](R) reader structure"] impl crate :: Readable for SshrSpec { }
#[doc = "`write(|w| ..)` method takes [`sshr::W`](W) writer structure"] impl crate :: Writable for SshrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SSHR to value 0x0190"] impl crate :: Resettable for SshrSpec { const RESET_VALUE : u32 = 0x0190 ; } }
#[doc = "SSLR (rw) register accessor: SCL Low Period Count for Std. Speed Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sslr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sslr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sslr`] module"]
#[doc (alias = "SSLR")] pub type Sslr = crate :: Reg < sslr :: SslrSpec > ;
#[doc = "SCL Low Period Count for Std. Speed Register"] pub mod sslr {
#[doc = "Register `SSLR` reader"] pub type R = crate :: R < SslrSpec > ;
#[doc = "Register `SSLR` writer"] pub type W = crate :: W < SslrSpec > ;
#[doc = "Field `CNT` reader - This register sets the SCL clock low period count for standard speed"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - This register sets the SCL clock low period count for standard speed"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - This register sets the SCL clock low period count for standard speed"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - This register sets the SCL clock low period count for standard speed"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , SslrSpec > { CntW :: new (self , 0) } }
#[doc = "SCL Low Period Count for Std. Speed Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sslr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sslr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SslrSpec ; impl crate :: RegisterSpec for SslrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sslr::R`](R) reader structure"] impl crate :: Readable for SslrSpec { }
#[doc = "`write(|w| ..)` method takes [`sslr::W`](W) writer structure"] impl crate :: Writable for SslrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SSLR to value 0x01d6"] impl crate :: Resettable for SslrSpec { const RESET_VALUE : u32 = 0x01d6 ; } }
#[doc = "FSHR (rw) register accessor: SCL High Period Count for Fast Speed Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fshr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fshr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fshr`] module"]
#[doc (alias = "FSHR")] pub type Fshr = crate :: Reg < fshr :: FshrSpec > ;
#[doc = "SCL High Period Count for Fast Speed Register"] pub mod fshr {
#[doc = "Register `FSHR` reader"] pub type R = crate :: R < FshrSpec > ;
#[doc = "Register `FSHR` writer"] pub type W = crate :: W < FshrSpec > ;
#[doc = "Field `CNT` reader - This register sets the SCL clock high_period count for standard speed"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - This register sets the SCL clock high_period count for standard speed"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - This register sets the SCL clock high_period count for standard speed"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - This register sets the SCL clock high_period count for standard speed"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , FshrSpec > { CntW :: new (self , 0) } }
#[doc = "SCL High Period Count for Fast Speed Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fshr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fshr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FshrSpec ; impl crate :: RegisterSpec for FshrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fshr::R`](R) reader structure"] impl crate :: Readable for FshrSpec { }
#[doc = "`write(|w| ..)` method takes [`fshr::W`](W) writer structure"] impl crate :: Writable for FshrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FSHR to value 0x36"] impl crate :: Resettable for FshrSpec { const RESET_VALUE : u32 = 0x36 ; } }
#[doc = "FSLR (rw) register accessor: SCL Low Period Count for Fast Speed Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fslr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fslr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fslr`] module"]
#[doc (alias = "FSLR")] pub type Fslr = crate :: Reg < fslr :: FslrSpec > ;
#[doc = "SCL Low Period Count for Fast Speed Register"] pub mod fslr {
#[doc = "Register `FSLR` reader"] pub type R = crate :: R < FslrSpec > ;
#[doc = "Register `FSLR` writer"] pub type W = crate :: W < FslrSpec > ;
#[doc = "Field `CNT` reader - This register sets the SCL clock low period count for standard speed"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - This register sets the SCL clock low period count for standard speed"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - This register sets the SCL clock low period count for standard speed"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - This register sets the SCL clock low period count for standard speed"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , FslrSpec > { CntW :: new (self , 0) } }
#[doc = "SCL Low Period Count for Fast Speed Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fslr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fslr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FslrSpec ; impl crate :: RegisterSpec for FslrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fslr::R`](R) reader structure"] impl crate :: Readable for FslrSpec { }
#[doc = "`write(|w| ..)` method takes [`fslr::W`](W) writer structure"] impl crate :: Writable for FslrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FSLR to value 0x82"] impl crate :: Resettable for FslrSpec { const RESET_VALUE : u32 = 0x82 ; } }
#[doc = "ISR (r) register accessor: Interrupt Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "Interrupt Status Register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Field `ISR` reader - Specific bit description refer to RAWISR"] pub type IsrR = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:10 - Specific bit description refer to RAWISR"]
#[inline (always)] pub fn isr (& self) -> IsrR { IsrR :: new ((self . bits & 0x07ff) as u16) } }
#[doc = "Interrupt Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "IMR (rw) register accessor: Interrupt Mask Register\n\nYou can [`read`](crate::Reg::read) this register and get [`imr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`imr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@imr`] module"]
#[doc (alias = "IMR")] pub type Imr = crate :: Reg < imr :: ImrSpec > ;
#[doc = "Interrupt Mask Register"] pub mod imr {
#[doc = "Register `IMR` reader"] pub type R = crate :: R < ImrSpec > ;
#[doc = "Register `IMR` writer"] pub type W = crate :: W < ImrSpec > ;
#[doc = "Field `IMR` reader - Specific bit description shield RAWISR"] pub type ImrR = crate :: FieldReader < u16 > ;
#[doc = "Field `IMR` writer - Specific bit description shield RAWISR"] pub type ImrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ; impl R {
#[doc = "Bits 0:10 - Specific bit description shield RAWISR"]
#[inline (always)] pub fn imr (& self) -> ImrR { ImrR :: new ((self . bits & 0x07ff) as u16) } } impl W {
#[doc = "Bits 0:10 - Specific bit description shield RAWISR"]
#[inline (always)] pub fn imr (& mut self) -> ImrW < '_ , ImrSpec > { ImrW :: new (self , 0) } }
#[doc = "Interrupt Mask Register\n\nYou can [`read`](crate::Reg::read) this register and get [`imr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`imr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ImrSpec ; impl crate :: RegisterSpec for ImrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`imr::R`](R) reader structure"] impl crate :: Readable for ImrSpec { }
#[doc = "`write(|w| ..)` method takes [`imr::W`](W) writer structure"] impl crate :: Writable for ImrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IMR to value 0x08ff"] impl crate :: Resettable for ImrSpec { const RESET_VALUE : u32 = 0x08ff ; } }
#[doc = "RAWISR (r) register accessor: RAW Interrupt Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rawisr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rawisr`] module"]
#[doc (alias = "RAWISR")] pub type Rawisr = crate :: Reg < rawisr :: RawisrSpec > ;
#[doc = "RAW Interrupt Status Register"] pub mod rawisr {
#[doc = "Register `RAWISR` reader"] pub type R = crate :: R < RawisrSpec > ;
#[doc = "Field `RX_UNDER` reader - Receive buffer under"] pub type RxUnderR = crate :: BitReader ;
#[doc = "Field `RX_OVER` reader - Receive buffer over"] pub type RxOverR = crate :: BitReader ;
#[doc = "Field `RX_FULL` reader - Receive buffer not empty"] pub type RxFullR = crate :: BitReader ;
#[doc = "Field `TX_OVER` reader - Transmit buffer over"] pub type TxOverR = crate :: BitReader ;
#[doc = "Field `TX_EMPTY` reader - Transmit buffer empty"] pub type TxEmptyR = crate :: BitReader ;
#[doc = "Field `RD_REQ` reader - Read request"] pub type RdReqR = crate :: BitReader ;
#[doc = "Field `TX_ABRT` reader - Transmit abort"] pub type TxAbrtR = crate :: BitReader ;
#[doc = "Field `RX_DONE` reader - Transmit done"] pub type RxDoneR = crate :: BitReader ;
#[doc = "Field `ACTIV` reader - This bit captures DW_spb_i2c acticity and stays set until it is cleared"] pub type ActivR = crate :: BitReader ;
#[doc = "Field `STOP` reader - Stop condition detection"] pub type StopR = crate :: BitReader ;
#[doc = "Field `START` reader - Start condition detection"] pub type StartR = crate :: BitReader ;
#[doc = "Field `GC` reader - General call"] pub type GcR = crate :: BitReader ;
#[doc = "Field `RESTART` reader - RESTART_DET interrupt status"] pub type RestartR = crate :: BitReader ;
#[doc = "Field `HOLD` reader - MST_ON_HOLD interrupt status"] pub type HoldR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Receive buffer under"]
#[inline (always)] pub fn rx_under (& self) -> RxUnderR { RxUnderR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receive buffer over"]
#[inline (always)] pub fn rx_over (& self) -> RxOverR { RxOverR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Receive buffer not empty"]
#[inline (always)] pub fn rx_full (& self) -> RxFullR { RxFullR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transmit buffer over"]
#[inline (always)] pub fn tx_over (& self) -> TxOverR { TxOverR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Transmit buffer empty"]
#[inline (always)] pub fn tx_empty (& self) -> TxEmptyR { TxEmptyR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Read request"]
#[inline (always)] pub fn rd_req (& self) -> RdReqR { RdReqR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transmit abort"]
#[inline (always)] pub fn tx_abrt (& self) -> TxAbrtR { TxAbrtR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transmit done"]
#[inline (always)] pub fn rx_done (& self) -> RxDoneR { RxDoneR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - This bit captures DW_spb_i2c acticity and stays set until it is cleared"]
#[inline (always)] pub fn activ (& self) -> ActivR { ActivR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Stop condition detection"]
#[inline (always)] pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Start condition detection"]
#[inline (always)] pub fn start (& self) -> StartR { StartR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - General call"]
#[inline (always)] pub fn gc (& self) -> GcR { GcR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - RESTART_DET interrupt status"]
#[inline (always)] pub fn restart (& self) -> RestartR { RestartR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - MST_ON_HOLD interrupt status"]
#[inline (always)] pub fn hold (& self) -> HoldR { HoldR :: new (((self . bits >> 13) & 1) != 0) } }
#[doc = "RAW Interrupt Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rawisr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RawisrSpec ; impl crate :: RegisterSpec for RawisrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rawisr::R`](R) reader structure"] impl crate :: Readable for RawisrSpec { }
#[doc = "`reset()` method sets RAWISR to value 0"] impl crate :: Resettable for RawisrSpec { } }
#[doc = "RXTLR (r) register accessor: Receive FIFO Threshold Level Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxtlr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxtlr`] module"]
#[doc (alias = "RXTLR")] pub type Rxtlr = crate :: Reg < rxtlr :: RxtlrSpec > ;
#[doc = "Receive FIFO Threshold Level Register"] pub mod rxtlr {
#[doc = "Register `RXTLR` reader"] pub type R = crate :: R < RxtlrSpec > ;
#[doc = "Field `TL` reader - Receive FIFO threshold level"] pub type TlR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - Receive FIFO threshold level"]
#[inline (always)] pub fn tl (& self) -> TlR { TlR :: new ((self . bits & 0xff) as u8) } }
#[doc = "Receive FIFO Threshold Level Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxtlr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxtlrSpec ; impl crate :: RegisterSpec for RxtlrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rxtlr::R`](R) reader structure"] impl crate :: Readable for RxtlrSpec { }
#[doc = "`reset()` method sets RXTLR to value 0"] impl crate :: Resettable for RxtlrSpec { } }
#[doc = "TXTLR (r) register accessor: Transmit FIFO Threshold Level Register\n\nYou can [`read`](crate::Reg::read) this register and get [`txtlr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txtlr`] module"]
#[doc (alias = "TXTLR")] pub type Txtlr = crate :: Reg < txtlr :: TxtlrSpec > ;
#[doc = "Transmit FIFO Threshold Level Register"] pub mod txtlr {
#[doc = "Register `TXTLR` reader"] pub type R = crate :: R < TxtlrSpec > ;
#[doc = "Field `TL` reader - Transmit FIFO threshold level"] pub type TlR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - Transmit FIFO threshold level"]
#[inline (always)] pub fn tl (& self) -> TlR { TlR :: new ((self . bits & 0xff) as u8) } }
#[doc = "Transmit FIFO Threshold Level Register\n\nYou can [`read`](crate::Reg::read) this register and get [`txtlr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TxtlrSpec ; impl crate :: RegisterSpec for TxtlrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`txtlr::R`](R) reader structure"] impl crate :: Readable for TxtlrSpec { }
#[doc = "`reset()` method sets TXTLR to value 0"] impl crate :: Resettable for TxtlrSpec { } }
#[doc = "ICR (r) register accessor: Clear All Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`icr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`] module"]
#[doc (alias = "ICR")] pub type Icr = crate :: Reg < icr :: IcrSpec > ;
#[doc = "Clear All Interrupt Register"] pub mod icr {
#[doc = "Register `ICR` reader"] pub type R = crate :: R < IcrSpec > ;
#[doc = "Field `ICR` reader - Read this register to clear the combined interrupt"] pub type IcrR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the combined interrupt"]
#[inline (always)] pub fn icr (& self) -> IcrR { IcrR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear All Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`icr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`icr::R`](R) reader structure"] impl crate :: Readable for IcrSpec { }
#[doc = "`reset()` method sets ICR to value 0"] impl crate :: Resettable for IcrSpec { } }
#[doc = "RX_UNDER (r) register accessor: Clear RX_UNDER Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_under::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_under`] module"]
#[doc (alias = "RX_UNDER")] pub type RxUnder = crate :: Reg < rx_under :: RxUnderSpec > ;
#[doc = "Clear RX_UNDER Interrupt Register"] pub mod rx_under {
#[doc = "Register `RX_UNDER` reader"] pub type R = crate :: R < RxUnderSpec > ;
#[doc = "Field `RX_UNDER` reader - Read this register to clear the RX_UNDER interrupt(bit 0)of the RAWISR register"] pub type RxUnderR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the RX_UNDER interrupt(bit 0)of the RAWISR register"]
#[inline (always)] pub fn rx_under (& self) -> RxUnderR { RxUnderR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear RX_UNDER Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_under::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxUnderSpec ; impl crate :: RegisterSpec for RxUnderSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rx_under::R`](R) reader structure"] impl crate :: Readable for RxUnderSpec { }
#[doc = "`reset()` method sets RX_UNDER to value 0"] impl crate :: Resettable for RxUnderSpec { } }
#[doc = "RX_OVER (r) register accessor: Clear RX_OVER Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_over::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_over`] module"]
#[doc (alias = "RX_OVER")] pub type RxOver = crate :: Reg < rx_over :: RxOverSpec > ;
#[doc = "Clear RX_OVER Interrupt Register"] pub mod rx_over {
#[doc = "Register `RX_OVER` reader"] pub type R = crate :: R < RxOverSpec > ;
#[doc = "Field `RX_OVER` reader - Read this register to clear the RX_UNDER interrupt(bit 1)of the RAWISR register"] pub type RxOverR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the RX_UNDER interrupt(bit 1)of the RAWISR register"]
#[inline (always)] pub fn rx_over (& self) -> RxOverR { RxOverR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear RX_OVER Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_over::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxOverSpec ; impl crate :: RegisterSpec for RxOverSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rx_over::R`](R) reader structure"] impl crate :: Readable for RxOverSpec { }
#[doc = "`reset()` method sets RX_OVER to value 0"] impl crate :: Resettable for RxOverSpec { } }
#[doc = "TX_OVER (r) register accessor: Clear TX_OVER Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_over::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_over`] module"]
#[doc (alias = "TX_OVER")] pub type TxOver = crate :: Reg < tx_over :: TxOverSpec > ;
#[doc = "Clear TX_OVER Interrupt Register"] pub mod tx_over {
#[doc = "Register `TX_OVER` reader"] pub type R = crate :: R < TxOverSpec > ;
#[doc = "Field `TX_OVER` reader - Read this register to clear the RX_UNDER interrupt(bit 3)of the RAWISR register"] pub type TxOverR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the RX_UNDER interrupt(bit 3)of the RAWISR register"]
#[inline (always)] pub fn tx_over (& self) -> TxOverR { TxOverR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear TX_OVER Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_over::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TxOverSpec ; impl crate :: RegisterSpec for TxOverSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tx_over::R`](R) reader structure"] impl crate :: Readable for TxOverSpec { }
#[doc = "`reset()` method sets TX_OVER to value 0"] impl crate :: Resettable for TxOverSpec { } }
#[doc = "RD_REQ (r) register accessor: Clear RD_REQ Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rd_req::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rd_req`] module"]
#[doc (alias = "RD_REQ")] pub type RdReq = crate :: Reg < rd_req :: RdReqSpec > ;
#[doc = "Clear RD_REQ Interrupt Register"] pub mod rd_req {
#[doc = "Register `RD_REQ` reader"] pub type R = crate :: R < RdReqSpec > ;
#[doc = "Field `RD_REQ` reader - Read this register to clear the RX_UNDER interrupt(bit 5)of the RAWISR register"] pub type RdReqR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the RX_UNDER interrupt(bit 5)of the RAWISR register"]
#[inline (always)] pub fn rd_req (& self) -> RdReqR { RdReqR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear RD_REQ Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rd_req::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RdReqSpec ; impl crate :: RegisterSpec for RdReqSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rd_req::R`](R) reader structure"] impl crate :: Readable for RdReqSpec { }
#[doc = "`reset()` method sets RD_REQ to value 0"] impl crate :: Resettable for RdReqSpec { } }
#[doc = "TX_ABRT (r) register accessor: Clear TX_ABRT Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_abrt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_abrt`] module"]
#[doc (alias = "TX_ABRT")] pub type TxAbrt = crate :: Reg < tx_abrt :: TxAbrtSpec > ;
#[doc = "Clear TX_ABRT Interrupt Register"] pub mod tx_abrt {
#[doc = "Register `TX_ABRT` reader"] pub type R = crate :: R < TxAbrtSpec > ;
#[doc = "Field `TX_ABRT` reader - Read this register to clear the RX_UNDER interrupt(bit 6)of the RAWISR register"] pub type TxAbrtR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the RX_UNDER interrupt(bit 6)of the RAWISR register"]
#[inline (always)] pub fn tx_abrt (& self) -> TxAbrtR { TxAbrtR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear TX_ABRT Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_abrt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TxAbrtSpec ; impl crate :: RegisterSpec for TxAbrtSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tx_abrt::R`](R) reader structure"] impl crate :: Readable for TxAbrtSpec { }
#[doc = "`reset()` method sets TX_ABRT to value 0"] impl crate :: Resettable for TxAbrtSpec { } }
#[doc = "RX_DONE (r) register accessor: Clear RX_DONE Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_done::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_done`] module"]
#[doc (alias = "RX_DONE")] pub type RxDone = crate :: Reg < rx_done :: RxDoneSpec > ;
#[doc = "Clear RX_DONE Interrupt Register"] pub mod rx_done {
#[doc = "Register `RX_DONE` reader"] pub type R = crate :: R < RxDoneSpec > ;
#[doc = "Field `RX_DONE` reader - Read this register to clear the RX_UNDER interrupt(bit 7)of the RAWISR register"] pub type RxDoneR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the RX_UNDER interrupt(bit 7)of the RAWISR register"]
#[inline (always)] pub fn rx_done (& self) -> RxDoneR { RxDoneR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear RX_DONE Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_done::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxDoneSpec ; impl crate :: RegisterSpec for RxDoneSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rx_done::R`](R) reader structure"] impl crate :: Readable for RxDoneSpec { }
#[doc = "`reset()` method sets RX_DONE to value 0"] impl crate :: Resettable for RxDoneSpec { } }
#[doc = "ACTIV (r) register accessor: Clear ACTIVITY Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`activ::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@activ`] module"]
#[doc (alias = "ACTIV")] pub type Activ = crate :: Reg < activ :: ActivSpec > ;
#[doc = "Clear ACTIVITY Interrupt Register"] pub mod activ {
#[doc = "Register `ACTIV` reader"] pub type R = crate :: R < ActivSpec > ;
#[doc = "Field `ACTIV` reader - Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore"] pub type ActivR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore"]
#[inline (always)] pub fn activ (& self) -> ActivR { ActivR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear ACTIVITY Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`activ::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ActivSpec ; impl crate :: RegisterSpec for ActivSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`activ::R`](R) reader structure"] impl crate :: Readable for ActivSpec { }
#[doc = "`reset()` method sets ACTIV to value 0"] impl crate :: Resettable for ActivSpec { } }
#[doc = "STOP (r) register accessor: Clear STOP_DET Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`stop::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stop`] module"]
#[doc (alias = "STOP")] pub type Stop = crate :: Reg < stop :: StopSpec > ;
#[doc = "Clear STOP_DET Interrupt Register"] pub mod stop {
#[doc = "Register `STOP` reader"] pub type R = crate :: R < StopSpec > ;
#[doc = "Field `STOP` reader - Read this register to clear the STOP_DET interrupt(bit 9)of the RAWISR register"] pub type StopR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the STOP_DET interrupt(bit 9)of the RAWISR register"]
#[inline (always)] pub fn stop (& self) -> StopR { StopR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear STOP_DET Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`stop::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct StopSpec ; impl crate :: RegisterSpec for StopSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`stop::R`](R) reader structure"] impl crate :: Readable for StopSpec { }
#[doc = "`reset()` method sets STOP to value 0"] impl crate :: Resettable for StopSpec { } }
#[doc = "START (r) register accessor: Clear START_DET Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`start::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@start`] module"]
#[doc (alias = "START")] pub type Start = crate :: Reg < start :: StartSpec > ;
#[doc = "Clear START_DET Interrupt Register"] pub mod start {
#[doc = "Register `START` reader"] pub type R = crate :: R < StartSpec > ;
#[doc = "Field `START` reader - Read this register to clear the START_DET interrupt(bit 10)of the RAWISR register"] pub type StartR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the START_DET interrupt(bit 10)of the RAWISR register"]
#[inline (always)] pub fn start (& self) -> StartR { StartR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear START_DET Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`start::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct StartSpec ; impl crate :: RegisterSpec for StartSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`start::R`](R) reader structure"] impl crate :: Readable for StartSpec { }
#[doc = "`reset()` method sets START to value 0"] impl crate :: Resettable for StartSpec { } }
#[doc = "GC (r) register accessor: Clear GEN_CALL Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`gc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gc`] module"]
#[doc (alias = "GC")] pub type Gc = crate :: Reg < gc :: GcSpec > ;
#[doc = "Clear GEN_CALL Interrupt Register"] pub mod gc {
#[doc = "Register `GC` reader"] pub type R = crate :: R < GcSpec > ;
#[doc = "Field `GC` reader - Read this register to clear the GEN_CALL interrupt(bit 11)of the RAWISR register"] pub type GcR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Read this register to clear the GEN_CALL interrupt(bit 11)of the RAWISR register"]
#[inline (always)] pub fn gc (& self) -> GcR { GcR :: new ((self . bits & 1) != 0) } }
#[doc = "Clear GEN_CALL Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`gc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GcSpec ; impl crate :: RegisterSpec for GcSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`gc::R`](R) reader structure"] impl crate :: Readable for GcSpec { }
#[doc = "`reset()` method sets GC to value 0"] impl crate :: Resettable for GcSpec { } }
#[doc = "ENR (rw) register accessor: Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enr`] module"]
#[doc (alias = "ENR")] pub type Enr = crate :: Reg < enr :: EnrSpec > ;
#[doc = "Enable Register"] pub mod enr {
#[doc = "Register `ENR` reader"] pub type R = crate :: R < EnrSpec > ;
#[doc = "Register `ENR` writer"] pub type W = crate :: W < EnrSpec > ;
#[doc = "Field `ENABLE` reader - I2C mode enable"] pub type EnableR = crate :: BitReader ;
#[doc = "Field `ENABLE` writer - I2C mode enable"] pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ABORT` reader - I2C transfer abort"] pub type AbortR = crate :: BitReader ;
#[doc = "Field `ABORT` writer - I2C transfer abort"] pub type AbortW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - I2C mode enable"]
#[inline (always)] pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - I2C transfer abort"]
#[inline (always)] pub fn abort (& self) -> AbortR { AbortR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - I2C mode enable"]
#[inline (always)] pub fn enable (& mut self) -> EnableW < '_ , EnrSpec > { EnableW :: new (self , 0) }
#[doc = "Bit 1 - I2C transfer abort"]
#[inline (always)] pub fn abort (& mut self) -> AbortW < '_ , EnrSpec > { AbortW :: new (self , 1) } }
#[doc = "Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EnrSpec ; impl crate :: RegisterSpec for EnrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`enr::R`](R) reader structure"] impl crate :: Readable for EnrSpec { }
#[doc = "`write(|w| ..)` method takes [`enr::W`](W) writer structure"] impl crate :: Writable for EnrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ENR to value 0"] impl crate :: Resettable for EnrSpec { } }
#[doc = "SR (r) register accessor: Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status Register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `ACTIV` reader - I2C activity status"] pub type ActivR = crate :: BitReader ;
#[doc = "Field `TFNF` reader - Transmit FIFO not full"] pub type TfnfR = crate :: BitReader ;
#[doc = "Field `TFE` reader - Transmit FIFO completely empty"] pub type TfeR = crate :: BitReader ;
#[doc = "Field `RFNE` reader - Receive FIFO not empty"] pub type RfneR = crate :: BitReader ;
#[doc = "Field `RFF` reader - Receive FIFO completely full"] pub type RffR = crate :: BitReader ;
#[doc = "Field `MST_ACTIV` reader - Master FSM activity status"] pub type MstActivR = crate :: BitReader ;
#[doc = "Field `SLV_ACTIV` reader - Slave FSM activity status"] pub type SlvActivR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - I2C activity status"]
#[inline (always)] pub fn activ (& self) -> ActivR { ActivR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transmit FIFO not full"]
#[inline (always)] pub fn tfnf (& self) -> TfnfR { TfnfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Transmit FIFO completely empty"]
#[inline (always)] pub fn tfe (& self) -> TfeR { TfeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Receive FIFO not empty"]
#[inline (always)] pub fn rfne (& self) -> RfneR { RfneR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Receive FIFO completely full"]
#[inline (always)] pub fn rff (& self) -> RffR { RffR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Master FSM activity status"]
#[inline (always)] pub fn mst_activ (& self) -> MstActivR { MstActivR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Slave FSM activity status"]
#[inline (always)] pub fn slv_activ (& self) -> SlvActivR { SlvActivR :: new (((self . bits >> 6) & 1) != 0) } }
#[doc = "Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0x06"] impl crate :: Resettable for SrSpec { const RESET_VALUE : u32 = 0x06 ; } }
#[doc = "TXFLR (r) register accessor: Transmit FIFO Level Register\n\nYou can [`read`](crate::Reg::read) this register and get [`txflr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txflr`] module"]
#[doc (alias = "TXFLR")] pub type Txflr = crate :: Reg < txflr :: TxflrSpec > ;
#[doc = "Transmit FIFO Level Register"] pub mod txflr {
#[doc = "Register `TXFLR` reader"] pub type R = crate :: R < TxflrSpec > ;
#[doc = "Field `CNT` reader - Transmit FIFO level.Contains the number of valid data entires in the transmit FIFO"] pub type CntR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:1 - Transmit FIFO level.Contains the number of valid data entires in the transmit FIFO"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 3) as u8) } }
#[doc = "Transmit FIFO Level Register\n\nYou can [`read`](crate::Reg::read) this register and get [`txflr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TxflrSpec ; impl crate :: RegisterSpec for TxflrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`txflr::R`](R) reader structure"] impl crate :: Readable for TxflrSpec { }
#[doc = "`reset()` method sets TXFLR to value 0"] impl crate :: Resettable for TxflrSpec { } }
#[doc = "RXFLR (r) register accessor: Receive FIFO Level Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxflr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxflr`] module"]
#[doc (alias = "RXFLR")] pub type Rxflr = crate :: Reg < rxflr :: RxflrSpec > ;
#[doc = "Receive FIFO Level Register"] pub mod rxflr {
#[doc = "Register `RXFLR` reader"] pub type R = crate :: R < RxflrSpec > ;
#[doc = "Field `CNT` reader - Receive FIFO level. Contains the number of valid data entires in the receive FIFO"] pub type CntR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:1 - Receive FIFO level. Contains the number of valid data entires in the receive FIFO"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 3) as u8) } }
#[doc = "Receive FIFO Level Register\n\nYou can [`read`](crate::Reg::read) this register and get [`rxflr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxflrSpec ; impl crate :: RegisterSpec for RxflrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rxflr::R`](R) reader structure"] impl crate :: Readable for RxflrSpec { }
#[doc = "`reset()` method sets RXFLR to value 0"] impl crate :: Resettable for RxflrSpec { } }
#[doc = "HOLD (r) register accessor: SDA Hold Time Register\n\nYou can [`read`](crate::Reg::read) this register and get [`hold::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hold`] module"]
#[doc (alias = "HOLD")] pub type Hold = crate :: Reg < hold :: HoldSpec > ;
#[doc = "SDA Hold Time Register"] pub mod hold {
#[doc = "Register `HOLD` reader"] pub type R = crate :: R < HoldSpec > ;
#[doc = "Field `TX_HOLD` reader - Sets the required SDA hold time in units of ic_clk period"] pub type TxHoldR = crate :: FieldReader < u16 > ;
#[doc = "Field `RX_HOLD` reader - Sets the required SDA hold time in units of ic_clk period"] pub type RxHoldR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:15 - Sets the required SDA hold time in units of ic_clk period"]
#[inline (always)] pub fn tx_hold (& self) -> TxHoldR { TxHoldR :: new ((self . bits & 0xffff) as u16) }
#[doc = "Bits 16:23 - Sets the required SDA hold time in units of ic_clk period"]
#[inline (always)] pub fn rx_hold (& self) -> RxHoldR { RxHoldR :: new (((self . bits >> 16) & 0xff) as u8) } }
#[doc = "SDA Hold Time Register\n\nYou can [`read`](crate::Reg::read) this register and get [`hold::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HoldSpec ; impl crate :: RegisterSpec for HoldSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`hold::R`](R) reader structure"] impl crate :: Readable for HoldSpec { }
#[doc = "`reset()` method sets HOLD to value 0x01"] impl crate :: Resettable for HoldSpec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "DMA (rw) register accessor: DMA Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma`] module"]
#[doc (alias = "DMA")] pub type Dma = crate :: Reg < dma :: DmaSpec > ;
#[doc = "DMA Control Register"] pub mod dma {
#[doc = "Register `DMA` reader"] pub type R = crate :: R < DmaSpec > ;
#[doc = "Register `DMA` writer"] pub type W = crate :: W < DmaSpec > ;
#[doc = "Field `RXEN` reader - Receive DMA enable"] pub type RxenR = crate :: BitReader ;
#[doc = "Field `RXEN` writer - Receive DMA enable"] pub type RxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEN` reader - Transmit DMA enable"] pub type TxenR = crate :: BitReader ;
#[doc = "Field `TXEN` writer - Transmit DMA enable"] pub type TxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Receive DMA enable"]
#[inline (always)] pub fn rxen (& self) -> RxenR { RxenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Transmit DMA enable"]
#[inline (always)] pub fn txen (& self) -> TxenR { TxenR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Receive DMA enable"]
#[inline (always)] pub fn rxen (& mut self) -> RxenW < '_ , DmaSpec > { RxenW :: new (self , 0) }
#[doc = "Bit 1 - Transmit DMA enable"]
#[inline (always)] pub fn txen (& mut self) -> TxenW < '_ , DmaSpec > { TxenW :: new (self , 1) } }
#[doc = "DMA Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmaSpec ; impl crate :: RegisterSpec for DmaSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dma::R`](R) reader structure"] impl crate :: Readable for DmaSpec { }
#[doc = "`write(|w| ..)` method takes [`dma::W`](W) writer structure"] impl crate :: Writable for DmaSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA to value 0"] impl crate :: Resettable for DmaSpec { } }
#[doc = "SETUP (rw) register accessor: SDA Setup Time Register\n\nYou can [`read`](crate::Reg::read) this register and get [`setup::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`setup::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@setup`] module"]
#[doc (alias = "SETUP")] pub type Setup = crate :: Reg < setup :: SetupSpec > ;
#[doc = "SDA Setup Time Register"] pub mod setup {
#[doc = "Register `SETUP` reader"] pub type R = crate :: R < SetupSpec > ;
#[doc = "Register `SETUP` writer"] pub type W = crate :: W < SetupSpec > ;
#[doc = "Field `CNT` reader - SDA setup"] pub type CntR = crate :: FieldReader ;
#[doc = "Field `CNT` writer - SDA setup"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - SDA setup"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - SDA setup"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , SetupSpec > { CntW :: new (self , 0) } }
#[doc = "SDA Setup Time Register\n\nYou can [`read`](crate::Reg::read) this register and get [`setup::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`setup::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SetupSpec ; impl crate :: RegisterSpec for SetupSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`setup::R`](R) reader structure"] impl crate :: Readable for SetupSpec { }
#[doc = "`write(|w| ..)` method takes [`setup::W`](W) writer structure"] impl crate :: Writable for SetupSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SETUP to value 0x64"] impl crate :: Resettable for SetupSpec { const RESET_VALUE : u32 = 0x64 ; } }
#[doc = "GCR (rw) register accessor: ACK General Call Register\n\nYou can [`read`](crate::Reg::read) this register and get [`gcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gcr`] module"]
#[doc (alias = "GCR")] pub type Gcr = crate :: Reg < gcr :: GcrSpec > ;
#[doc = "ACK General Call Register"] pub mod gcr {
#[doc = "Register `GCR` reader"] pub type R = crate :: R < GcrSpec > ;
#[doc = "Register `GCR` writer"] pub type W = crate :: W < GcrSpec > ;
#[doc = "Field `GC` reader - ACK general call"] pub type GcR = crate :: BitReader ;
#[doc = "Field `GC` writer - ACK general call"] pub type GcW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - ACK general call"]
#[inline (always)] pub fn gc (& self) -> GcR { GcR :: new ((self . bits & 1) != 0) } } impl W {
#[doc = "Bit 0 - ACK general call"]
#[inline (always)] pub fn gc (& mut self) -> GcW < '_ , GcrSpec > { GcW :: new (self , 0) } }
#[doc = "ACK General Call Register\n\nYou can [`read`](crate::Reg::read) this register and get [`gcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GcrSpec ; impl crate :: RegisterSpec for GcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`gcr::R`](R) reader structure"] impl crate :: Readable for GcrSpec { }
#[doc = "`write(|w| ..)` method takes [`gcr::W`](W) writer structure"] impl crate :: Writable for GcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets GCR to value 0x01"] impl crate :: Resettable for GcrSpec { const RESET_VALUE : u32 = 0x01 ; } } }
#[doc = "Independent watchdog"] pub type Iwdg = crate :: Periph < iwdg :: RegisterBlock , 0x4000_3000 > ; impl core :: fmt :: Debug for Iwdg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Iwdg") . finish () } }
#[doc = "Independent watchdog"] pub mod iwdg {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { kr : Kr , pr : Pr , rlr : Rlr , sr : Sr , cr : Cr , } impl RegisterBlock {
#[doc = "0x00 - Key register"]
#[inline (always)] pub const fn kr (& self) -> & Kr { & self . kr }
#[doc = "0x04 - Prescaler register"]
#[inline (always)] pub const fn pr (& self) -> & Pr { & self . pr }
#[doc = "0x08 - Reload register"]
#[inline (always)] pub const fn rlr (& self) -> & Rlr { & self . rlr }
#[doc = "0x0c - Status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x10 - Control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr } }
#[doc = "KR (w) register accessor: Key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`kr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@kr`] module"]
#[doc (alias = "KR")] pub type Kr = crate :: Reg < kr :: KrSpec > ;
#[doc = "Key register"] pub mod kr {
#[doc = "Register `KR` writer"] pub type W = crate :: W < KrSpec > ;
#[doc = "Field `KEY` writer - Key value"] pub type KeyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - Key value"]
#[inline (always)] pub fn key (& mut self) -> KeyW < '_ , KrSpec > { KeyW :: new (self , 0) } }
#[doc = "Key register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`kr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct KrSpec ; impl crate :: RegisterSpec for KrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`kr::W`](W) writer structure"] impl crate :: Writable for KrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets KR to value 0"] impl crate :: Resettable for KrSpec { } }
#[doc = "PR (rw) register accessor: Prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pr`] module"]
#[doc (alias = "PR")] pub type Pr = crate :: Reg < pr :: PrSpec > ;
#[doc = "Prescaler register"] pub mod pr {
#[doc = "Register `PR` reader"] pub type R = crate :: R < PrSpec > ;
#[doc = "Register `PR` writer"] pub type W = crate :: W < PrSpec > ;
#[doc = "Field `PR` reader - Prescaler divider"] pub type PrR = crate :: FieldReader ;
#[doc = "Field `PR` writer - Prescaler divider"] pub type PrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:2 - Prescaler divider"]
#[inline (always)] pub fn pr (& self) -> PrR { PrR :: new ((self . bits & 7) as u8) } } impl W {
#[doc = "Bits 0:2 - Prescaler divider"]
#[inline (always)] pub fn pr (& mut self) -> PrW < '_ , PrSpec > { PrW :: new (self , 0) } }
#[doc = "Prescaler register\n\nYou can [`read`](crate::Reg::read) this register and get [`pr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PrSpec ; impl crate :: RegisterSpec for PrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`pr::R`](R) reader structure"] impl crate :: Readable for PrSpec { }
#[doc = "`write(|w| ..)` method takes [`pr::W`](W) writer structure"] impl crate :: Writable for PrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PR to value 0"] impl crate :: Resettable for PrSpec { } }
#[doc = "RLR (rw) register accessor: Reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rlr`] module"]
#[doc (alias = "RLR")] pub type Rlr = crate :: Reg < rlr :: RlrSpec > ;
#[doc = "Reload register"] pub mod rlr {
#[doc = "Register `RLR` reader"] pub type R = crate :: R < RlrSpec > ;
#[doc = "Register `RLR` writer"] pub type W = crate :: W < RlrSpec > ;
#[doc = "Field `RL` reader - Watchdog counter reload value"] pub type RlR = crate :: FieldReader < u16 > ;
#[doc = "Field `RL` writer - Watchdog counter reload value"] pub type RlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R {
#[doc = "Bits 0:11 - Watchdog counter reload value"]
#[inline (always)] pub fn rl (& self) -> RlR { RlR :: new ((self . bits & 0x0fff) as u16) } } impl W {
#[doc = "Bits 0:11 - Watchdog counter reload value"]
#[inline (always)] pub fn rl (& mut self) -> RlW < '_ , RlrSpec > { RlW :: new (self , 0) } }
#[doc = "Reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`rlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RlrSpec ; impl crate :: RegisterSpec for RlrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rlr::R`](R) reader structure"] impl crate :: Readable for RlrSpec { }
#[doc = "`write(|w| ..)` method takes [`rlr::W`](W) writer structure"] impl crate :: Writable for RlrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RLR to value 0x0fff"] impl crate :: Resettable for RlrSpec { const RESET_VALUE : u32 = 0x0fff ; } }
#[doc = "SR (r) register accessor: Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `PVU` reader - Watchdog prescaler value update"] pub type PvuR = crate :: BitReader ;
#[doc = "Field `RVU` reader - Watchdog counter reload value update"] pub type RvuR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Watchdog prescaler value update"]
#[inline (always)] pub fn pvu (& self) -> PvuR { PvuR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Watchdog counter reload value update"]
#[inline (always)] pub fn rvu (& self) -> RvuR { RvuR :: new (((self . bits >> 1) & 1) != 0) } }
#[doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "CR (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `IRQ_SEL` reader - Interruput select"] pub type IrqSelR = crate :: BitReader ;
#[doc = "Field `IRQ_SEL` writer - Interruput select"] pub type IrqSelW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IRQ_CLR` reader - Interruput clear"] pub type IrqClrR = crate :: BitReader ;
#[doc = "Field `IRQ_CLR` writer - Interruput clear"] pub type IrqClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Interruput select"]
#[inline (always)] pub fn irq_sel (& self) -> IrqSelR { IrqSelR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Interruput clear"]
#[inline (always)] pub fn irq_clr (& self) -> IrqClrR { IrqClrR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Interruput select"]
#[inline (always)] pub fn irq_sel (& mut self) -> IrqSelW < '_ , CrSpec > { IrqSelW :: new (self , 0) }
#[doc = "Bit 1 - Interruput clear"]
#[inline (always)] pub fn irq_clr (& mut self) -> IrqClrW < '_ , CrSpec > { IrqClrW :: new (self , 1) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } } }
#[doc = "PWM Control"] pub type Pwm = crate :: Periph < pwm :: RegisterBlock , 0x4001_6400 > ; impl core :: fmt :: Debug for Pwm { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pwm") . finish () } }
#[doc = "PWM Control"] pub mod pwm {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { csr : Csr , apmskr : Apmskr , apmdlr : Apmdlr , } impl RegisterBlock {
#[doc = "0x00 - Control PWM output status register"]
#[inline (always)] pub const fn csr (& self) -> & Csr { & self . csr }
#[doc = "0x04 - Auto phase mask register"]
#[inline (always)] pub const fn apmskr (& self) -> & Apmskr { & self . apmskr }
#[doc = "0x08 - Auto phase mask dalay register"]
#[inline (always)] pub const fn apmdlr (& self) -> & Apmdlr { & self . apmdlr } }
#[doc = "CSR (rw) register accessor: Control PWM output status register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
#[doc (alias = "CSR")] pub type Csr = crate :: Reg < csr :: CsrSpec > ;
#[doc = "Control PWM output status register"] pub mod csr {
#[doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ;
#[doc = "Register `CSR` writer"] pub type W = crate :: W < CsrSpec > ;
#[doc = "Field `CCE` reader - Current Compensation Enable"] pub type CceR = crate :: BitReader ;
#[doc = "Field `CCE` writer - Current Compensation Enable"] pub type CceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPE` reader - Current Protection Enable"] pub type CpeR = crate :: BitReader ;
#[doc = "Field `CPE` writer - Current Protection Enable"] pub type CpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `APMTIE` reader - Auto Phase Mask Trigger Interrupt Enable"] pub type ApmtieR = crate :: BitReader ;
#[doc = "Field `APMTIE` writer - Auto Phase Mask Trigger Interrupt Enable"] pub type ApmtieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TERRIE` reader - Trigger Error Interrupt Enable"] pub type TerrieR = crate :: BitReader ;
#[doc = "Field `TERRIE` writer - Trigger Error Interrupt Enable"] pub type TerrieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC_TRGSEL` reader - Current Protection Trigger Selection"] pub type CcTrgselR = crate :: FieldReader ;
#[doc = "Field `CC_TRGSEL` writer - Current Protection Trigger Selection"] pub type CcTrgselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CC_STRG` reader - Current Compensation Software Trigger"] pub type CcStrgR = crate :: BitReader ;
#[doc = "Field `CC_STRG` writer - Current Compensation Software Trigger"] pub type CcStrgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CP_MDSEL` reader - Current Protection Mode Selection"] pub type CpMdselR = crate :: BitReader ;
#[doc = "Field `CP_MDSEL` writer - Current Protection Mode Selection"] pub type CpMdselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `APMTIF` reader - Auto Phase Mask Trigger Flag"] pub type ApmtifR = crate :: BitReader ;
#[doc = "Field `APMTIF` writer - Auto Phase Mask Trigger Flag"] pub type ApmtifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TERRIF` reader - Trigger Error Flag"] pub type TerrifR = crate :: BitReader ;
#[doc = "Field `TERRIF` writer - Trigger Error Flag"] pub type TerrifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IOFLT` reader - GPIO Input Filter"] pub type IofltR = crate :: FieldReader ;
#[doc = "Field `IOFLT` writer - GPIO Input Filter"] pub type IofltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `HALL_TRGSEL` reader - Hall Sensor Trigger 3-channel select"] pub type HallTrgselR = crate :: FieldReader ;
#[doc = "Field `HALL_TRGSEL` writer - Hall Sensor Trigger 3-channel select"] pub type HallTrgselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CUREN` reader - Enable Current Input Status Value"] pub type CurenR = crate :: BitReader ;
#[doc = "Field `CUREN` writer - Enable Current Input Status Value"] pub type CurenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MSKDAT` reader - Immediate Output of The Port when PWM is Masked"] pub type MskdatR = crate :: FieldReader ;
#[doc = "Field `MSKDAT` writer - Immediate Output of The Port when PWM is Masked"] pub type MskdatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `MSKEN_CURR` reader - PWM Output Mask Immediately Enable"] pub type MskenCurrR = crate :: FieldReader ;
#[doc = "Field `MSKEN_CURR` writer - PWM Output Mask Immediately Enable"] pub type MskenCurrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ; impl R {
#[doc = "Bit 0 - Current Compensation Enable"]
#[inline (always)] pub fn cce (& self) -> CceR { CceR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Current Protection Enable"]
#[inline (always)] pub fn cpe (& self) -> CpeR { CpeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Auto Phase Mask Trigger Interrupt Enable"]
#[inline (always)] pub fn apmtie (& self) -> ApmtieR { ApmtieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Trigger Error Interrupt Enable"]
#[inline (always)] pub fn terrie (& self) -> TerrieR { TerrieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - Current Protection Trigger Selection"]
#[inline (always)] pub fn cc_trgsel (& self) -> CcTrgselR { CcTrgselR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Current Compensation Software Trigger"]
#[inline (always)] pub fn cc_strg (& self) -> CcStrgR { CcStrgR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 10 - Current Protection Mode Selection"]
#[inline (always)] pub fn cp_mdsel (& self) -> CpMdselR { CpMdselR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Auto Phase Mask Trigger Flag"]
#[inline (always)] pub fn apmtif (& self) -> ApmtifR { ApmtifR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Trigger Error Flag"]
#[inline (always)] pub fn terrif (& self) -> TerrifR { TerrifR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bits 13:15 - GPIO Input Filter"]
#[inline (always)] pub fn ioflt (& self) -> IofltR { IofltR :: new (((self . bits >> 13) & 7) as u8) }
#[doc = "Bits 16:17 - Hall Sensor Trigger 3-channel select"]
#[inline (always)] pub fn hall_trgsel (& self) -> HallTrgselR { HallTrgselR :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bit 18 - Enable Current Input Status Value"]
#[inline (always)] pub fn curen (& self) -> CurenR { CurenR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bits 19:24 - Immediate Output of The Port when PWM is Masked"]
#[inline (always)] pub fn mskdat (& self) -> MskdatR { MskdatR :: new (((self . bits >> 19) & 0x3f) as u8) }
#[doc = "Bits 25:30 - PWM Output Mask Immediately Enable"]
#[inline (always)] pub fn msken_curr (& self) -> MskenCurrR { MskenCurrR :: new (((self . bits >> 25) & 0x3f) as u8) } } impl W {
#[doc = "Bit 0 - Current Compensation Enable"]
#[inline (always)] pub fn cce (& mut self) -> CceW < '_ , CsrSpec > { CceW :: new (self , 0) }
#[doc = "Bit 1 - Current Protection Enable"]
#[inline (always)] pub fn cpe (& mut self) -> CpeW < '_ , CsrSpec > { CpeW :: new (self , 1) }
#[doc = "Bit 2 - Auto Phase Mask Trigger Interrupt Enable"]
#[inline (always)] pub fn apmtie (& mut self) -> ApmtieW < '_ , CsrSpec > { ApmtieW :: new (self , 2) }
#[doc = "Bit 3 - Trigger Error Interrupt Enable"]
#[inline (always)] pub fn terrie (& mut self) -> TerrieW < '_ , CsrSpec > { TerrieW :: new (self , 3) }
#[doc = "Bits 4:5 - Current Protection Trigger Selection"]
#[inline (always)] pub fn cc_trgsel (& mut self) -> CcTrgselW < '_ , CsrSpec > { CcTrgselW :: new (self , 4) }
#[doc = "Bit 6 - Current Compensation Software Trigger"]
#[inline (always)] pub fn cc_strg (& mut self) -> CcStrgW < '_ , CsrSpec > { CcStrgW :: new (self , 6) }
#[doc = "Bit 10 - Current Protection Mode Selection"]
#[inline (always)] pub fn cp_mdsel (& mut self) -> CpMdselW < '_ , CsrSpec > { CpMdselW :: new (self , 10) }
#[doc = "Bit 11 - Auto Phase Mask Trigger Flag"]
#[inline (always)] pub fn apmtif (& mut self) -> ApmtifW < '_ , CsrSpec > { ApmtifW :: new (self , 11) }
#[doc = "Bit 12 - Trigger Error Flag"]
#[inline (always)] pub fn terrif (& mut self) -> TerrifW < '_ , CsrSpec > { TerrifW :: new (self , 12) }
#[doc = "Bits 13:15 - GPIO Input Filter"]
#[inline (always)] pub fn ioflt (& mut self) -> IofltW < '_ , CsrSpec > { IofltW :: new (self , 13) }
#[doc = "Bits 16:17 - Hall Sensor Trigger 3-channel select"]
#[inline (always)] pub fn hall_trgsel (& mut self) -> HallTrgselW < '_ , CsrSpec > { HallTrgselW :: new (self , 16) }
#[doc = "Bit 18 - Enable Current Input Status Value"]
#[inline (always)] pub fn curen (& mut self) -> CurenW < '_ , CsrSpec > { CurenW :: new (self , 18) }
#[doc = "Bits 19:24 - Immediate Output of The Port when PWM is Masked"]
#[inline (always)] pub fn mskdat (& mut self) -> MskdatW < '_ , CsrSpec > { MskdatW :: new (self , 19) }
#[doc = "Bits 25:30 - PWM Output Mask Immediately Enable"]
#[inline (always)] pub fn msken_curr (& mut self) -> MskenCurrW < '_ , CsrSpec > { MskenCurrW :: new (self , 25) } }
#[doc = "Control PWM output status register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`csr::W`](W) writer structure"] impl crate :: Writable for CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CSR to value 0"] impl crate :: Resettable for CsrSpec { } }
#[doc = "APMSKR (rw) register accessor: Auto phase mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`apmskr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apmskr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apmskr`] module"]
#[doc (alias = "APMSKR")] pub type Apmskr = crate :: Reg < apmskr :: ApmskrSpec > ;
#[doc = "Auto phase mask register"] pub mod apmskr {
#[doc = "Register `APMSKR` reader"] pub type R = crate :: R < ApmskrSpec > ;
#[doc = "Register `APMSKR` writer"] pub type W = crate :: W < ApmskrSpec > ;
#[doc = "Field `MSKDAT` reader - PWM Mask Data"] pub type MskdatR = crate :: FieldReader ;
#[doc = "Field `MSKDAT` writer - PWM Mask Data"] pub type MskdatW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `MSKEN` reader - PWM Mask Function Enable"] pub type MskenR = crate :: FieldReader ;
#[doc = "Field `MSKEN` writer - PWM Mask Function Enable"] pub type MskenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `APM_TRIGSEL` reader - Auto Phase Mask Tigger Selection"] pub type ApmTrigselR = crate :: FieldReader ;
#[doc = "Field `APM_TRIGSEL` writer - Auto Phase Mask Tigger Selection"] pub type ApmTrigselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `APM_STRG` reader - Auto Phase Mask Software Trigger"] pub type ApmStrgR = crate :: BitReader ;
#[doc = "Field `APM_STRG` writer - Auto Phase Mask Software Trigger"] pub type ApmStrgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENTRGI` reader - Expect Next Trigger Input"] pub type EntrgiR = crate :: FieldReader ;
#[doc = "Field `ENTRGI` writer - Expect Next Trigger Input"] pub type EntrgiW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `CTRGI` reader - Current Trigger Input"] pub type CtrgiR = crate :: FieldReader ;
#[doc = "Field `CTRGI` writer - Current Trigger Input"] pub type CtrgiW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:5 - PWM Mask Data"]
#[inline (always)] pub fn mskdat (& self) -> MskdatR { MskdatR :: new ((self . bits & 0x3f) as u8) }
#[doc = "Bits 8:13 - PWM Mask Function Enable"]
#[inline (always)] pub fn msken (& self) -> MskenR { MskenR :: new (((self . bits >> 8) & 0x3f) as u8) }
#[doc = "Bits 16:17 - Auto Phase Mask Tigger Selection"]
#[inline (always)] pub fn apm_trigsel (& self) -> ApmTrigselR { ApmTrigselR :: new (((self . bits >> 16) & 3) as u8) }
#[doc = "Bit 18 - Auto Phase Mask Software Trigger"]
#[inline (always)] pub fn apm_strg (& self) -> ApmStrgR { ApmStrgR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bits 20:22 - Expect Next Trigger Input"]
#[inline (always)] pub fn entrgi (& self) -> EntrgiR { EntrgiR :: new (((self . bits >> 20) & 7) as u8) }
#[doc = "Bits 23:25 - Current Trigger Input"]
#[inline (always)] pub fn ctrgi (& self) -> CtrgiR { CtrgiR :: new (((self . bits >> 23) & 7) as u8) } } impl W {
#[doc = "Bits 0:5 - PWM Mask Data"]
#[inline (always)] pub fn mskdat (& mut self) -> MskdatW < '_ , ApmskrSpec > { MskdatW :: new (self , 0) }
#[doc = "Bits 8:13 - PWM Mask Function Enable"]
#[inline (always)] pub fn msken (& mut self) -> MskenW < '_ , ApmskrSpec > { MskenW :: new (self , 8) }
#[doc = "Bits 16:17 - Auto Phase Mask Tigger Selection"]
#[inline (always)] pub fn apm_trigsel (& mut self) -> ApmTrigselW < '_ , ApmskrSpec > { ApmTrigselW :: new (self , 16) }
#[doc = "Bit 18 - Auto Phase Mask Software Trigger"]
#[inline (always)] pub fn apm_strg (& mut self) -> ApmStrgW < '_ , ApmskrSpec > { ApmStrgW :: new (self , 18) }
#[doc = "Bits 20:22 - Expect Next Trigger Input"]
#[inline (always)] pub fn entrgi (& mut self) -> EntrgiW < '_ , ApmskrSpec > { EntrgiW :: new (self , 20) }
#[doc = "Bits 23:25 - Current Trigger Input"]
#[inline (always)] pub fn ctrgi (& mut self) -> CtrgiW < '_ , ApmskrSpec > { CtrgiW :: new (self , 23) } }
#[doc = "Auto phase mask register\n\nYou can [`read`](crate::Reg::read) this register and get [`apmskr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apmskr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ApmskrSpec ; impl crate :: RegisterSpec for ApmskrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apmskr::R`](R) reader structure"] impl crate :: Readable for ApmskrSpec { }
#[doc = "`write(|w| ..)` method takes [`apmskr::W`](W) writer structure"] impl crate :: Writable for ApmskrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APMSKR to value 0"] impl crate :: Resettable for ApmskrSpec { } }
#[doc = "APMDLR (rw) register accessor: Auto phase mask dalay register\n\nYou can [`read`](crate::Reg::read) this register and get [`apmdlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apmdlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apmdlr`] module"]
#[doc (alias = "APMDLR")] pub type Apmdlr = crate :: Reg < apmdlr :: ApmdlrSpec > ;
#[doc = "Auto phase mask dalay register"] pub mod apmdlr {
#[doc = "Register `APMDLR` reader"] pub type R = crate :: R < ApmdlrSpec > ;
#[doc = "Register `APMDLR` writer"] pub type W = crate :: W < ApmdlrSpec > ;
#[doc = "Field `APMDLR` reader - *D0"] pub type ApmdlrR = crate :: FieldReader < u32 > ;
#[doc = "Field `APMDLR` writer - *D0"] pub type ApmdlrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 26 , u32 > ; impl R {
#[doc = "Bits 0:25 - *D0"]
#[inline (always)] pub fn apmdlr (& self) -> ApmdlrR { ApmdlrR :: new (self . bits & 0x03ff_ffff) } } impl W {
#[doc = "Bits 0:25 - *D0"]
#[inline (always)] pub fn apmdlr (& mut self) -> ApmdlrW < '_ , ApmdlrSpec > { ApmdlrW :: new (self , 0) } }
#[doc = "Auto phase mask dalay register\n\nYou can [`read`](crate::Reg::read) this register and get [`apmdlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apmdlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ApmdlrSpec ; impl crate :: RegisterSpec for ApmdlrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apmdlr::R`](R) reader structure"] impl crate :: Readable for ApmdlrSpec { }
#[doc = "`write(|w| ..)` method takes [`apmdlr::W`](W) writer structure"] impl crate :: Writable for ApmdlrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APMDLR to value 0x01"] impl crate :: Resettable for ApmdlrSpec { const RESET_VALUE : u32 = 0x01 ; } } }
#[doc = "Power control"] pub type Pwr = crate :: Periph < pwr :: RegisterBlock , 0x4000_7000 > ; impl core :: fmt :: Debug for Pwr { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pwr") . finish () } }
#[doc = "Power control"] pub mod pwr {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , csr : Csr , } impl RegisterBlock {
#[doc = "0x00 - CR"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - CSR"]
#[inline (always)] pub const fn csr (& self) -> & Csr { & self . csr } }
#[doc = "CR (rw) register accessor: CR\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "CR"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `LPDS` reader - Auto Phase Mask delay load register"] pub type LpdsR = crate :: BitReader ;
#[doc = "Field `LPDS` writer - Auto Phase Mask delay load register"] pub type LpdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PDDS` reader - Power down deepsleep"] pub type PddsR = crate :: BitReader ;
#[doc = "Field `PDDS` writer - Power down deepsleep"] pub type PddsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CWUF` reader - Clear wakeup flag"] pub type CwufR = crate :: BitReader ;
#[doc = "Field `CWUF` writer - Clear wakeup flag"] pub type CwufW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSBF` reader - Clear standby flag"] pub type CsbfR = crate :: BitReader ;
#[doc = "Field `CSBF` writer - Clear standby flag"] pub type CsbfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVDE` reader - Power voltage detector enable"] pub type PvdeR = crate :: BitReader ;
#[doc = "Field `PVDE` writer - Power voltage detector enable"] pub type PvdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PLS` reader - PVD level selection"] pub type PlsR = crate :: FieldReader ;
#[doc = "Field `PLS` writer - PVD level selection"] pub type PlsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bit 0 - Auto Phase Mask delay load register"]
#[inline (always)] pub fn lpds (& self) -> LpdsR { LpdsR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Power down deepsleep"]
#[inline (always)] pub fn pdds (& self) -> PddsR { PddsR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Clear wakeup flag"]
#[inline (always)] pub fn cwuf (& self) -> CwufR { CwufR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Clear standby flag"]
#[inline (always)] pub fn csbf (& self) -> CsbfR { CsbfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Power voltage detector enable"]
#[inline (always)] pub fn pvde (& self) -> PvdeR { PvdeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 9:12 - PVD level selection"]
#[inline (always)] pub fn pls (& self) -> PlsR { PlsR :: new (((self . bits >> 9) & 0x0f) as u8) } } impl W {
#[doc = "Bit 0 - Auto Phase Mask delay load register"]
#[inline (always)] pub fn lpds (& mut self) -> LpdsW < '_ , CrSpec > { LpdsW :: new (self , 0) }
#[doc = "Bit 1 - Power down deepsleep"]
#[inline (always)] pub fn pdds (& mut self) -> PddsW < '_ , CrSpec > { PddsW :: new (self , 1) }
#[doc = "Bit 2 - Clear wakeup flag"]
#[inline (always)] pub fn cwuf (& mut self) -> CwufW < '_ , CrSpec > { CwufW :: new (self , 2) }
#[doc = "Bit 3 - Clear standby flag"]
#[inline (always)] pub fn csbf (& mut self) -> CsbfW < '_ , CrSpec > { CsbfW :: new (self , 3) }
#[doc = "Bit 4 - Power voltage detector enable"]
#[inline (always)] pub fn pvde (& mut self) -> PvdeW < '_ , CrSpec > { PvdeW :: new (self , 4) }
#[doc = "Bits 9:12 - PVD level selection"]
#[inline (always)] pub fn pls (& mut self) -> PlsW < '_ , CrSpec > { PlsW :: new (self , 9) } }
#[doc = "CR\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0"] impl crate :: Resettable for CrSpec { } }
#[doc = "CSR (rw) register accessor: CSR\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
#[doc (alias = "CSR")] pub type Csr = crate :: Reg < csr :: CsrSpec > ;
#[doc = "CSR"] pub mod csr {
#[doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ;
#[doc = "Register `CSR` writer"] pub type W = crate :: W < CsrSpec > ;
#[doc = "Field `WUF` reader - Wakeup flag"] pub type WufR = crate :: BitReader ;
#[doc = "Field `WUF` writer - Wakeup flag"] pub type WufW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SBF` reader - Standby flag"] pub type SbfR = crate :: BitReader ;
#[doc = "Field `SBF` writer - Standby flag"] pub type SbfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PVDO` reader - PVD output"] pub type PvdoR = crate :: BitReader ;
#[doc = "Field `PVDO` writer - PVD output"] pub type PvdoW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EWUP` reader - Enable WKUP pin"] pub type EwupR = crate :: BitReader ;
#[doc = "Field `EWUP` writer - Enable WKUP pin"] pub type EwupW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Wakeup flag"]
#[inline (always)] pub fn wuf (& self) -> WufR { WufR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Standby flag"]
#[inline (always)] pub fn sbf (& self) -> SbfR { SbfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - PVD output"]
#[inline (always)] pub fn pvdo (& self) -> PvdoR { PvdoR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 8 - Enable WKUP pin"]
#[inline (always)] pub fn ewup (& self) -> EwupR { EwupR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Wakeup flag"]
#[inline (always)] pub fn wuf (& mut self) -> WufW < '_ , CsrSpec > { WufW :: new (self , 0) }
#[doc = "Bit 1 - Standby flag"]
#[inline (always)] pub fn sbf (& mut self) -> SbfW < '_ , CsrSpec > { SbfW :: new (self , 1) }
#[doc = "Bit 2 - PVD output"]
#[inline (always)] pub fn pvdo (& mut self) -> PvdoW < '_ , CsrSpec > { PvdoW :: new (self , 2) }
#[doc = "Bit 8 - Enable WKUP pin"]
#[inline (always)] pub fn ewup (& mut self) -> EwupW < '_ , CsrSpec > { EwupW :: new (self , 8) } }
#[doc = "CSR\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`csr::W`](W) writer structure"] impl crate :: Writable for CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CSR to value 0"] impl crate :: Resettable for CsrSpec { } } }
#[doc = "Reset and clock control"] pub type Rcc = crate :: Periph < rcc :: RegisterBlock , 0x4002_1000 > ; impl core :: fmt :: Debug for Rcc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rcc") . finish () } }
#[doc = "Reset and clock control"] pub mod rcc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , cfgr : Cfgr , cir : Cir , apb2rstr : Apb2rstr , apb1rstr : Apb1rstr , ahbenr : Ahbenr , apb2enr : Apb2enr , apb1enr : Apb1enr , _reserved8 : [u8 ; 0x04] , csr : Csr , ahbrstr : Ahbrstr , _reserved10 : [u8 ; 0x14] , config : Config , } impl RegisterBlock {
#[doc = "0x00 - Control Register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - Configuration Register"]
#[inline (always)] pub const fn cfgr (& self) -> & Cfgr { & self . cfgr }
#[doc = "0x08 - Clock Interrupt Register"]
#[inline (always)] pub const fn cir (& self) -> & Cir { & self . cir }
#[doc = "0x0c - Advanced Peripheral Bus 2 Reset Register"]
#[inline (always)] pub const fn apb2rstr (& self) -> & Apb2rstr { & self . apb2rstr }
#[doc = "0x10 - Advanced Peripheral Bus 1 Reset Register"]
#[inline (always)] pub const fn apb1rstr (& self) -> & Apb1rstr { & self . apb1rstr }
#[doc = "0x14 - Advanced High Performance Bus Enable Register"]
#[inline (always)] pub const fn ahbenr (& self) -> & Ahbenr { & self . ahbenr }
#[doc = "0x18 - Advanced Peripheral Bus 2 Enable Register"]
#[inline (always)] pub const fn apb2enr (& self) -> & Apb2enr { & self . apb2enr }
#[doc = "0x1c - Advanced Peripheral Bus 1 Enable Register"]
#[inline (always)] pub const fn apb1enr (& self) -> & Apb1enr { & self . apb1enr }
#[doc = "0x24 - Control Status Register"]
#[inline (always)] pub const fn csr (& self) -> & Csr { & self . csr }
#[doc = "0x28 - Advanced High Performance Bus Reset Register"]
#[inline (always)] pub const fn ahbrstr (& self) -> & Ahbrstr { & self . ahbrstr }
#[doc = "0x40 - System Configuration Register"]
#[inline (always)] pub const fn config (& self) -> & Config { & self . config } }
#[doc = "CR (rw) register accessor: Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control Register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `HSION` reader - Internal high-speed clock enable"] pub type HsionR = crate :: BitReader ;
#[doc = "Field `HSION` writer - Internal high-speed clock enable"] pub type HsionW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDY` reader - Internal high-speed clock ready flag"] pub type HsirdyR = crate :: BitReader ;
#[doc = "Field `HSIRDY` writer - Internal high-speed clock ready flag"] pub type HsirdyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSITEN` reader - Internal high-speed clock temperature enable"] pub type HsitenR = crate :: BitReader ;
#[doc = "Field `HSITEN` writer - Internal high-speed clock temperature enable"] pub type HsitenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSICAL` reader - Internal high-speed clock calibration"] pub type HsicalR = crate :: FieldReader ;
#[doc = "Field `HSICAL` writer - Internal high-speed clock calibration"] pub type HsicalW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `HSEON` reader - External high-speed clock enable"] pub type HseonR = crate :: BitReader ;
#[doc = "Field `HSEON` writer - External high-speed clock enable"] pub type HseonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDY` reader - External high-speed clock ready flag"] pub type HserdyR = crate :: BitReader ;
#[doc = "Field `HSERDY` writer - External high-speed clock ready flag"] pub type HserdyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSEBYP` reader - External high-speed clock bypass"] pub type HsebypR = crate :: BitReader ;
#[doc = "Field `HSEBYP` writer - External high-speed clock bypass"] pub type HsebypW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCSON` reader - Clock security system enable"] pub type CcsonR = crate :: BitReader ;
#[doc = "Field `CCSON` writer - Clock security system enable"] pub type CcsonW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSI_72M` reader - HSI output 72M"] pub type Hsi72mR = crate :: BitReader ;
#[doc = "Field `HSI_72M` writer - HSI output 72M"] pub type Hsi72mW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STDBY_FS_WK` reader - Quickly wake-up standby mode selection"] pub type StdbyFsWkR = crate :: BitReader ;
#[doc = "Field `STDBY_FS_WK` writer - Quickly wake-up standby mode selection"] pub type StdbyFsWkW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Internal high-speed clock enable"]
#[inline (always)] pub fn hsion (& self) -> HsionR { HsionR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Internal high-speed clock ready flag"]
#[inline (always)] pub fn hsirdy (& self) -> HsirdyR { HsirdyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Internal high-speed clock temperature enable"]
#[inline (always)] pub fn hsiten (& self) -> HsitenR { HsitenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 8:13 - Internal high-speed clock calibration"]
#[inline (always)] pub fn hsical (& self) -> HsicalR { HsicalR :: new (((self . bits >> 8) & 0x3f) as u8) }
#[doc = "Bit 16 - External high-speed clock enable"]
#[inline (always)] pub fn hseon (& self) -> HseonR { HseonR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - External high-speed clock ready flag"]
#[inline (always)] pub fn hserdy (& self) -> HserdyR { HserdyR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - External high-speed clock bypass"]
#[inline (always)] pub fn hsebyp (& self) -> HsebypR { HsebypR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - Clock security system enable"]
#[inline (always)] pub fn ccson (& self) -> CcsonR { CcsonR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - HSI output 72M"]
#[inline (always)] pub fn hsi_72m (& self) -> Hsi72mR { Hsi72mR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 21 - Quickly wake-up standby mode selection"]
#[inline (always)] pub fn stdby_fs_wk (& self) -> StdbyFsWkR { StdbyFsWkR :: new (((self . bits >> 21) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Internal high-speed clock enable"]
#[inline (always)] pub fn hsion (& mut self) -> HsionW < '_ , CrSpec > { HsionW :: new (self , 0) }
#[doc = "Bit 1 - Internal high-speed clock ready flag"]
#[inline (always)] pub fn hsirdy (& mut self) -> HsirdyW < '_ , CrSpec > { HsirdyW :: new (self , 1) }
#[doc = "Bit 2 - Internal high-speed clock temperature enable"]
#[inline (always)] pub fn hsiten (& mut self) -> HsitenW < '_ , CrSpec > { HsitenW :: new (self , 2) }
#[doc = "Bits 8:13 - Internal high-speed clock calibration"]
#[inline (always)] pub fn hsical (& mut self) -> HsicalW < '_ , CrSpec > { HsicalW :: new (self , 8) }
#[doc = "Bit 16 - External high-speed clock enable"]
#[inline (always)] pub fn hseon (& mut self) -> HseonW < '_ , CrSpec > { HseonW :: new (self , 16) }
#[doc = "Bit 17 - External high-speed clock ready flag"]
#[inline (always)] pub fn hserdy (& mut self) -> HserdyW < '_ , CrSpec > { HserdyW :: new (self , 17) }
#[doc = "Bit 18 - External high-speed clock bypass"]
#[inline (always)] pub fn hsebyp (& mut self) -> HsebypW < '_ , CrSpec > { HsebypW :: new (self , 18) }
#[doc = "Bit 19 - Clock security system enable"]
#[inline (always)] pub fn ccson (& mut self) -> CcsonW < '_ , CrSpec > { CcsonW :: new (self , 19) }
#[doc = "Bit 20 - HSI output 72M"]
#[inline (always)] pub fn hsi_72m (& mut self) -> Hsi72mW < '_ , CrSpec > { Hsi72mW :: new (self , 20) }
#[doc = "Bit 21 - Quickly wake-up standby mode selection"]
#[inline (always)] pub fn stdby_fs_wk (& mut self) -> StdbyFsWkW < '_ , CrSpec > { StdbyFsWkW :: new (self , 21) } }
#[doc = "Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x03"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x03 ; } }
#[doc = "CFGR (rw) register accessor: Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
#[doc (alias = "CFGR")] pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ;
#[doc = "Configuration Register"] pub mod cfgr {
#[doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ;
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ;
#[doc = "Field `SW` reader - System clock switch"] pub type SwR = crate :: FieldReader ;
#[doc = "Field `SW` writer - System clock switch"] pub type SwW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SWS` reader - System clock switch status"] pub type SwsR = crate :: FieldReader ;
#[doc = "Field `SWS` writer - System clock switch status"] pub type SwsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `HPRE` reader - AHB Prescaler"] pub type HpreR = crate :: FieldReader ;
#[doc = "Field `HPRE` writer - AHB Prescaler"] pub type HpreW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `PPRE1` reader - APB low-speed prescaler(APB1)"] pub type Ppre1R = crate :: FieldReader ;
#[doc = "Field `PPRE1` writer - APB low-speed prescaler(APB1)"] pub type Ppre1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `PPRE2` reader - APB high-speed prescaler(APB2)"] pub type Ppre2R = crate :: FieldReader ;
#[doc = "Field `PPRE2` writer - APB high-speed prescaler(APB2)"] pub type Ppre2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MCO` reader - Microcontroller clock output"] pub type McoR = crate :: FieldReader ;
#[doc = "Field `MCO` writer - Microcontroller clock output"] pub type McoW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - System clock switch"]
#[inline (always)] pub fn sw (& self) -> SwR { SwR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - System clock switch status"]
#[inline (always)] pub fn sws (& self) -> SwsR { SwsR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - AHB Prescaler"]
#[inline (always)] pub fn hpre (& self) -> HpreR { HpreR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:10 - APB low-speed prescaler(APB1)"]
#[inline (always)] pub fn ppre1 (& self) -> Ppre1R { Ppre1R :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 11:13 - APB high-speed prescaler(APB2)"]
#[inline (always)] pub fn ppre2 (& self) -> Ppre2R { Ppre2R :: new (((self . bits >> 11) & 7) as u8) }
#[doc = "Bits 24:26 - Microcontroller clock output"]
#[inline (always)] pub fn mco (& self) -> McoR { McoR :: new (((self . bits >> 24) & 7) as u8) } } impl W {
#[doc = "Bits 0:1 - System clock switch"]
#[inline (always)] pub fn sw (& mut self) -> SwW < '_ , CfgrSpec > { SwW :: new (self , 0) }
#[doc = "Bits 2:3 - System clock switch status"]
#[inline (always)] pub fn sws (& mut self) -> SwsW < '_ , CfgrSpec > { SwsW :: new (self , 2) }
#[doc = "Bits 4:7 - AHB Prescaler"]
#[inline (always)] pub fn hpre (& mut self) -> HpreW < '_ , CfgrSpec > { HpreW :: new (self , 4) }
#[doc = "Bits 8:10 - APB low-speed prescaler(APB1)"]
#[inline (always)] pub fn ppre1 (& mut self) -> Ppre1W < '_ , CfgrSpec > { Ppre1W :: new (self , 8) }
#[doc = "Bits 11:13 - APB high-speed prescaler(APB2)"]
#[inline (always)] pub fn ppre2 (& mut self) -> Ppre2W < '_ , CfgrSpec > { Ppre2W :: new (self , 11) }
#[doc = "Bits 24:26 - Microcontroller clock output"]
#[inline (always)] pub fn mco (& mut self) -> McoW < '_ , CfgrSpec > { McoW :: new (self , 24) } }
#[doc = "Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0"] impl crate :: Resettable for CfgrSpec { } }
#[doc = "CIR (rw) register accessor: Clock Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cir`] module"]
#[doc (alias = "CIR")] pub type Cir = crate :: Reg < cir :: CirSpec > ;
#[doc = "Clock Interrupt Register"] pub mod cir {
#[doc = "Register `CIR` reader"] pub type R = crate :: R < CirSpec > ;
#[doc = "Register `CIR` writer"] pub type W = crate :: W < CirSpec > ;
#[doc = "Field `LSIRDYF` reader - LSI ready interrupt flag"] pub type LsirdyfR = crate :: BitReader ;
#[doc = "Field `LSIRDYF` writer - LSI ready interrupt flag"] pub type LsirdyfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDYF` reader - HSI ready interrupt flag"] pub type HsirdyfR = crate :: BitReader ;
#[doc = "Field `HSIRDYF` writer - HSI ready interrupt flag"] pub type HsirdyfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDYF` reader - HSE ready interrupt flag"] pub type HserdyfR = crate :: BitReader ;
#[doc = "Field `HSERDYF` writer - HSE ready interrupt flag"] pub type HserdyfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSSF` reader - Clock security system interrupt flag"] pub type CssfR = crate :: BitReader ;
#[doc = "Field `CSSF` writer - Clock security system interrupt flag"] pub type CssfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSIRDYIE` reader - LSI ready interrupt enable"] pub type LsirdyieR = crate :: BitReader ;
#[doc = "Field `LSIRDYIE` writer - LSI ready interrupt enable"] pub type LsirdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDYIE` reader - HSI ready interrupt enable"] pub type HsirdyieR = crate :: BitReader ;
#[doc = "Field `HSIRDYIE` writer - HSI ready interrupt enable"] pub type HsirdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDYIE` reader - HSE ready interrupt enable"] pub type HserdyieR = crate :: BitReader ;
#[doc = "Field `HSERDYIE` writer - HSE ready interrupt enable"] pub type HserdyieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSIRDYC` reader - LSI ready interrupt clear"] pub type LsirdycR = crate :: BitReader ;
#[doc = "Field `LSIRDYC` writer - LSI ready interrupt clear"] pub type LsirdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSIRDYC` reader - HSI ready interrupt clear"] pub type HsirdycR = crate :: BitReader ;
#[doc = "Field `HSIRDYC` writer - HSI ready interrupt clear"] pub type HsirdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HSERDYC` reader - HSE ready interrupt clear"] pub type HserdycR = crate :: BitReader ;
#[doc = "Field `HSERDYC` writer - HSE ready interrupt clear"] pub type HserdycW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CSSC` reader - Clock security system interrupt clear"] pub type CsscR = crate :: BitReader ;
#[doc = "Field `CSSC` writer - Clock security system interrupt clear"] pub type CsscW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - LSI ready interrupt flag"]
#[inline (always)] pub fn lsirdyf (& self) -> LsirdyfR { LsirdyfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - HSI ready interrupt flag"]
#[inline (always)] pub fn hsirdyf (& self) -> HsirdyfR { HsirdyfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - HSE ready interrupt flag"]
#[inline (always)] pub fn hserdyf (& self) -> HserdyfR { HserdyfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 7 - Clock security system interrupt flag"]
#[inline (always)] pub fn cssf (& self) -> CssfR { CssfR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - LSI ready interrupt enable"]
#[inline (always)] pub fn lsirdyie (& self) -> LsirdyieR { LsirdyieR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 10 - HSI ready interrupt enable"]
#[inline (always)] pub fn hsirdyie (& self) -> HsirdyieR { HsirdyieR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - HSE ready interrupt enable"]
#[inline (always)] pub fn hserdyie (& self) -> HserdyieR { HserdyieR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 16 - LSI ready interrupt clear"]
#[inline (always)] pub fn lsirdyc (& self) -> LsirdycR { LsirdycR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 18 - HSI ready interrupt clear"]
#[inline (always)] pub fn hsirdyc (& self) -> HsirdycR { HsirdycR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - HSE ready interrupt clear"]
#[inline (always)] pub fn hserdyc (& self) -> HserdycR { HserdycR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 23 - Clock security system interrupt clear"]
#[inline (always)] pub fn cssc (& self) -> CsscR { CsscR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 0 - LSI ready interrupt flag"]
#[inline (always)] pub fn lsirdyf (& mut self) -> LsirdyfW < '_ , CirSpec > { LsirdyfW :: new (self , 0) }
#[doc = "Bit 2 - HSI ready interrupt flag"]
#[inline (always)] pub fn hsirdyf (& mut self) -> HsirdyfW < '_ , CirSpec > { HsirdyfW :: new (self , 2) }
#[doc = "Bit 3 - HSE ready interrupt flag"]
#[inline (always)] pub fn hserdyf (& mut self) -> HserdyfW < '_ , CirSpec > { HserdyfW :: new (self , 3) }
#[doc = "Bit 7 - Clock security system interrupt flag"]
#[inline (always)] pub fn cssf (& mut self) -> CssfW < '_ , CirSpec > { CssfW :: new (self , 7) }
#[doc = "Bit 8 - LSI ready interrupt enable"]
#[inline (always)] pub fn lsirdyie (& mut self) -> LsirdyieW < '_ , CirSpec > { LsirdyieW :: new (self , 8) }
#[doc = "Bit 10 - HSI ready interrupt enable"]
#[inline (always)] pub fn hsirdyie (& mut self) -> HsirdyieW < '_ , CirSpec > { HsirdyieW :: new (self , 10) }
#[doc = "Bit 11 - HSE ready interrupt enable"]
#[inline (always)] pub fn hserdyie (& mut self) -> HserdyieW < '_ , CirSpec > { HserdyieW :: new (self , 11) }
#[doc = "Bit 16 - LSI ready interrupt clear"]
#[inline (always)] pub fn lsirdyc (& mut self) -> LsirdycW < '_ , CirSpec > { LsirdycW :: new (self , 16) }
#[doc = "Bit 18 - HSI ready interrupt clear"]
#[inline (always)] pub fn hsirdyc (& mut self) -> HsirdycW < '_ , CirSpec > { HsirdycW :: new (self , 18) }
#[doc = "Bit 19 - HSE ready interrupt clear"]
#[inline (always)] pub fn hserdyc (& mut self) -> HserdycW < '_ , CirSpec > { HserdycW :: new (self , 19) }
#[doc = "Bit 23 - Clock security system interrupt clear"]
#[inline (always)] pub fn cssc (& mut self) -> CsscW < '_ , CirSpec > { CsscW :: new (self , 23) } }
#[doc = "Clock Interrupt Register\n\nYou can [`read`](crate::Reg::read) this register and get [`cir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CirSpec ; impl crate :: RegisterSpec for CirSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cir::R`](R) reader structure"] impl crate :: Readable for CirSpec { }
#[doc = "`write(|w| ..)` method takes [`cir::W`](W) writer structure"] impl crate :: Writable for CirSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CIR to value 0"] impl crate :: Resettable for CirSpec { } }
#[doc = "APB2RSTR (rw) register accessor: Advanced Peripheral Bus 2 Reset Register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2rstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2rstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb2rstr`] module"]
#[doc (alias = "APB2RSTR")] pub type Apb2rstr = crate :: Reg < apb2rstr :: Apb2rstrSpec > ;
#[doc = "Advanced Peripheral Bus 2 Reset Register"] pub mod apb2rstr {
#[doc = "Register `APB2RSTR` reader"] pub type R = crate :: R < Apb2rstrSpec > ;
#[doc = "Register `APB2RSTR` writer"] pub type W = crate :: W < Apb2rstrSpec > ;
#[doc = "Field `EXTI` reader - External Interrupt"] pub type ExtiR = crate :: BitReader ;
#[doc = "Field `EXTI` writer - External Interrupt"] pub type ExtiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC1` reader - ADC1 interface reset"] pub type Adc1R = crate :: BitReader ;
#[doc = "Field `ADC1` writer - ADC1 interface reset"] pub type Adc1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM1` reader - TIM1 reset"] pub type Tim1R = crate :: BitReader ;
#[doc = "Field `TIM1` writer - TIM1 reset"] pub type Tim1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI1` reader - SPI1 reset"] pub type Spi1R = crate :: BitReader ;
#[doc = "Field `SPI1` writer - SPI1 reset"] pub type Spi1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART1` reader - UART1 reset"] pub type Uart1R = crate :: BitReader ;
#[doc = "Field `UART1` writer - UART1 reset"] pub type Uart1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP` reader - COMP interface reset"] pub type CompR = crate :: BitReader ;
#[doc = "Field `COMP` writer - COMP interface reset"] pub type CompW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM14` reader - TIM14 reset"] pub type Tim14R = crate :: BitReader ;
#[doc = "Field `TIM14` writer - TIM14 reset"] pub type Tim14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM16` reader - TIM16 reset"] pub type Tim16R = crate :: BitReader ;
#[doc = "Field `TIM16` writer - TIM16 reset"] pub type Tim16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM17` reader - TIM17 reset"] pub type Tim17R = crate :: BitReader ;
#[doc = "Field `TIM17` writer - TIM17 reset"] pub type Tim17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBGMCU` reader - DBGMCU reset"] pub type DbgmcuR = crate :: BitReader ;
#[doc = "Field `DBGMCU` writer - DBGMCU reset"] pub type DbgmcuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM` reader - PWM reset"] pub type PwmR = crate :: BitReader ;
#[doc = "Field `PWM` writer - PWM reset"] pub type PwmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - External Interrupt"]
#[inline (always)] pub fn exti (& self) -> ExtiR { ExtiR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 9 - ADC1 interface reset"]
#[inline (always)] pub fn adc1 (& self) -> Adc1R { Adc1R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 11 - TIM1 reset"]
#[inline (always)] pub fn tim1 (& self) -> Tim1R { Tim1R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - SPI1 reset"]
#[inline (always)] pub fn spi1 (& self) -> Spi1R { Spi1R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - UART1 reset"]
#[inline (always)] pub fn uart1 (& self) -> Uart1R { Uart1R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - COMP interface reset"]
#[inline (always)] pub fn comp (& self) -> CompR { CompR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - TIM14 reset"]
#[inline (always)] pub fn tim14 (& self) -> Tim14R { Tim14R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - TIM16 reset"]
#[inline (always)] pub fn tim16 (& self) -> Tim16R { Tim16R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TIM17 reset"]
#[inline (always)] pub fn tim17 (& self) -> Tim17R { Tim17R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 22 - DBGMCU reset"]
#[inline (always)] pub fn dbgmcu (& self) -> DbgmcuR { DbgmcuR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - PWM reset"]
#[inline (always)] pub fn pwm (& self) -> PwmR { PwmR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 0 - External Interrupt"]
#[inline (always)] pub fn exti (& mut self) -> ExtiW < '_ , Apb2rstrSpec > { ExtiW :: new (self , 0) }
#[doc = "Bit 9 - ADC1 interface reset"]
#[inline (always)] pub fn adc1 (& mut self) -> Adc1W < '_ , Apb2rstrSpec > { Adc1W :: new (self , 9) }
#[doc = "Bit 11 - TIM1 reset"]
#[inline (always)] pub fn tim1 (& mut self) -> Tim1W < '_ , Apb2rstrSpec > { Tim1W :: new (self , 11) }
#[doc = "Bit 12 - SPI1 reset"]
#[inline (always)] pub fn spi1 (& mut self) -> Spi1W < '_ , Apb2rstrSpec > { Spi1W :: new (self , 12) }
#[doc = "Bit 14 - UART1 reset"]
#[inline (always)] pub fn uart1 (& mut self) -> Uart1W < '_ , Apb2rstrSpec > { Uart1W :: new (self , 14) }
#[doc = "Bit 15 - COMP interface reset"]
#[inline (always)] pub fn comp (& mut self) -> CompW < '_ , Apb2rstrSpec > { CompW :: new (self , 15) }
#[doc = "Bit 16 - TIM14 reset"]
#[inline (always)] pub fn tim14 (& mut self) -> Tim14W < '_ , Apb2rstrSpec > { Tim14W :: new (self , 16) }
#[doc = "Bit 17 - TIM16 reset"]
#[inline (always)] pub fn tim16 (& mut self) -> Tim16W < '_ , Apb2rstrSpec > { Tim16W :: new (self , 17) }
#[doc = "Bit 18 - TIM17 reset"]
#[inline (always)] pub fn tim17 (& mut self) -> Tim17W < '_ , Apb2rstrSpec > { Tim17W :: new (self , 18) }
#[doc = "Bit 22 - DBGMCU reset"]
#[inline (always)] pub fn dbgmcu (& mut self) -> DbgmcuW < '_ , Apb2rstrSpec > { DbgmcuW :: new (self , 22) }
#[doc = "Bit 23 - PWM reset"]
#[inline (always)] pub fn pwm (& mut self) -> PwmW < '_ , Apb2rstrSpec > { PwmW :: new (self , 23) } }
#[doc = "Advanced Peripheral Bus 2 Reset Register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2rstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2rstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb2rstrSpec ; impl crate :: RegisterSpec for Apb2rstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb2rstr::R`](R) reader structure"] impl crate :: Readable for Apb2rstrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb2rstr::W`](W) writer structure"] impl crate :: Writable for Apb2rstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB2RSTR to value 0"] impl crate :: Resettable for Apb2rstrSpec { } }
#[doc = "APB1RSTR (rw) register accessor: Advanced Peripheral Bus 1 Reset Register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1rstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1rstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1rstr`] module"]
#[doc (alias = "APB1RSTR")] pub type Apb1rstr = crate :: Reg < apb1rstr :: Apb1rstrSpec > ;
#[doc = "Advanced Peripheral Bus 1 Reset Register"] pub mod apb1rstr {
#[doc = "Register `APB1RSTR` reader"] pub type R = crate :: R < Apb1rstrSpec > ;
#[doc = "Register `APB1RSTR` writer"] pub type W = crate :: W < Apb1rstrSpec > ;
#[doc = "Field `TIM2` reader - TIM2 reset"] pub type Tim2R = crate :: BitReader ;
#[doc = "Field `TIM2` writer - TIM2 reset"] pub type Tim2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM3` reader - TIM3 reset"] pub type Tim3R = crate :: BitReader ;
#[doc = "Field `TIM3` writer - TIM3 reset"] pub type Tim3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WWDG` reader - Window watchdog reset"] pub type WwdgR = crate :: BitReader ;
#[doc = "Field `WWDG` writer - Window watchdog reset"] pub type WwdgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI2` reader - SPI2 reset"] pub type Spi2R = crate :: BitReader ;
#[doc = "Field `SPI2` writer - SPI2 reset"] pub type Spi2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART2` reader - UART2 reset"] pub type Uart2R = crate :: BitReader ;
#[doc = "Field `UART2` writer - UART2 reset"] pub type Uart2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1` reader - I2C1 reset"] pub type I2c1R = crate :: BitReader ;
#[doc = "Field `I2C1` writer - I2C1 reset"] pub type I2c1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR` reader - Power interface reset"] pub type PwrR = crate :: BitReader ;
#[doc = "Field `PWR` writer - Power interface reset"] pub type PwrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - TIM2 reset"]
#[inline (always)] pub fn tim2 (& self) -> Tim2R { Tim2R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - TIM3 reset"]
#[inline (always)] pub fn tim3 (& self) -> Tim3R { Tim3R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 11 - Window watchdog reset"]
#[inline (always)] pub fn wwdg (& self) -> WwdgR { WwdgR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 14 - SPI2 reset"]
#[inline (always)] pub fn spi2 (& self) -> Spi2R { Spi2R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 17 - UART2 reset"]
#[inline (always)] pub fn uart2 (& self) -> Uart2R { Uart2R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 21 - I2C1 reset"]
#[inline (always)] pub fn i2c1 (& self) -> I2c1R { I2c1R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 28 - Power interface reset"]
#[inline (always)] pub fn pwr (& self) -> PwrR { PwrR :: new (((self . bits >> 28) & 1) != 0) } } impl W {
#[doc = "Bit 0 - TIM2 reset"]
#[inline (always)] pub fn tim2 (& mut self) -> Tim2W < '_ , Apb1rstrSpec > { Tim2W :: new (self , 0) }
#[doc = "Bit 1 - TIM3 reset"]
#[inline (always)] pub fn tim3 (& mut self) -> Tim3W < '_ , Apb1rstrSpec > { Tim3W :: new (self , 1) }
#[doc = "Bit 11 - Window watchdog reset"]
#[inline (always)] pub fn wwdg (& mut self) -> WwdgW < '_ , Apb1rstrSpec > { WwdgW :: new (self , 11) }
#[doc = "Bit 14 - SPI2 reset"]
#[inline (always)] pub fn spi2 (& mut self) -> Spi2W < '_ , Apb1rstrSpec > { Spi2W :: new (self , 14) }
#[doc = "Bit 17 - UART2 reset"]
#[inline (always)] pub fn uart2 (& mut self) -> Uart2W < '_ , Apb1rstrSpec > { Uart2W :: new (self , 17) }
#[doc = "Bit 21 - I2C1 reset"]
#[inline (always)] pub fn i2c1 (& mut self) -> I2c1W < '_ , Apb1rstrSpec > { I2c1W :: new (self , 21) }
#[doc = "Bit 28 - Power interface reset"]
#[inline (always)] pub fn pwr (& mut self) -> PwrW < '_ , Apb1rstrSpec > { PwrW :: new (self , 28) } }
#[doc = "Advanced Peripheral Bus 1 Reset Register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1rstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1rstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1rstrSpec ; impl crate :: RegisterSpec for Apb1rstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1rstr::R`](R) reader structure"] impl crate :: Readable for Apb1rstrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb1rstr::W`](W) writer structure"] impl crate :: Writable for Apb1rstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1RSTR to value 0"] impl crate :: Resettable for Apb1rstrSpec { } }
#[doc = "AHBENR (rw) register accessor: Advanced High Performance Bus Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahbenr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahbenr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahbenr`] module"]
#[doc (alias = "AHBENR")] pub type Ahbenr = crate :: Reg < ahbenr :: AhbenrSpec > ;
#[doc = "Advanced High Performance Bus Enable Register"] pub mod ahbenr {
#[doc = "Register `AHBENR` reader"] pub type R = crate :: R < AhbenrSpec > ;
#[doc = "Register `AHBENR` writer"] pub type W = crate :: W < AhbenrSpec > ;
#[doc = "Field `DMA1` reader - DMA1 clock enable"] pub type Dma1R = crate :: BitReader ;
#[doc = "Field `DMA1` writer - DMA1 clock enable"] pub type Dma1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM` reader - SRAM interface clock enable"] pub type SramR = crate :: BitReader ;
#[doc = "Field `SRAM` writer - SRAM interface clock enable"] pub type SramW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FLITF` reader - FLITF clock enable"] pub type FlitfR = crate :: BitReader ;
#[doc = "Field `FLITF` writer - FLITF clock enable"] pub type FlitfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRC` reader - CRC clock enable"] pub type CrcR = crate :: BitReader ;
#[doc = "Field `CRC` writer - CRC clock enable"] pub type CrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOA` reader - I/O port A clock enable"] pub type GpioaR = crate :: BitReader ;
#[doc = "Field `GPIOA` writer - I/O port A clock enable"] pub type GpioaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOB` reader - I/O port B clock enable"] pub type GpiobR = crate :: BitReader ;
#[doc = "Field `GPIOB` writer - I/O port B clock enable"] pub type GpiobW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOC` reader - I/O port C clock enable"] pub type GpiocR = crate :: BitReader ;
#[doc = "Field `GPIOC` writer - I/O port C clock enable"] pub type GpiocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOD` reader - I/O port D clock enable"] pub type GpiodR = crate :: BitReader ;
#[doc = "Field `GPIOD` writer - I/O port D clock enable"] pub type GpiodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HWDIV` reader - HWDIV clock enable"] pub type HwdivR = crate :: BitReader ;
#[doc = "Field `HWDIV` writer - HWDIV clock enable"] pub type HwdivW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DMA1 clock enable"]
#[inline (always)] pub fn dma1 (& self) -> Dma1R { Dma1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - SRAM interface clock enable"]
#[inline (always)] pub fn sram (& self) -> SramR { SramR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - FLITF clock enable"]
#[inline (always)] pub fn flitf (& self) -> FlitfR { FlitfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - CRC clock enable"]
#[inline (always)] pub fn crc (& self) -> CrcR { CrcR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 17 - I/O port A clock enable"]
#[inline (always)] pub fn gpioa (& self) -> GpioaR { GpioaR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - I/O port B clock enable"]
#[inline (always)] pub fn gpiob (& self) -> GpiobR { GpiobR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - I/O port C clock enable"]
#[inline (always)] pub fn gpioc (& self) -> GpiocR { GpiocR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - I/O port D clock enable"]
#[inline (always)] pub fn gpiod (& self) -> GpiodR { GpiodR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 26 - HWDIV clock enable"]
#[inline (always)] pub fn hwdiv (& self) -> HwdivR { HwdivR :: new (((self . bits >> 26) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DMA1 clock enable"]
#[inline (always)] pub fn dma1 (& mut self) -> Dma1W < '_ , AhbenrSpec > { Dma1W :: new (self , 0) }
#[doc = "Bit 2 - SRAM interface clock enable"]
#[inline (always)] pub fn sram (& mut self) -> SramW < '_ , AhbenrSpec > { SramW :: new (self , 2) }
#[doc = "Bit 4 - FLITF clock enable"]
#[inline (always)] pub fn flitf (& mut self) -> FlitfW < '_ , AhbenrSpec > { FlitfW :: new (self , 4) }
#[doc = "Bit 6 - CRC clock enable"]
#[inline (always)] pub fn crc (& mut self) -> CrcW < '_ , AhbenrSpec > { CrcW :: new (self , 6) }
#[doc = "Bit 17 - I/O port A clock enable"]
#[inline (always)] pub fn gpioa (& mut self) -> GpioaW < '_ , AhbenrSpec > { GpioaW :: new (self , 17) }
#[doc = "Bit 18 - I/O port B clock enable"]
#[inline (always)] pub fn gpiob (& mut self) -> GpiobW < '_ , AhbenrSpec > { GpiobW :: new (self , 18) }
#[doc = "Bit 19 - I/O port C clock enable"]
#[inline (always)] pub fn gpioc (& mut self) -> GpiocW < '_ , AhbenrSpec > { GpiocW :: new (self , 19) }
#[doc = "Bit 20 - I/O port D clock enable"]
#[inline (always)] pub fn gpiod (& mut self) -> GpiodW < '_ , AhbenrSpec > { GpiodW :: new (self , 20) }
#[doc = "Bit 26 - HWDIV clock enable"]
#[inline (always)] pub fn hwdiv (& mut self) -> HwdivW < '_ , AhbenrSpec > { HwdivW :: new (self , 26) } }
#[doc = "Advanced High Performance Bus Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahbenr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahbenr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AhbenrSpec ; impl crate :: RegisterSpec for AhbenrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahbenr::R`](R) reader structure"] impl crate :: Readable for AhbenrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahbenr::W`](W) writer structure"] impl crate :: Writable for AhbenrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHBENR to value 0x14"] impl crate :: Resettable for AhbenrSpec { const RESET_VALUE : u32 = 0x14 ; } }
#[doc = "APB2ENR (rw) register accessor: Advanced Peripheral Bus 2 Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb2enr`] module"]
#[doc (alias = "APB2ENR")] pub type Apb2enr = crate :: Reg < apb2enr :: Apb2enrSpec > ;
#[doc = "Advanced Peripheral Bus 2 Enable Register"] pub mod apb2enr {
#[doc = "Register `APB2ENR` reader"] pub type R = crate :: R < Apb2enrSpec > ;
#[doc = "Register `APB2ENR` writer"] pub type W = crate :: W < Apb2enrSpec > ;
#[doc = "Field `EXTI` reader - External Interrupt"] pub type ExtiR = crate :: BitReader ;
#[doc = "Field `EXTI` writer - External Interrupt"] pub type ExtiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADC1` reader - ADC1 interface enable"] pub type Adc1R = crate :: BitReader ;
#[doc = "Field `ADC1` writer - ADC1 interface enable"] pub type Adc1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM1` reader - TIM1 enable"] pub type Tim1R = crate :: BitReader ;
#[doc = "Field `TIM1` writer - TIM1 enable"] pub type Tim1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI1` reader - SPI1 enable"] pub type Spi1R = crate :: BitReader ;
#[doc = "Field `SPI1` writer - SPI1 enable"] pub type Spi1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART1` reader - UART1 enable"] pub type Uart1R = crate :: BitReader ;
#[doc = "Field `UART1` writer - UART1 enable"] pub type Uart1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMP` reader - COMP interface enable"] pub type CompR = crate :: BitReader ;
#[doc = "Field `COMP` writer - COMP interface enable"] pub type CompW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM14` reader - TIM14 enable"] pub type Tim14R = crate :: BitReader ;
#[doc = "Field `TIM14` writer - TIM14 enable"] pub type Tim14W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM16` reader - TIM16 enable"] pub type Tim16R = crate :: BitReader ;
#[doc = "Field `TIM16` writer - TIM16 enable"] pub type Tim16W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM17` reader - TIM17 enable"] pub type Tim17R = crate :: BitReader ;
#[doc = "Field `TIM17` writer - TIM17 enable"] pub type Tim17W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DBGMCU` reader - DBGMCU enable"] pub type DbgmcuR = crate :: BitReader ;
#[doc = "Field `DBGMCU` writer - DBGMCU enable"] pub type DbgmcuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM` reader - *D23"] pub type PwmR = crate :: BitReader ;
#[doc = "Field `PWM` writer - *D23"] pub type PwmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - External Interrupt"]
#[inline (always)] pub fn exti (& self) -> ExtiR { ExtiR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 9 - ADC1 interface enable"]
#[inline (always)] pub fn adc1 (& self) -> Adc1R { Adc1R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 11 - TIM1 enable"]
#[inline (always)] pub fn tim1 (& self) -> Tim1R { Tim1R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - SPI1 enable"]
#[inline (always)] pub fn spi1 (& self) -> Spi1R { Spi1R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - UART1 enable"]
#[inline (always)] pub fn uart1 (& self) -> Uart1R { Uart1R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - COMP interface enable"]
#[inline (always)] pub fn comp (& self) -> CompR { CompR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - TIM14 enable"]
#[inline (always)] pub fn tim14 (& self) -> Tim14R { Tim14R :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - TIM16 enable"]
#[inline (always)] pub fn tim16 (& self) -> Tim16R { Tim16R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - TIM17 enable"]
#[inline (always)] pub fn tim17 (& self) -> Tim17R { Tim17R :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 22 - DBGMCU enable"]
#[inline (always)] pub fn dbgmcu (& self) -> DbgmcuR { DbgmcuR :: new (((self . bits >> 22) & 1) != 0) }
#[doc = "Bit 23 - *D23"]
#[inline (always)] pub fn pwm (& self) -> PwmR { PwmR :: new (((self . bits >> 23) & 1) != 0) } } impl W {
#[doc = "Bit 0 - External Interrupt"]
#[inline (always)] pub fn exti (& mut self) -> ExtiW < '_ , Apb2enrSpec > { ExtiW :: new (self , 0) }
#[doc = "Bit 9 - ADC1 interface enable"]
#[inline (always)] pub fn adc1 (& mut self) -> Adc1W < '_ , Apb2enrSpec > { Adc1W :: new (self , 9) }
#[doc = "Bit 11 - TIM1 enable"]
#[inline (always)] pub fn tim1 (& mut self) -> Tim1W < '_ , Apb2enrSpec > { Tim1W :: new (self , 11) }
#[doc = "Bit 12 - SPI1 enable"]
#[inline (always)] pub fn spi1 (& mut self) -> Spi1W < '_ , Apb2enrSpec > { Spi1W :: new (self , 12) }
#[doc = "Bit 14 - UART1 enable"]
#[inline (always)] pub fn uart1 (& mut self) -> Uart1W < '_ , Apb2enrSpec > { Uart1W :: new (self , 14) }
#[doc = "Bit 15 - COMP interface enable"]
#[inline (always)] pub fn comp (& mut self) -> CompW < '_ , Apb2enrSpec > { CompW :: new (self , 15) }
#[doc = "Bit 16 - TIM14 enable"]
#[inline (always)] pub fn tim14 (& mut self) -> Tim14W < '_ , Apb2enrSpec > { Tim14W :: new (self , 16) }
#[doc = "Bit 17 - TIM16 enable"]
#[inline (always)] pub fn tim16 (& mut self) -> Tim16W < '_ , Apb2enrSpec > { Tim16W :: new (self , 17) }
#[doc = "Bit 18 - TIM17 enable"]
#[inline (always)] pub fn tim17 (& mut self) -> Tim17W < '_ , Apb2enrSpec > { Tim17W :: new (self , 18) }
#[doc = "Bit 22 - DBGMCU enable"]
#[inline (always)] pub fn dbgmcu (& mut self) -> DbgmcuW < '_ , Apb2enrSpec > { DbgmcuW :: new (self , 22) }
#[doc = "Bit 23 - *D23"]
#[inline (always)] pub fn pwm (& mut self) -> PwmW < '_ , Apb2enrSpec > { PwmW :: new (self , 23) } }
#[doc = "Advanced Peripheral Bus 2 Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb2enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb2enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb2enrSpec ; impl crate :: RegisterSpec for Apb2enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb2enr::R`](R) reader structure"] impl crate :: Readable for Apb2enrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb2enr::W`](W) writer structure"] impl crate :: Writable for Apb2enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB2ENR to value 0"] impl crate :: Resettable for Apb2enrSpec { } }
#[doc = "APB1ENR (rw) register accessor: Advanced Peripheral Bus 1 Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1enr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1enr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@apb1enr`] module"]
#[doc (alias = "APB1ENR")] pub type Apb1enr = crate :: Reg < apb1enr :: Apb1enrSpec > ;
#[doc = "Advanced Peripheral Bus 1 Enable Register"] pub mod apb1enr {
#[doc = "Register `APB1ENR` reader"] pub type R = crate :: R < Apb1enrSpec > ;
#[doc = "Register `APB1ENR` writer"] pub type W = crate :: W < Apb1enrSpec > ;
#[doc = "Field `TIM2` reader - TIM2 clock enable"] pub type Tim2R = crate :: BitReader ;
#[doc = "Field `TIM2` writer - TIM2 clock enable"] pub type Tim2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIM3` reader - TIM3 clock enable"] pub type Tim3R = crate :: BitReader ;
#[doc = "Field `TIM3` writer - TIM3 clock enable"] pub type Tim3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WWDG` reader - Window watchdog clock enable"] pub type WwdgR = crate :: BitReader ;
#[doc = "Field `WWDG` writer - Window watchdog clock enable"] pub type WwdgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPI2` reader - SPI2 clock enable"] pub type Spi2R = crate :: BitReader ;
#[doc = "Field `SPI2` writer - SPI2 clock enable"] pub type Spi2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UART2` reader - UART2 clock enable"] pub type Uart2R = crate :: BitReader ;
#[doc = "Field `UART2` writer - UART2 clock enable"] pub type Uart2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `I2C1` reader - I2C1 clock enable"] pub type I2c1R = crate :: BitReader ;
#[doc = "Field `I2C1` writer - I2C1 clock enable"] pub type I2c1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR` reader - Power interface clock enable"] pub type PwrR = crate :: BitReader ;
#[doc = "Field `PWR` writer - Power interface clock enable"] pub type PwrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - TIM2 clock enable"]
#[inline (always)] pub fn tim2 (& self) -> Tim2R { Tim2R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - TIM3 clock enable"]
#[inline (always)] pub fn tim3 (& self) -> Tim3R { Tim3R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 11 - Window watchdog clock enable"]
#[inline (always)] pub fn wwdg (& self) -> WwdgR { WwdgR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 14 - SPI2 clock enable"]
#[inline (always)] pub fn spi2 (& self) -> Spi2R { Spi2R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 17 - UART2 clock enable"]
#[inline (always)] pub fn uart2 (& self) -> Uart2R { Uart2R :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 21 - I2C1 clock enable"]
#[inline (always)] pub fn i2c1 (& self) -> I2c1R { I2c1R :: new (((self . bits >> 21) & 1) != 0) }
#[doc = "Bit 28 - Power interface clock enable"]
#[inline (always)] pub fn pwr (& self) -> PwrR { PwrR :: new (((self . bits >> 28) & 1) != 0) } } impl W {
#[doc = "Bit 0 - TIM2 clock enable"]
#[inline (always)] pub fn tim2 (& mut self) -> Tim2W < '_ , Apb1enrSpec > { Tim2W :: new (self , 0) }
#[doc = "Bit 1 - TIM3 clock enable"]
#[inline (always)] pub fn tim3 (& mut self) -> Tim3W < '_ , Apb1enrSpec > { Tim3W :: new (self , 1) }
#[doc = "Bit 11 - Window watchdog clock enable"]
#[inline (always)] pub fn wwdg (& mut self) -> WwdgW < '_ , Apb1enrSpec > { WwdgW :: new (self , 11) }
#[doc = "Bit 14 - SPI2 clock enable"]
#[inline (always)] pub fn spi2 (& mut self) -> Spi2W < '_ , Apb1enrSpec > { Spi2W :: new (self , 14) }
#[doc = "Bit 17 - UART2 clock enable"]
#[inline (always)] pub fn uart2 (& mut self) -> Uart2W < '_ , Apb1enrSpec > { Uart2W :: new (self , 17) }
#[doc = "Bit 21 - I2C1 clock enable"]
#[inline (always)] pub fn i2c1 (& mut self) -> I2c1W < '_ , Apb1enrSpec > { I2c1W :: new (self , 21) }
#[doc = "Bit 28 - Power interface clock enable"]
#[inline (always)] pub fn pwr (& mut self) -> PwrW < '_ , Apb1enrSpec > { PwrW :: new (self , 28) } }
#[doc = "Advanced Peripheral Bus 1 Enable Register\n\nYou can [`read`](crate::Reg::read) this register and get [`apb1enr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`apb1enr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Apb1enrSpec ; impl crate :: RegisterSpec for Apb1enrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`apb1enr::R`](R) reader structure"] impl crate :: Readable for Apb1enrSpec { }
#[doc = "`write(|w| ..)` method takes [`apb1enr::W`](W) writer structure"] impl crate :: Writable for Apb1enrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets APB1ENR to value 0"] impl crate :: Resettable for Apb1enrSpec { } }
#[doc = "CSR (rw) register accessor: Control Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
#[doc (alias = "CSR")] pub type Csr = crate :: Reg < csr :: CsrSpec > ;
#[doc = "Control Status Register"] pub mod csr {
#[doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ;
#[doc = "Register `CSR` writer"] pub type W = crate :: W < CsrSpec > ;
#[doc = "Field `LSION` reader - Internal low-speed oscillator enable"] pub type LsionR = crate :: BitReader ;
#[doc = "Field `LSION` writer - Internal low-speed oscillator enable"] pub type LsionW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSIRDY` reader - Internal low-speed oscillator ready"] pub type LsirdyR = crate :: BitReader ;
#[doc = "Field `LSIRDY` writer - Internal low-speed oscillator ready"] pub type LsirdyW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RMVF` reader - Remove reset flag"] pub type RmvfR = crate :: BitReader ;
#[doc = "Field `RMVF` writer - Remove reset flag"] pub type RmvfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PINRSTF` reader - PIN reset flag"] pub type PinrstfR = crate :: BitReader ;
#[doc = "Field `PINRSTF` writer - PIN reset flag"] pub type PinrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PORRSTF` reader - POR/PDR reset flag"] pub type PorrstfR = crate :: BitReader ;
#[doc = "Field `PORRSTF` writer - POR/PDR reset flag"] pub type PorrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SFTRSTF` reader - Software reset flag"] pub type SftrstfR = crate :: BitReader ;
#[doc = "Field `SFTRSTF` writer - Software reset flag"] pub type SftrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IWDGRSTF` reader - Independent watchdog reset flag"] pub type IwdgrstfR = crate :: BitReader ;
#[doc = "Field `IWDGRSTF` writer - Independent watchdog reset flag"] pub type IwdgrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WWDGRSTF` reader - Window watchdog reset flag"] pub type WwdgrstfR = crate :: BitReader ;
#[doc = "Field `WWDGRSTF` writer - Window watchdog reset flag"] pub type WwdgrstfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Internal low-speed oscillator enable"]
#[inline (always)] pub fn lsion (& self) -> LsionR { LsionR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Internal low-speed oscillator ready"]
#[inline (always)] pub fn lsirdy (& self) -> LsirdyR { LsirdyR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 24 - Remove reset flag"]
#[inline (always)] pub fn rmvf (& self) -> RmvfR { RmvfR :: new (((self . bits >> 24) & 1) != 0) }
#[doc = "Bit 26 - PIN reset flag"]
#[inline (always)] pub fn pinrstf (& self) -> PinrstfR { PinrstfR :: new (((self . bits >> 26) & 1) != 0) }
#[doc = "Bit 27 - POR/PDR reset flag"]
#[inline (always)] pub fn porrstf (& self) -> PorrstfR { PorrstfR :: new (((self . bits >> 27) & 1) != 0) }
#[doc = "Bit 28 - Software reset flag"]
#[inline (always)] pub fn sftrstf (& self) -> SftrstfR { SftrstfR :: new (((self . bits >> 28) & 1) != 0) }
#[doc = "Bit 29 - Independent watchdog reset flag"]
#[inline (always)] pub fn iwdgrstf (& self) -> IwdgrstfR { IwdgrstfR :: new (((self . bits >> 29) & 1) != 0) }
#[doc = "Bit 30 - Window watchdog reset flag"]
#[inline (always)] pub fn wwdgrstf (& self) -> WwdgrstfR { WwdgrstfR :: new (((self . bits >> 30) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Internal low-speed oscillator enable"]
#[inline (always)] pub fn lsion (& mut self) -> LsionW < '_ , CsrSpec > { LsionW :: new (self , 0) }
#[doc = "Bit 1 - Internal low-speed oscillator ready"]
#[inline (always)] pub fn lsirdy (& mut self) -> LsirdyW < '_ , CsrSpec > { LsirdyW :: new (self , 1) }
#[doc = "Bit 24 - Remove reset flag"]
#[inline (always)] pub fn rmvf (& mut self) -> RmvfW < '_ , CsrSpec > { RmvfW :: new (self , 24) }
#[doc = "Bit 26 - PIN reset flag"]
#[inline (always)] pub fn pinrstf (& mut self) -> PinrstfW < '_ , CsrSpec > { PinrstfW :: new (self , 26) }
#[doc = "Bit 27 - POR/PDR reset flag"]
#[inline (always)] pub fn porrstf (& mut self) -> PorrstfW < '_ , CsrSpec > { PorrstfW :: new (self , 27) }
#[doc = "Bit 28 - Software reset flag"]
#[inline (always)] pub fn sftrstf (& mut self) -> SftrstfW < '_ , CsrSpec > { SftrstfW :: new (self , 28) }
#[doc = "Bit 29 - Independent watchdog reset flag"]
#[inline (always)] pub fn iwdgrstf (& mut self) -> IwdgrstfW < '_ , CsrSpec > { IwdgrstfW :: new (self , 29) }
#[doc = "Bit 30 - Window watchdog reset flag"]
#[inline (always)] pub fn wwdgrstf (& mut self) -> WwdgrstfW < '_ , CsrSpec > { WwdgrstfW :: new (self , 30) } }
#[doc = "Control Status Register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`csr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { }
#[doc = "`write(|w| ..)` method takes [`csr::W`](W) writer structure"] impl crate :: Writable for CsrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CSR to value 0x0c00_0000"] impl crate :: Resettable for CsrSpec { const RESET_VALUE : u32 = 0x0c00_0000 ; } }
#[doc = "AHBRSTR (rw) register accessor: Advanced High Performance Bus Reset Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahbrstr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahbrstr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahbrstr`] module"]
#[doc (alias = "AHBRSTR")] pub type Ahbrstr = crate :: Reg < ahbrstr :: AhbrstrSpec > ;
#[doc = "Advanced High Performance Bus Reset Register"] pub mod ahbrstr {
#[doc = "Register `AHBRSTR` reader"] pub type R = crate :: R < AhbrstrSpec > ;
#[doc = "Register `AHBRSTR` writer"] pub type W = crate :: W < AhbrstrSpec > ;
#[doc = "Field `DMA1` reader - DMA1 clock reset"] pub type Dma1R = crate :: BitReader ;
#[doc = "Field `DMA1` writer - DMA1 clock reset"] pub type Dma1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SRAM` reader - SRAM interface clock reset"] pub type SramR = crate :: BitReader ;
#[doc = "Field `SRAM` writer - SRAM interface clock reset"] pub type SramW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FLITF` reader - FLITF clock reset"] pub type FlitfR = crate :: BitReader ;
#[doc = "Field `FLITF` writer - FLITF clock reset"] pub type FlitfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CRC` reader - CRC clock reset"] pub type CrcR = crate :: BitReader ;
#[doc = "Field `CRC` writer - CRC clock reset"] pub type CrcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOA` reader - I/O port A clock reset"] pub type GpioaR = crate :: BitReader ;
#[doc = "Field `GPIOA` writer - I/O port A clock reset"] pub type GpioaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOB` reader - I/O port B clock reset"] pub type GpiobR = crate :: BitReader ;
#[doc = "Field `GPIOB` writer - I/O port B clock reset"] pub type GpiobW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOC` reader - I/O port C clock reset"] pub type GpiocR = crate :: BitReader ;
#[doc = "Field `GPIOC` writer - I/O port C clock reset"] pub type GpiocW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `GPIOD` reader - I/O port D clock reset"] pub type GpiodR = crate :: BitReader ;
#[doc = "Field `GPIOD` writer - I/O port D clock reset"] pub type GpiodW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HWDIV` reader - HWDIV clock reset"] pub type HwdivR = crate :: BitReader ;
#[doc = "Field `HWDIV` writer - HWDIV clock reset"] pub type HwdivW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DMA1 clock reset"]
#[inline (always)] pub fn dma1 (& self) -> Dma1R { Dma1R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - SRAM interface clock reset"]
#[inline (always)] pub fn sram (& self) -> SramR { SramR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - FLITF clock reset"]
#[inline (always)] pub fn flitf (& self) -> FlitfR { FlitfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - CRC clock reset"]
#[inline (always)] pub fn crc (& self) -> CrcR { CrcR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 17 - I/O port A clock reset"]
#[inline (always)] pub fn gpioa (& self) -> GpioaR { GpioaR :: new (((self . bits >> 17) & 1) != 0) }
#[doc = "Bit 18 - I/O port B clock reset"]
#[inline (always)] pub fn gpiob (& self) -> GpiobR { GpiobR :: new (((self . bits >> 18) & 1) != 0) }
#[doc = "Bit 19 - I/O port C clock reset"]
#[inline (always)] pub fn gpioc (& self) -> GpiocR { GpiocR :: new (((self . bits >> 19) & 1) != 0) }
#[doc = "Bit 20 - I/O port D clock reset"]
#[inline (always)] pub fn gpiod (& self) -> GpiodR { GpiodR :: new (((self . bits >> 20) & 1) != 0) }
#[doc = "Bit 26 - HWDIV clock reset"]
#[inline (always)] pub fn hwdiv (& self) -> HwdivR { HwdivR :: new (((self . bits >> 26) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DMA1 clock reset"]
#[inline (always)] pub fn dma1 (& mut self) -> Dma1W < '_ , AhbrstrSpec > { Dma1W :: new (self , 0) }
#[doc = "Bit 2 - SRAM interface clock reset"]
#[inline (always)] pub fn sram (& mut self) -> SramW < '_ , AhbrstrSpec > { SramW :: new (self , 2) }
#[doc = "Bit 4 - FLITF clock reset"]
#[inline (always)] pub fn flitf (& mut self) -> FlitfW < '_ , AhbrstrSpec > { FlitfW :: new (self , 4) }
#[doc = "Bit 6 - CRC clock reset"]
#[inline (always)] pub fn crc (& mut self) -> CrcW < '_ , AhbrstrSpec > { CrcW :: new (self , 6) }
#[doc = "Bit 17 - I/O port A clock reset"]
#[inline (always)] pub fn gpioa (& mut self) -> GpioaW < '_ , AhbrstrSpec > { GpioaW :: new (self , 17) }
#[doc = "Bit 18 - I/O port B clock reset"]
#[inline (always)] pub fn gpiob (& mut self) -> GpiobW < '_ , AhbrstrSpec > { GpiobW :: new (self , 18) }
#[doc = "Bit 19 - I/O port C clock reset"]
#[inline (always)] pub fn gpioc (& mut self) -> GpiocW < '_ , AhbrstrSpec > { GpiocW :: new (self , 19) }
#[doc = "Bit 20 - I/O port D clock reset"]
#[inline (always)] pub fn gpiod (& mut self) -> GpiodW < '_ , AhbrstrSpec > { GpiodW :: new (self , 20) }
#[doc = "Bit 26 - HWDIV clock reset"]
#[inline (always)] pub fn hwdiv (& mut self) -> HwdivW < '_ , AhbrstrSpec > { HwdivW :: new (self , 26) } }
#[doc = "Advanced High Performance Bus Reset Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ahbrstr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahbrstr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AhbrstrSpec ; impl crate :: RegisterSpec for AhbrstrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ahbrstr::R`](R) reader structure"] impl crate :: Readable for AhbrstrSpec { }
#[doc = "`write(|w| ..)` method takes [`ahbrstr::W`](W) writer structure"] impl crate :: Writable for AhbrstrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AHBRSTR to value 0"] impl crate :: Resettable for AhbrstrSpec { } }
#[doc = "CONFIG (rw) register accessor: System Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config`] module"]
#[doc (alias = "CONFIG")] pub type Config = crate :: Reg < config :: ConfigSpec > ;
#[doc = "System Configuration Register"] pub mod config {
#[doc = "Register `CONFIG` reader"] pub type R = crate :: R < ConfigSpec > ;
#[doc = "Register `CONFIG` writer"] pub type W = crate :: W < ConfigSpec > ;
#[doc = "Field `PAGESIZE` reader - Flash Page size"] pub type PagesizeR = crate :: BitReader ;
#[doc = "Field `PAGESIZE` writer - Flash Page size"] pub type PagesizeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSC_RTRIM` reader - Oscillator feedback resistance trimming"] pub type OscRtrimR = crate :: FieldReader ;
#[doc = "Field `OSC_RTRIM` writer - Oscillator feedback resistance trimming"] pub type OscRtrimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OSC_ITRIM` reader - Oscillator drive current trimming"] pub type OscItrimR = crate :: FieldReader ;
#[doc = "Field `OSC_ITRIM` writer - Oscillator drive current trimming"] pub type OscItrimW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSC_LPFEN` reader - Oscillator low pass filtering enable"] pub type OscLpfenR = crate :: BitReader ;
#[doc = "Field `OSC_LPFEN` writer - Oscillator low pass filtering enable"] pub type OscLpfenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 1 - Flash Page size"]
#[inline (always)] pub fn pagesize (& self) -> PagesizeR { PagesizeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 8:10 - Oscillator feedback resistance trimming"]
#[inline (always)] pub fn osc_rtrim (& self) -> OscRtrimR { OscRtrimR :: new (((self . bits >> 8) & 7) as u8) }
#[doc = "Bits 11:12 - Oscillator drive current trimming"]
#[inline (always)] pub fn osc_itrim (& self) -> OscItrimR { OscItrimR :: new (((self . bits >> 11) & 3) as u8) }
#[doc = "Bit 14 - Oscillator low pass filtering enable"]
#[inline (always)] pub fn osc_lpfen (& self) -> OscLpfenR { OscLpfenR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 1 - Flash Page size"]
#[inline (always)] pub fn pagesize (& mut self) -> PagesizeW < '_ , ConfigSpec > { PagesizeW :: new (self , 1) }
#[doc = "Bits 8:10 - Oscillator feedback resistance trimming"]
#[inline (always)] pub fn osc_rtrim (& mut self) -> OscRtrimW < '_ , ConfigSpec > { OscRtrimW :: new (self , 8) }
#[doc = "Bits 11:12 - Oscillator drive current trimming"]
#[inline (always)] pub fn osc_itrim (& mut self) -> OscItrimW < '_ , ConfigSpec > { OscItrimW :: new (self , 11) }
#[doc = "Bit 14 - Oscillator low pass filtering enable"]
#[inline (always)] pub fn osc_lpfen (& mut self) -> OscLpfenW < '_ , ConfigSpec > { OscLpfenW :: new (self , 14) } }
#[doc = "System Configuration Register\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ConfigSpec ; impl crate :: RegisterSpec for ConfigSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`config::R`](R) reader structure"] impl crate :: Readable for ConfigSpec { }
#[doc = "`write(|w| ..)` method takes [`config::W`](W) writer structure"] impl crate :: Writable for ConfigSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CONFIG to value 0"] impl crate :: Resettable for ConfigSpec { } } }
#[doc = "Serial peripheral interface"] pub type Spi1 = crate :: Periph < spi1 :: RegisterBlock , 0x4001_3000 > ; impl core :: fmt :: Debug for Spi1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi1") . finish () } }
#[doc = "Serial peripheral interface"] pub mod spi1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { txreg : Txreg , rxreg : Rxreg , cstat : Cstat , intstat : Intstat , inten : Inten , intclr : Intclr , gctl : Gctl , cctl : Cctl , spbrg : Spbrg , rxdnr : Rxdnr , nssr : Nssr , extctl : Extctl , } impl RegisterBlock {
#[doc = "0x00 - TXREG"]
#[inline (always)] pub const fn txreg (& self) -> & Txreg { & self . txreg }
#[doc = "0x04 - RXREG"]
#[inline (always)] pub const fn rxreg (& self) -> & Rxreg { & self . rxreg }
#[doc = "0x08 - CSTAT"]
#[inline (always)] pub const fn cstat (& self) -> & Cstat { & self . cstat }
#[doc = "0x0c - INTSTAT"]
#[inline (always)] pub const fn intstat (& self) -> & Intstat { & self . intstat }
#[doc = "0x10 - INTEN"]
#[inline (always)] pub const fn inten (& self) -> & Inten { & self . inten }
#[doc = "0x14 - INTCLR"]
#[inline (always)] pub const fn intclr (& self) -> & Intclr { & self . intclr }
#[doc = "0x18 - GCTL"]
#[inline (always)] pub const fn gctl (& self) -> & Gctl { & self . gctl }
#[doc = "0x1c - CCTL"]
#[inline (always)] pub const fn cctl (& self) -> & Cctl { & self . cctl }
#[doc = "0x20 - SPBRG"]
#[inline (always)] pub const fn spbrg (& self) -> & Spbrg { & self . spbrg }
#[doc = "0x24 - RXDNR"]
#[inline (always)] pub const fn rxdnr (& self) -> & Rxdnr { & self . rxdnr }
#[doc = "0x28 - NSSR"]
#[inline (always)] pub const fn nssr (& self) -> & Nssr { & self . nssr }
#[doc = "0x2c - EXTCTL"]
#[inline (always)] pub const fn extctl (& self) -> & Extctl { & self . extctl } }
#[doc = "TXREG (rw) register accessor: TXREG\n\nYou can [`read`](crate::Reg::read) this register and get [`txreg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txreg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txreg`] module"]
#[doc (alias = "TXREG")] pub type Txreg = crate :: Reg < txreg :: TxregSpec > ;
#[doc = "TXREG"] pub mod txreg {
#[doc = "Register `TXREG` reader"] pub type R = crate :: R < TxregSpec > ;
#[doc = "Register `TXREG` writer"] pub type W = crate :: W < TxregSpec > ;
#[doc = "Field `TXREG` reader - Transmit data register"] pub type TxregR = crate :: FieldReader < u32 > ;
#[doc = "Field `TXREG` writer - Transmit data register"] pub type TxregW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Transmit data register"]
#[inline (always)] pub fn txreg (& self) -> TxregR { TxregR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Transmit data register"]
#[inline (always)] pub fn txreg (& mut self) -> TxregW < '_ , TxregSpec > { TxregW :: new (self , 0) } }
#[doc = "TXREG\n\nYou can [`read`](crate::Reg::read) this register and get [`txreg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txreg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TxregSpec ; impl crate :: RegisterSpec for TxregSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`txreg::R`](R) reader structure"] impl crate :: Readable for TxregSpec { }
#[doc = "`write(|w| ..)` method takes [`txreg::W`](W) writer structure"] impl crate :: Writable for TxregSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TXREG to value 0"] impl crate :: Resettable for TxregSpec { } }
#[doc = "RXREG (r) register accessor: RXREG\n\nYou can [`read`](crate::Reg::read) this register and get [`rxreg::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxreg`] module"]
#[doc (alias = "RXREG")] pub type Rxreg = crate :: Reg < rxreg :: RxregSpec > ;
#[doc = "RXREG"] pub mod rxreg {
#[doc = "Register `RXREG` reader"] pub type R = crate :: R < RxregSpec > ;
#[doc = "Field `RXREG` reader - Receive data register"] pub type RxregR = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - Receive data register"]
#[inline (always)] pub fn rxreg (& self) -> RxregR { RxregR :: new (self . bits) } }
#[doc = "RXREG\n\nYou can [`read`](crate::Reg::read) this register and get [`rxreg::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxregSpec ; impl crate :: RegisterSpec for RxregSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rxreg::R`](R) reader structure"] impl crate :: Readable for RxregSpec { }
#[doc = "`reset()` method sets RXREG to value 0"] impl crate :: Resettable for RxregSpec { } }
#[doc = "CSTAT (r) register accessor: CSTAT\n\nYou can [`read`](crate::Reg::read) this register and get [`cstat::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cstat`] module"]
#[doc (alias = "CSTAT")] pub type Cstat = crate :: Reg < cstat :: CstatSpec > ;
#[doc = "CSTAT"] pub mod cstat {
#[doc = "Register `CSTAT` reader"] pub type R = crate :: R < CstatSpec > ;
#[doc = "Field `TXEPT` reader - Transmitter empty bit"] pub type TxeptR = crate :: BitReader ;
#[doc = "Field `RXAVL` reader - Receive available byte data message"] pub type RxavlR = crate :: BitReader ;
#[doc = "Field `TXFULL` reader - Transmitter FIFO full status bit"] pub type TxfullR = crate :: BitReader ;
#[doc = "Field `RXAVL_4BYTE` reader - Receive available 4 byte data message"] pub type Rxavl4byteR = crate :: BitReader ;
#[doc = "Field `TXFADDR` reader - Receive FIFO address"] pub type TxfaddrR = crate :: FieldReader ;
#[doc = "Field `RXFADDR` reader - Transmit FIFO address"] pub type RxfaddrR = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - Transmitter empty bit"]
#[inline (always)] pub fn txept (& self) -> TxeptR { TxeptR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receive available byte data message"]
#[inline (always)] pub fn rxavl (& self) -> RxavlR { RxavlR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Transmitter FIFO full status bit"]
#[inline (always)] pub fn txfull (& self) -> TxfullR { TxfullR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Receive available 4 byte data message"]
#[inline (always)] pub fn rxavl_4byte (& self) -> Rxavl4byteR { Rxavl4byteR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:7 - Receive FIFO address"]
#[inline (always)] pub fn txfaddr (& self) -> TxfaddrR { TxfaddrR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:11 - Transmit FIFO address"]
#[inline (always)] pub fn rxfaddr (& self) -> RxfaddrR { RxfaddrR :: new (((self . bits >> 8) & 0x0f) as u8) } }
#[doc = "CSTAT\n\nYou can [`read`](crate::Reg::read) this register and get [`cstat::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CstatSpec ; impl crate :: RegisterSpec for CstatSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cstat::R`](R) reader structure"] impl crate :: Readable for CstatSpec { }
#[doc = "`reset()` method sets CSTAT to value 0x01"] impl crate :: Resettable for CstatSpec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "INTSTAT (rw) register accessor: INTSTAT\n\nYou can [`read`](crate::Reg::read) this register and get [`intstat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`intstat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@intstat`] module"]
#[doc (alias = "INTSTAT")] pub type Intstat = crate :: Reg < intstat :: IntstatSpec > ;
#[doc = "INTSTAT"] pub mod intstat {
#[doc = "Register `INTSTAT` reader"] pub type R = crate :: R < IntstatSpec > ;
#[doc = "Register `INTSTAT` writer"] pub type W = crate :: W < IntstatSpec > ;
#[doc = "Field `TX_INTF` reader - Transmit FIFO avialable interrupt flag bit"] pub type TxIntfR = crate :: BitReader ;
#[doc = "Field `TX_INTF` writer - Transmit FIFO avialable interrupt flag bit"] pub type TxIntfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RX_INTF` reader - Receive data available interrupt flag bit"] pub type RxIntfR = crate :: BitReader ;
#[doc = "Field `RX_INTF` writer - Receive data available interrupt flag bit"] pub type RxIntfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UNDERRUN_INTF` reader - SPI underrun interrupt flag bit"] pub type UnderrunIntfR = crate :: BitReader ;
#[doc = "Field `UNDERRUN_INTF` writer - SPI underrun interrupt flag bit"] pub type UnderrunIntfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXOERR_INTF` reader - Receive overrun error interrupt flag bit"] pub type RxoerrIntfR = crate :: BitReader ;
#[doc = "Field `RXOERR_INTF` writer - Receive overrun error interrupt flag bit"] pub type RxoerrIntfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXMATCH_INTF` reader - Receive data match the RXDNR number"] pub type RxmatchIntfR = crate :: BitReader ;
#[doc = "Field `RXMATCH_INTF` writer - Receive data match the RXDNR number"] pub type RxmatchIntfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFULL_INTF` reader - RX FIFO full interrupt flag bit"] pub type RxfullIntfR = crate :: BitReader ;
#[doc = "Field `RXFULL_INTF` writer - RX FIFO full interrupt flag bit"] pub type RxfullIntfW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEPT_INTF` reader - Transmitter empty interrupt flag bit"] pub type TxeptIntfR = crate :: BitReader ;
#[doc = "Field `TXEPT_INTF` writer - Transmitter empty interrupt flag bit"] pub type TxeptIntfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transmit FIFO avialable interrupt flag bit"]
#[inline (always)] pub fn tx_intf (& self) -> TxIntfR { TxIntfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receive data available interrupt flag bit"]
#[inline (always)] pub fn rx_intf (& self) -> RxIntfR { RxIntfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - SPI underrun interrupt flag bit"]
#[inline (always)] pub fn underrun_intf (& self) -> UnderrunIntfR { UnderrunIntfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Receive overrun error interrupt flag bit"]
#[inline (always)] pub fn rxoerr_intf (& self) -> RxoerrIntfR { RxoerrIntfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Receive data match the RXDNR number"]
#[inline (always)] pub fn rxmatch_intf (& self) -> RxmatchIntfR { RxmatchIntfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RX FIFO full interrupt flag bit"]
#[inline (always)] pub fn rxfull_intf (& self) -> RxfullIntfR { RxfullIntfR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transmitter empty interrupt flag bit"]
#[inline (always)] pub fn txept_intf (& self) -> TxeptIntfR { TxeptIntfR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transmit FIFO avialable interrupt flag bit"]
#[inline (always)] pub fn tx_intf (& mut self) -> TxIntfW < '_ , IntstatSpec > { TxIntfW :: new (self , 0) }
#[doc = "Bit 1 - Receive data available interrupt flag bit"]
#[inline (always)] pub fn rx_intf (& mut self) -> RxIntfW < '_ , IntstatSpec > { RxIntfW :: new (self , 1) }
#[doc = "Bit 2 - SPI underrun interrupt flag bit"]
#[inline (always)] pub fn underrun_intf (& mut self) -> UnderrunIntfW < '_ , IntstatSpec > { UnderrunIntfW :: new (self , 2) }
#[doc = "Bit 3 - Receive overrun error interrupt flag bit"]
#[inline (always)] pub fn rxoerr_intf (& mut self) -> RxoerrIntfW < '_ , IntstatSpec > { RxoerrIntfW :: new (self , 3) }
#[doc = "Bit 4 - Receive data match the RXDNR number"]
#[inline (always)] pub fn rxmatch_intf (& mut self) -> RxmatchIntfW < '_ , IntstatSpec > { RxmatchIntfW :: new (self , 4) }
#[doc = "Bit 5 - RX FIFO full interrupt flag bit"]
#[inline (always)] pub fn rxfull_intf (& mut self) -> RxfullIntfW < '_ , IntstatSpec > { RxfullIntfW :: new (self , 5) }
#[doc = "Bit 6 - Transmitter empty interrupt flag bit"]
#[inline (always)] pub fn txept_intf (& mut self) -> TxeptIntfW < '_ , IntstatSpec > { TxeptIntfW :: new (self , 6) } }
#[doc = "INTSTAT\n\nYou can [`read`](crate::Reg::read) this register and get [`intstat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`intstat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IntstatSpec ; impl crate :: RegisterSpec for IntstatSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`intstat::R`](R) reader structure"] impl crate :: Readable for IntstatSpec { }
#[doc = "`write(|w| ..)` method takes [`intstat::W`](W) writer structure"] impl crate :: Writable for IntstatSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INTSTAT to value 0"] impl crate :: Resettable for IntstatSpec { } }
#[doc = "INTEN (rw) register accessor: INTEN\n\nYou can [`read`](crate::Reg::read) this register and get [`inten::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inten::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inten`] module"]
#[doc (alias = "INTEN")] pub type Inten = crate :: Reg < inten :: IntenSpec > ;
#[doc = "INTEN"] pub mod inten {
#[doc = "Register `INTEN` reader"] pub type R = crate :: R < IntenSpec > ;
#[doc = "Register `INTEN` writer"] pub type W = crate :: W < IntenSpec > ;
#[doc = "Field `TX_IEN` reader - Transmit FIFO empty interrupt enable bit"] pub type TxIenR = crate :: BitReader ;
#[doc = "Field `TX_IEN` writer - Transmit FIFO empty interrupt enable bit"] pub type TxIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RX_IEN` reader - Receive FIFO interrupt enable bit"] pub type RxIenR = crate :: BitReader ;
#[doc = "Field `RX_IEN` writer - Receive FIFO interrupt enable bit"] pub type RxIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UNDERRUN_IEN` reader - Transmitter underrun interrupt enable bit(SPI slave mode only)"] pub type UnderrunIenR = crate :: BitReader ;
#[doc = "Field `UNDERRUN_IEN` writer - Transmitter underrun interrupt enable bit(SPI slave mode only)"] pub type UnderrunIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXOERR_IEN` reader - Overrun error interrupt enable bit"] pub type RxoerrIenR = crate :: BitReader ;
#[doc = "Field `RXOERR_IEN` writer - Overrun error interrupt enable bit"] pub type RxoerrIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXMATCH_IEN` reader - Receive data complete interrupt enable bit"] pub type RxmatchIenR = crate :: BitReader ;
#[doc = "Field `RXMATCH_IEN` writer - Receive data complete interrupt enable bit"] pub type RxmatchIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFULL_IEN` reader - Receive FIFO full interrupt enable bit"] pub type RxfullIenR = crate :: BitReader ;
#[doc = "Field `RXFULL_IEN` writer - Receive FIFO full interrupt enable bit"] pub type RxfullIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEPT_IEN` reader - Transmit empty interrupt enable bit"] pub type TxeptIenR = crate :: BitReader ;
#[doc = "Field `TXEPT_IEN` writer - Transmit empty interrupt enable bit"] pub type TxeptIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transmit FIFO empty interrupt enable bit"]
#[inline (always)] pub fn tx_ien (& self) -> TxIenR { TxIenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receive FIFO interrupt enable bit"]
#[inline (always)] pub fn rx_ien (& self) -> RxIenR { RxIenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Transmitter underrun interrupt enable bit(SPI slave mode only)"]
#[inline (always)] pub fn underrun_ien (& self) -> UnderrunIenR { UnderrunIenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Overrun error interrupt enable bit"]
#[inline (always)] pub fn rxoerr_ien (& self) -> RxoerrIenR { RxoerrIenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Receive data complete interrupt enable bit"]
#[inline (always)] pub fn rxmatch_ien (& self) -> RxmatchIenR { RxmatchIenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Receive FIFO full interrupt enable bit"]
#[inline (always)] pub fn rxfull_ien (& self) -> RxfullIenR { RxfullIenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transmit empty interrupt enable bit"]
#[inline (always)] pub fn txept_ien (& self) -> TxeptIenR { TxeptIenR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transmit FIFO empty interrupt enable bit"]
#[inline (always)] pub fn tx_ien (& mut self) -> TxIenW < '_ , IntenSpec > { TxIenW :: new (self , 0) }
#[doc = "Bit 1 - Receive FIFO interrupt enable bit"]
#[inline (always)] pub fn rx_ien (& mut self) -> RxIenW < '_ , IntenSpec > { RxIenW :: new (self , 1) }
#[doc = "Bit 2 - Transmitter underrun interrupt enable bit(SPI slave mode only)"]
#[inline (always)] pub fn underrun_ien (& mut self) -> UnderrunIenW < '_ , IntenSpec > { UnderrunIenW :: new (self , 2) }
#[doc = "Bit 3 - Overrun error interrupt enable bit"]
#[inline (always)] pub fn rxoerr_ien (& mut self) -> RxoerrIenW < '_ , IntenSpec > { RxoerrIenW :: new (self , 3) }
#[doc = "Bit 4 - Receive data complete interrupt enable bit"]
#[inline (always)] pub fn rxmatch_ien (& mut self) -> RxmatchIenW < '_ , IntenSpec > { RxmatchIenW :: new (self , 4) }
#[doc = "Bit 5 - Receive FIFO full interrupt enable bit"]
#[inline (always)] pub fn rxfull_ien (& mut self) -> RxfullIenW < '_ , IntenSpec > { RxfullIenW :: new (self , 5) }
#[doc = "Bit 6 - Transmit empty interrupt enable bit"]
#[inline (always)] pub fn txept_ien (& mut self) -> TxeptIenW < '_ , IntenSpec > { TxeptIenW :: new (self , 6) } }
#[doc = "INTEN\n\nYou can [`read`](crate::Reg::read) this register and get [`inten::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inten::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IntenSpec ; impl crate :: RegisterSpec for IntenSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`inten::R`](R) reader structure"] impl crate :: Readable for IntenSpec { }
#[doc = "`write(|w| ..)` method takes [`inten::W`](W) writer structure"] impl crate :: Writable for IntenSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INTEN to value 0"] impl crate :: Resettable for IntenSpec { } }
#[doc = "INTCLR (rw) register accessor: INTCLR\n\nYou can [`read`](crate::Reg::read) this register and get [`intclr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`intclr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@intclr`] module"]
#[doc (alias = "INTCLR")] pub type Intclr = crate :: Reg < intclr :: IntclrSpec > ;
#[doc = "INTCLR"] pub mod intclr {
#[doc = "Register `INTCLR` reader"] pub type R = crate :: R < IntclrSpec > ;
#[doc = "Register `INTCLR` writer"] pub type W = crate :: W < IntclrSpec > ;
#[doc = "Field `TX_ICLR` reader - Transmitter FIFO empty interrupt clear bit"] pub type TxIclrR = crate :: BitReader ;
#[doc = "Field `TX_ICLR` writer - Transmitter FIFO empty interrupt clear bit"] pub type TxIclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RX_ICLR` reader - Receive interrupt clear bit"] pub type RxIclrR = crate :: BitReader ;
#[doc = "Field `RX_ICLR` writer - Receive interrupt clear bit"] pub type RxIclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UNDERRUN_ICLR` reader - Transmitter underrun interrupt clear bit(SPI slave mode only)"] pub type UnderrunIclrR = crate :: BitReader ;
#[doc = "Field `UNDERRUN_ICLR` writer - Transmitter underrun interrupt clear bit(SPI slave mode only)"] pub type UnderrunIclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXOERR_ICLR` reader - Overrun error interrupt clear bit"] pub type RxoerrIclrR = crate :: BitReader ;
#[doc = "Field `RXOERR_ICLR` writer - Overrun error interrupt clear bit"] pub type RxoerrIclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXMATCH_ICLR` reader - Receive completed interrupt clear bit"] pub type RxmatchIclrR = crate :: BitReader ;
#[doc = "Field `RXMATCH_ICLR` writer - Receive completed interrupt clear bit"] pub type RxmatchIclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFULL_ICLR` reader - Receiver buffer full interrupt clear bit"] pub type RxfullIclrR = crate :: BitReader ;
#[doc = "Field `RXFULL_ICLR` writer - Receiver buffer full interrupt clear bit"] pub type RxfullIclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEPT_ICLR` reader - Transmitter empty interrupt clear bit"] pub type TxeptIclrR = crate :: BitReader ;
#[doc = "Field `TXEPT_ICLR` writer - Transmitter empty interrupt clear bit"] pub type TxeptIclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transmitter FIFO empty interrupt clear bit"]
#[inline (always)] pub fn tx_iclr (& self) -> TxIclrR { TxIclrR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receive interrupt clear bit"]
#[inline (always)] pub fn rx_iclr (& self) -> RxIclrR { RxIclrR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Transmitter underrun interrupt clear bit(SPI slave mode only)"]
#[inline (always)] pub fn underrun_iclr (& self) -> UnderrunIclrR { UnderrunIclrR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Overrun error interrupt clear bit"]
#[inline (always)] pub fn rxoerr_iclr (& self) -> RxoerrIclrR { RxoerrIclrR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Receive completed interrupt clear bit"]
#[inline (always)] pub fn rxmatch_iclr (& self) -> RxmatchIclrR { RxmatchIclrR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Receiver buffer full interrupt clear bit"]
#[inline (always)] pub fn rxfull_iclr (& self) -> RxfullIclrR { RxfullIclrR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Transmitter empty interrupt clear bit"]
#[inline (always)] pub fn txept_iclr (& self) -> TxeptIclrR { TxeptIclrR :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transmitter FIFO empty interrupt clear bit"]
#[inline (always)] pub fn tx_iclr (& mut self) -> TxIclrW < '_ , IntclrSpec > { TxIclrW :: new (self , 0) }
#[doc = "Bit 1 - Receive interrupt clear bit"]
#[inline (always)] pub fn rx_iclr (& mut self) -> RxIclrW < '_ , IntclrSpec > { RxIclrW :: new (self , 1) }
#[doc = "Bit 2 - Transmitter underrun interrupt clear bit(SPI slave mode only)"]
#[inline (always)] pub fn underrun_iclr (& mut self) -> UnderrunIclrW < '_ , IntclrSpec > { UnderrunIclrW :: new (self , 2) }
#[doc = "Bit 3 - Overrun error interrupt clear bit"]
#[inline (always)] pub fn rxoerr_iclr (& mut self) -> RxoerrIclrW < '_ , IntclrSpec > { RxoerrIclrW :: new (self , 3) }
#[doc = "Bit 4 - Receive completed interrupt clear bit"]
#[inline (always)] pub fn rxmatch_iclr (& mut self) -> RxmatchIclrW < '_ , IntclrSpec > { RxmatchIclrW :: new (self , 4) }
#[doc = "Bit 5 - Receiver buffer full interrupt clear bit"]
#[inline (always)] pub fn rxfull_iclr (& mut self) -> RxfullIclrW < '_ , IntclrSpec > { RxfullIclrW :: new (self , 5) }
#[doc = "Bit 6 - Transmitter empty interrupt clear bit"]
#[inline (always)] pub fn txept_iclr (& mut self) -> TxeptIclrW < '_ , IntclrSpec > { TxeptIclrW :: new (self , 6) } }
#[doc = "INTCLR\n\nYou can [`read`](crate::Reg::read) this register and get [`intclr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`intclr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IntclrSpec ; impl crate :: RegisterSpec for IntclrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`intclr::R`](R) reader structure"] impl crate :: Readable for IntclrSpec { }
#[doc = "`write(|w| ..)` method takes [`intclr::W`](W) writer structure"] impl crate :: Writable for IntclrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INTCLR to value 0"] impl crate :: Resettable for IntclrSpec { } }
#[doc = "GCTL (rw) register accessor: GCTL\n\nYou can [`read`](crate::Reg::read) this register and get [`gctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gctl`] module"]
#[doc (alias = "GCTL")] pub type Gctl = crate :: Reg < gctl :: GctlSpec > ;
#[doc = "GCTL"] pub mod gctl {
#[doc = "Register `GCTL` reader"] pub type R = crate :: R < GctlSpec > ;
#[doc = "Register `GCTL` writer"] pub type W = crate :: W < GctlSpec > ;
#[doc = "Field `SPIEN` reader - SPI select bit"] pub type SpienR = crate :: BitReader ;
#[doc = "Field `SPIEN` writer - SPI select bit"] pub type SpienW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INT_EN` reader - SPI interrupt enable bit"] pub type IntEnR = crate :: BitReader ;
#[doc = "Field `INT_EN` writer - SPI interrupt enable bit"] pub type IntEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MODE` reader - Master mode bit"] pub type ModeR = crate :: BitReader ;
#[doc = "Field `MODE` writer - Master mode bit"] pub type ModeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEN` reader - Transmit enable bit"] pub type TxenR = crate :: BitReader ;
#[doc = "Field `TXEN` writer - Transmit enable bit"] pub type TxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXEN` reader - Receive enable bit"] pub type RxenR = crate :: BitReader ;
#[doc = "Field `RXEN` writer - Receive enable bit"] pub type RxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXTLF` reader - RX FIFO trigger level bit"] pub type RxtlfR = crate :: FieldReader ;
#[doc = "Field `RXTLF` writer - RX FIFO trigger level bit"] pub type RxtlfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `TXTLF` reader - TX FIFO trigger level bit"] pub type TxtlfR = crate :: FieldReader ;
#[doc = "Field `TXTLF` writer - TX FIFO trigger level bit"] pub type TxtlfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `DMAEN` reader - DMA access mode enable"] pub type DmaenR = crate :: BitReader ;
#[doc = "Field `DMAEN` writer - DMA access mode enable"] pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NSS_SEL` reader - NSS select signal that from software and hardware"] pub type NssSelR = crate :: BitReader ;
#[doc = "Field `NSS_SEL` writer - NSS select signal that from software and hardware"] pub type NssSelW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DW8_32` reader - Valid byte or double-word data select signal"] pub type Dw8_32R = crate :: BitReader ;
#[doc = "Field `DW8_32` writer - Valid byte or double-word data select signal"] pub type Dw8_32W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NSSTOG` reader - NSS selection signal is automatically flipped"] pub type NsstogR = crate :: BitReader ;
#[doc = "Field `NSSTOG` writer - NSS selection signal is automatically flipped"] pub type NsstogW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - SPI select bit"]
#[inline (always)] pub fn spien (& self) -> SpienR { SpienR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - SPI interrupt enable bit"]
#[inline (always)] pub fn int_en (& self) -> IntEnR { IntEnR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Master mode bit"]
#[inline (always)] pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transmit enable bit"]
#[inline (always)] pub fn txen (& self) -> TxenR { TxenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Receive enable bit"]
#[inline (always)] pub fn rxen (& self) -> RxenR { RxenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:6 - RX FIFO trigger level bit"]
#[inline (always)] pub fn rxtlf (& self) -> RxtlfR { RxtlfR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bits 7:8 - TX FIFO trigger level bit"]
#[inline (always)] pub fn txtlf (& self) -> TxtlfR { TxtlfR :: new (((self . bits >> 7) & 3) as u8) }
#[doc = "Bit 9 - DMA access mode enable"]
#[inline (always)] pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - NSS select signal that from software and hardware"]
#[inline (always)] pub fn nss_sel (& self) -> NssSelR { NssSelR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Valid byte or double-word data select signal"]
#[inline (always)] pub fn dw8_32 (& self) -> Dw8_32R { Dw8_32R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - NSS selection signal is automatically flipped"]
#[inline (always)] pub fn nsstog (& self) -> NsstogR { NsstogR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - SPI select bit"]
#[inline (always)] pub fn spien (& mut self) -> SpienW < '_ , GctlSpec > { SpienW :: new (self , 0) }
#[doc = "Bit 1 - SPI interrupt enable bit"]
#[inline (always)] pub fn int_en (& mut self) -> IntEnW < '_ , GctlSpec > { IntEnW :: new (self , 1) }
#[doc = "Bit 2 - Master mode bit"]
#[inline (always)] pub fn mode (& mut self) -> ModeW < '_ , GctlSpec > { ModeW :: new (self , 2) }
#[doc = "Bit 3 - Transmit enable bit"]
#[inline (always)] pub fn txen (& mut self) -> TxenW < '_ , GctlSpec > { TxenW :: new (self , 3) }
#[doc = "Bit 4 - Receive enable bit"]
#[inline (always)] pub fn rxen (& mut self) -> RxenW < '_ , GctlSpec > { RxenW :: new (self , 4) }
#[doc = "Bits 5:6 - RX FIFO trigger level bit"]
#[inline (always)] pub fn rxtlf (& mut self) -> RxtlfW < '_ , GctlSpec > { RxtlfW :: new (self , 5) }
#[doc = "Bits 7:8 - TX FIFO trigger level bit"]
#[inline (always)] pub fn txtlf (& mut self) -> TxtlfW < '_ , GctlSpec > { TxtlfW :: new (self , 7) }
#[doc = "Bit 9 - DMA access mode enable"]
#[inline (always)] pub fn dmaen (& mut self) -> DmaenW < '_ , GctlSpec > { DmaenW :: new (self , 9) }
#[doc = "Bit 10 - NSS select signal that from software and hardware"]
#[inline (always)] pub fn nss_sel (& mut self) -> NssSelW < '_ , GctlSpec > { NssSelW :: new (self , 10) }
#[doc = "Bit 11 - Valid byte or double-word data select signal"]
#[inline (always)] pub fn dw8_32 (& mut self) -> Dw8_32W < '_ , GctlSpec > { Dw8_32W :: new (self , 11) }
#[doc = "Bit 12 - NSS selection signal is automatically flipped"]
#[inline (always)] pub fn nsstog (& mut self) -> NsstogW < '_ , GctlSpec > { NsstogW :: new (self , 12) } }
#[doc = "GCTL\n\nYou can [`read`](crate::Reg::read) this register and get [`gctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GctlSpec ; impl crate :: RegisterSpec for GctlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`gctl::R`](R) reader structure"] impl crate :: Readable for GctlSpec { }
#[doc = "`write(|w| ..)` method takes [`gctl::W`](W) writer structure"] impl crate :: Writable for GctlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets GCTL to value 0x04"] impl crate :: Resettable for GctlSpec { const RESET_VALUE : u32 = 0x04 ; } }
#[doc = "CCTL (rw) register accessor: CCTL\n\nYou can [`read`](crate::Reg::read) this register and get [`cctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cctl`] module"]
#[doc (alias = "CCTL")] pub type Cctl = crate :: Reg < cctl :: CctlSpec > ;
#[doc = "CCTL"] pub mod cctl {
#[doc = "Register `CCTL` reader"] pub type R = crate :: R < CctlSpec > ;
#[doc = "Register `CCTL` writer"] pub type W = crate :: W < CctlSpec > ;
#[doc = "Field `CPHA` reader - Clock phase select bit"] pub type CphaR = crate :: BitReader ;
#[doc = "Field `CPHA` writer - Clock phase select bit"] pub type CphaW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPOL` reader - Clock polarity select bit"] pub type CpolR = crate :: BitReader ;
#[doc = "Field `CPOL` writer - Clock polarity select bit"] pub type CpolW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LSBFE` reader - LSI first enable bit"] pub type LsbfeR = crate :: BitReader ;
#[doc = "Field `LSBFE` writer - LSI first enable bit"] pub type LsbfeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPILEN` reader - SPI character length bit"] pub type SpilenR = crate :: BitReader ;
#[doc = "Field `SPILEN` writer - SPI character length bit"] pub type SpilenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXEDGE` reader - Receive data edge select"] pub type RxedgeR = crate :: BitReader ;
#[doc = "Field `RXEDGE` writer - Receive data edge select"] pub type RxedgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEDGE` reader - Transmit data edge select"] pub type TxedgeR = crate :: BitReader ;
#[doc = "Field `TXEDGE` writer - Transmit data edge select"] pub type TxedgeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CPHASEL` reader - CPHA polarity select"] pub type CphaselR = crate :: BitReader ;
#[doc = "Field `CPHASEL` writer - CPHA polarity select"] pub type CphaselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `HISPD` reader - High speed slave mode"] pub type HispdR = crate :: BitReader ;
#[doc = "Field `HISPD` writer - High speed slave mode"] pub type HispdW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Clock phase select bit"]
#[inline (always)] pub fn cpha (& self) -> CphaR { CphaR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Clock polarity select bit"]
#[inline (always)] pub fn cpol (& self) -> CpolR { CpolR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - LSI first enable bit"]
#[inline (always)] pub fn lsbfe (& self) -> LsbfeR { LsbfeR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - SPI character length bit"]
#[inline (always)] pub fn spilen (& self) -> SpilenR { SpilenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Receive data edge select"]
#[inline (always)] pub fn rxedge (& self) -> RxedgeR { RxedgeR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Transmit data edge select"]
#[inline (always)] pub fn txedge (& self) -> TxedgeR { TxedgeR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - CPHA polarity select"]
#[inline (always)] pub fn cphasel (& self) -> CphaselR { CphaselR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - High speed slave mode"]
#[inline (always)] pub fn hispd (& self) -> HispdR { HispdR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Clock phase select bit"]
#[inline (always)] pub fn cpha (& mut self) -> CphaW < '_ , CctlSpec > { CphaW :: new (self , 0) }
#[doc = "Bit 1 - Clock polarity select bit"]
#[inline (always)] pub fn cpol (& mut self) -> CpolW < '_ , CctlSpec > { CpolW :: new (self , 1) }
#[doc = "Bit 2 - LSI first enable bit"]
#[inline (always)] pub fn lsbfe (& mut self) -> LsbfeW < '_ , CctlSpec > { LsbfeW :: new (self , 2) }
#[doc = "Bit 3 - SPI character length bit"]
#[inline (always)] pub fn spilen (& mut self) -> SpilenW < '_ , CctlSpec > { SpilenW :: new (self , 3) }
#[doc = "Bit 4 - Receive data edge select"]
#[inline (always)] pub fn rxedge (& mut self) -> RxedgeW < '_ , CctlSpec > { RxedgeW :: new (self , 4) }
#[doc = "Bit 5 - Transmit data edge select"]
#[inline (always)] pub fn txedge (& mut self) -> TxedgeW < '_ , CctlSpec > { TxedgeW :: new (self , 5) }
#[doc = "Bit 6 - CPHA polarity select"]
#[inline (always)] pub fn cphasel (& mut self) -> CphaselW < '_ , CctlSpec > { CphaselW :: new (self , 6) }
#[doc = "Bit 7 - High speed slave mode"]
#[inline (always)] pub fn hispd (& mut self) -> HispdW < '_ , CctlSpec > { HispdW :: new (self , 7) } }
#[doc = "CCTL\n\nYou can [`read`](crate::Reg::read) this register and get [`cctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CctlSpec ; impl crate :: RegisterSpec for CctlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cctl::R`](R) reader structure"] impl crate :: Readable for CctlSpec { }
#[doc = "`write(|w| ..)` method takes [`cctl::W`](W) writer structure"] impl crate :: Writable for CctlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCTL to value 0x08"] impl crate :: Resettable for CctlSpec { const RESET_VALUE : u32 = 0x08 ; } }
#[doc = "SPBRG (rw) register accessor: SPBRG\n\nYou can [`read`](crate::Reg::read) this register and get [`spbrg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`spbrg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@spbrg`] module"]
#[doc (alias = "SPBRG")] pub type Spbrg = crate :: Reg < spbrg :: SpbrgSpec > ;
#[doc = "SPBRG"] pub mod spbrg {
#[doc = "Register `SPBRG` reader"] pub type R = crate :: R < SpbrgSpec > ;
#[doc = "Register `SPBRG` writer"] pub type W = crate :: W < SpbrgSpec > ;
#[doc = "Field `SPBRG` reader - SPI baud rate control register for baud rate"] pub type SpbrgR = crate :: FieldReader < u16 > ;
#[doc = "Field `SPBRG` writer - SPI baud rate control register for baud rate"] pub type SpbrgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - SPI baud rate control register for baud rate"]
#[inline (always)] pub fn spbrg (& self) -> SpbrgR { SpbrgR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - SPI baud rate control register for baud rate"]
#[inline (always)] pub fn spbrg (& mut self) -> SpbrgW < '_ , SpbrgSpec > { SpbrgW :: new (self , 0) } }
#[doc = "SPBRG\n\nYou can [`read`](crate::Reg::read) this register and get [`spbrg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`spbrg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SpbrgSpec ; impl crate :: RegisterSpec for SpbrgSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`spbrg::R`](R) reader structure"] impl crate :: Readable for SpbrgSpec { }
#[doc = "`write(|w| ..)` method takes [`spbrg::W`](W) writer structure"] impl crate :: Writable for SpbrgSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SPBRG to value 0x02"] impl crate :: Resettable for SpbrgSpec { const RESET_VALUE : u32 = 0x02 ; } }
#[doc = "RXDNR (rw) register accessor: RXDNR\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdnr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxdnr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxdnr`] module"]
#[doc (alias = "RXDNR")] pub type Rxdnr = crate :: Reg < rxdnr :: RxdnrSpec > ;
#[doc = "RXDNR"] pub mod rxdnr {
#[doc = "Register `RXDNR` reader"] pub type R = crate :: R < RxdnrSpec > ;
#[doc = "Register `RXDNR` writer"] pub type W = crate :: W < RxdnrSpec > ;
#[doc = "Field `RXDNR` reader - The register is used to hold a count of to be received bytes in next receive process"] pub type RxdnrR = crate :: FieldReader < u16 > ;
#[doc = "Field `RXDNR` writer - The register is used to hold a count of to be received bytes in next receive process"] pub type RxdnrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - The register is used to hold a count of to be received bytes in next receive process"]
#[inline (always)] pub fn rxdnr (& self) -> RxdnrR { RxdnrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - The register is used to hold a count of to be received bytes in next receive process"]
#[inline (always)] pub fn rxdnr (& mut self) -> RxdnrW < '_ , RxdnrSpec > { RxdnrW :: new (self , 0) } }
#[doc = "RXDNR\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdnr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxdnr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxdnrSpec ; impl crate :: RegisterSpec for RxdnrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rxdnr::R`](R) reader structure"] impl crate :: Readable for RxdnrSpec { }
#[doc = "`write(|w| ..)` method takes [`rxdnr::W`](W) writer structure"] impl crate :: Writable for RxdnrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RXDNR to value 0x01"] impl crate :: Resettable for RxdnrSpec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "NSSR (rw) register accessor: NSSR\n\nYou can [`read`](crate::Reg::read) this register and get [`nssr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`nssr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@nssr`] module"]
#[doc (alias = "NSSR")] pub type Nssr = crate :: Reg < nssr :: NssrSpec > ;
#[doc = "NSSR"] pub mod nssr {
#[doc = "Register `NSSR` reader"] pub type R = crate :: R < NssrSpec > ;
#[doc = "Register `NSSR` writer"] pub type W = crate :: W < NssrSpec > ;
#[doc = "Field `NSS` reader - Chip select output signal in Master mode"] pub type NssR = crate :: BitReader ;
#[doc = "Field `NSS` writer - Chip select output signal in Master mode"] pub type NssW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Chip select output signal in Master mode"]
#[inline (always)] pub fn nss (& self) -> NssR { NssR :: new ((self . bits & 1) != 0) } } impl W {
#[doc = "Bit 0 - Chip select output signal in Master mode"]
#[inline (always)] pub fn nss (& mut self) -> NssW < '_ , NssrSpec > { NssW :: new (self , 0) } }
#[doc = "NSSR\n\nYou can [`read`](crate::Reg::read) this register and get [`nssr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`nssr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct NssrSpec ; impl crate :: RegisterSpec for NssrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`nssr::R`](R) reader structure"] impl crate :: Readable for NssrSpec { }
#[doc = "`write(|w| ..)` method takes [`nssr::W`](W) writer structure"] impl crate :: Writable for NssrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets NSSR to value 0xff"] impl crate :: Resettable for NssrSpec { const RESET_VALUE : u32 = 0xff ; } }
#[doc = "EXTCTL (rw) register accessor: EXTCTL\n\nYou can [`read`](crate::Reg::read) this register and get [`extctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@extctl`] module"]
#[doc (alias = "EXTCTL")] pub type Extctl = crate :: Reg < extctl :: ExtctlSpec > ;
#[doc = "EXTCTL"] pub mod extctl {
#[doc = "Register `EXTCTL` reader"] pub type R = crate :: R < ExtctlSpec > ;
#[doc = "Register `EXTCTL` writer"] pub type W = crate :: W < ExtctlSpec > ;
#[doc = "Field `EXTLEN` reader - Control SPI data length"] pub type ExtlenR = crate :: FieldReader ;
#[doc = "Field `EXTLEN` writer - Control SPI data length"] pub type ExtlenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl R {
#[doc = "Bits 0:4 - Control SPI data length"]
#[inline (always)] pub fn extlen (& self) -> ExtlenR { ExtlenR :: new ((self . bits & 0x1f) as u8) } } impl W {
#[doc = "Bits 0:4 - Control SPI data length"]
#[inline (always)] pub fn extlen (& mut self) -> ExtlenW < '_ , ExtctlSpec > { ExtlenW :: new (self , 0) } }
#[doc = "EXTCTL\n\nYou can [`read`](crate::Reg::read) this register and get [`extctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`extctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ExtctlSpec ; impl crate :: RegisterSpec for ExtctlSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`extctl::R`](R) reader structure"] impl crate :: Readable for ExtctlSpec { }
#[doc = "`write(|w| ..)` method takes [`extctl::W`](W) writer structure"] impl crate :: Writable for ExtctlSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EXTCTL to value 0x08"] impl crate :: Resettable for ExtctlSpec { const RESET_VALUE : u32 = 0x08 ; } } }
#[doc = "Serial peripheral interface"] pub type Spi2 = crate :: Periph < spi1 :: RegisterBlock , 0x4000_3800 > ; impl core :: fmt :: Debug for Spi2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi2") . finish () } }
#[doc = "Serial peripheral interface"] pub use self :: spi1 as spi2 ;
#[doc = "Advanced timer"] pub type Tim1 = crate :: Periph < tim1 :: RegisterBlock , 0x4001_2c00 > ; impl core :: fmt :: Debug for Tim1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim1") . finish () } }
#[doc = "Advanced timer"] pub mod tim1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , smcr : Smcr , dier : Dier , sr : Sr , egr : Egr , _reserved_6_ccmr1 : [u8 ; 0x04] , _reserved_7_ccmr2 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , rcr : Rcr , ccr1 : Ccr1 , ccr2 : Ccr2 , ccr3 : Ccr3 , ccr4 : Ccr4 , bdtr : Bdtr , dcr : Dcr , dmar : Dmar , _reserved20 : [u8 ; 0x04] , ccmr3_output : Ccmr3Output , ccr5 : Ccr5 , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - slave mode control register 1"]
#[inline (always)] pub const fn smcr (& self) -> & Smcr { & self . smcr }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (input mode)"]
#[inline (always)] pub const fn ccmr2_input (& self) -> & Ccmr2Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - capture/compare mode register 2(output mode)"]
#[inline (always)] pub const fn ccmr2_output (& self) -> & Ccmr2Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x30 - repetition counter register"]
#[inline (always)] pub const fn rcr (& self) -> & Rcr { & self . rcr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x38 - capture/compare register 2"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x3c - capture/compare register 3"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x40 - capture/compare register 4"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x44 - break and dead-time register"]
#[inline (always)] pub const fn bdtr (& self) -> & Bdtr { & self . bdtr }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar }
#[doc = "0x54 - capture/compare mode register 3 (output mode)"]
#[inline (always)] pub const fn ccmr3_output (& self) -> & Ccmr3Output { & self . ccmr3_output }
#[doc = "0x58 - capture/compare register 5"]
#[inline (always)] pub const fn ccr5 (& self) -> & Ccr5 { & self . ccr5 } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMS` reader - Center-aligned mode selection"] pub type CmsR = crate :: FieldReader ;
#[doc = "Field `CMS` writer - Center-aligned mode selection"] pub type CmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& self) -> CmsR { CmsR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Cr1Spec > { DirW :: new (self , 4) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& mut self) -> CmsW < '_ , Cr1Spec > { CmsW :: new (self , 5) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCPC` reader - Capture/compare preloaded control"] pub type CcpcR = crate :: BitReader ;
#[doc = "Field `CCPC` writer - Capture/compare preloaded control"] pub type CcpcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCUS` reader - Capture/compare control update selection"] pub type CcusR = crate :: BitReader ;
#[doc = "Field `CCUS` writer - Capture/compare control update selection"] pub type CcusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCDS` reader - Capture/compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TI1S` reader - TI1 selection"] pub type Ti1sR = crate :: BitReader ;
#[doc = "Field `TI1S` writer - TI1 selection"] pub type Ti1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1` reader - Output Idle state 1"] pub type Ois1R = crate :: BitReader ;
#[doc = "Field `OIS1` writer - Output Idle state 1"] pub type Ois1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1N` reader - Output Idle state 1"] pub type Ois1nR = crate :: BitReader ;
#[doc = "Field `OIS1N` writer - Output Idle state 1"] pub type Ois1nW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS2` reader - OIS2"] pub type Ois2R = crate :: BitReader ;
#[doc = "Field `OIS2` writer - OIS2"] pub type Ois2W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS2N` reader - OIS2N"] pub type Ois2nR = crate :: BitReader ;
#[doc = "Field `OIS2N` writer - OIS2N"] pub type Ois2nW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS3` reader - OIS3"] pub type Ois3R = crate :: BitReader ;
#[doc = "Field `OIS3` writer - OIS3"] pub type Ois3W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS3N` reader - OIS3N"] pub type Ois3nR = crate :: BitReader ;
#[doc = "Field `OIS3N` writer - OIS3N"] pub type Ois3nW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS4` reader - OIS4"] pub type Ois4R = crate :: BitReader ;
#[doc = "Field `OIS4` writer - OIS4"] pub type Ois4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& self) -> CcpcR { CcpcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& self) -> CcusR { CcusR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& self) -> Ti1sR { Ti1sR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& self) -> Ois1R { Ois1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& self) -> Ois1nR { Ois1nR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - OIS2"]
#[inline (always)] pub fn ois2 (& self) -> Ois2R { Ois2R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - OIS2N"]
#[inline (always)] pub fn ois2n (& self) -> Ois2nR { Ois2nR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - OIS3"]
#[inline (always)] pub fn ois3 (& self) -> Ois3R { Ois3R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - OIS3N"]
#[inline (always)] pub fn ois3n (& self) -> Ois3nR { Ois3nR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - OIS4"]
#[inline (always)] pub fn ois4 (& self) -> Ois4R { Ois4R :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& mut self) -> CcpcW < '_ , Cr2Spec > { CcpcW :: new (self , 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& mut self) -> CcusW < '_ , Cr2Spec > { CcusW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& mut self) -> Ti1sW < '_ , Cr2Spec > { Ti1sW :: new (self , 7) }
#[doc = "Bit 8 - Output Idle state 1"]
#[inline (always)] pub fn ois1 (& mut self) -> Ois1W < '_ , Cr2Spec > { Ois1W :: new (self , 8) }
#[doc = "Bit 9 - Output Idle state 1"]
#[inline (always)] pub fn ois1n (& mut self) -> Ois1nW < '_ , Cr2Spec > { Ois1nW :: new (self , 9) }
#[doc = "Bit 10 - OIS2"]
#[inline (always)] pub fn ois2 (& mut self) -> Ois2W < '_ , Cr2Spec > { Ois2W :: new (self , 10) }
#[doc = "Bit 11 - OIS2N"]
#[inline (always)] pub fn ois2n (& mut self) -> Ois2nW < '_ , Cr2Spec > { Ois2nW :: new (self , 11) }
#[doc = "Bit 12 - OIS3"]
#[inline (always)] pub fn ois3 (& mut self) -> Ois3W < '_ , Cr2Spec > { Ois3W :: new (self , 12) }
#[doc = "Bit 13 - OIS3N"]
#[inline (always)] pub fn ois3n (& mut self) -> Ois3nW < '_ , Cr2Spec > { Ois3nW :: new (self , 13) }
#[doc = "Bit 14 - OIS4"]
#[inline (always)] pub fn ois4 (& mut self) -> Ois4W < '_ , Cr2Spec > { Ois4W :: new (self , 14) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMCR (rw) register accessor: slave mode control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smcr`] module"]
#[doc (alias = "SMCR")] pub type Smcr = crate :: Reg < smcr :: SmcrSpec > ;
#[doc = "slave mode control register 1"] pub mod smcr {
#[doc = "Register `SMCR` reader"] pub type R = crate :: R < SmcrSpec > ;
#[doc = "Register `SMCR` writer"] pub type W = crate :: W < SmcrSpec > ;
#[doc = "Field `SMS` reader - Slave mode selection"] pub type SmsR = crate :: FieldReader ;
#[doc = "Field `SMS` writer - Slave mode selection"] pub type SmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OCCS` reader - Output compare clear selection"] pub type OccsR = crate :: BitReader ;
#[doc = "Field `OCCS` writer - Output compare clear selection"] pub type OccsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TS` reader - Trigger selection"] pub type TsR = crate :: FieldReader ;
#[doc = "Field `TS` writer - Trigger selection"] pub type TsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSM` reader - Master/slave mode"] pub type MsmR = crate :: BitReader ;
#[doc = "Field `MSM` writer - Master/slave mode"] pub type MsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETF` reader - External trigger filter"] pub type EtfR = crate :: FieldReader ;
#[doc = "Field `ETF` writer - External trigger filter"] pub type EtfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ETPS` reader - External trigger prescaler"] pub type EtpsR = crate :: FieldReader ;
#[doc = "Field `ETPS` writer - External trigger prescaler"] pub type EtpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECE` reader - External clock enable"] pub type EceR = crate :: BitReader ;
#[doc = "Field `ECE` writer - External clock enable"] pub type EceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETP` reader - External trigger polarity"] pub type EtpR = crate :: BitReader ;
#[doc = "Field `ETP` writer - External trigger polarity"] pub type EtpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& self) -> SmsR { SmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - Output compare clear selection"]
#[inline (always)] pub fn occs (& self) -> OccsR { OccsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& self) -> TsR { TsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Master/slave mode"]
#[inline (always)] pub fn msm (& self) -> MsmR { MsmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& self) -> EtfR { EtfR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& self) -> EtpsR { EtpsR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& self) -> EceR { EceR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& self) -> EtpR { EtpR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& mut self) -> SmsW < '_ , SmcrSpec > { SmsW :: new (self , 0) }
#[doc = "Bit 3 - Output compare clear selection"]
#[inline (always)] pub fn occs (& mut self) -> OccsW < '_ , SmcrSpec > { OccsW :: new (self , 3) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& mut self) -> TsW < '_ , SmcrSpec > { TsW :: new (self , 4) }
#[doc = "Bit 7 - Master/slave mode"]
#[inline (always)] pub fn msm (& mut self) -> MsmW < '_ , SmcrSpec > { MsmW :: new (self , 7) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& mut self) -> EtfW < '_ , SmcrSpec > { EtfW :: new (self , 8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& mut self) -> EtpsW < '_ , SmcrSpec > { EtpsW :: new (self , 12) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& mut self) -> EceW < '_ , SmcrSpec > { EceW :: new (self , 14) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& mut self) -> EtpW < '_ , SmcrSpec > { EtpW :: new (self , 15) } }
#[doc = "slave mode control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SmcrSpec ; impl crate :: RegisterSpec for SmcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smcr::R`](R) reader structure"] impl crate :: Readable for SmcrSpec { }
#[doc = "`write(|w| ..)` method takes [`smcr::W`](W) writer structure"] impl crate :: Writable for SmcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMCR to value 0"] impl crate :: Resettable for SmcrSpec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IE` reader - Capture/Compare 2 interrupt enable"] pub type Cc2ieR = crate :: BitReader ;
#[doc = "Field `CC2IE` writer - Capture/Compare 2 interrupt enable"] pub type Cc2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IE` reader - Capture/Compare 3 interrupt enable"] pub type Cc3ieR = crate :: BitReader ;
#[doc = "Field `CC3IE` writer - Capture/Compare 3 interrupt enable"] pub type Cc3ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IE` reader - Capture/Compare 4 interrupt enable"] pub type Cc4ieR = crate :: BitReader ;
#[doc = "Field `CC4IE` writer - Capture/Compare 4 interrupt enable"] pub type Cc4ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIE` reader - COM interrupt enable"] pub type ComieR = crate :: BitReader ;
#[doc = "Field `COMIE` writer - COM interrupt enable"] pub type ComieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIE` reader - Trigger interrupt enable"] pub type TieR = crate :: BitReader ;
#[doc = "Field `TIE` writer - Trigger interrupt enable"] pub type TieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIE` reader - Break interrupt enable"] pub type BieR = crate :: BitReader ;
#[doc = "Field `BIE` writer - Break interrupt enable"] pub type BieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2DE` reader - Capture/Compare 2 DMA request enable"] pub type Cc2deR = crate :: BitReader ;
#[doc = "Field `CC2DE` writer - Capture/Compare 2 DMA request enable"] pub type Cc2deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3DE` reader - Capture/Compare 3 DMA request enable"] pub type Cc3deR = crate :: BitReader ;
#[doc = "Field `CC3DE` writer - Capture/Compare 3 DMA request enable"] pub type Cc3deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4DE` reader - Capture/Compare 4 DMA request enable"] pub type Cc4deR = crate :: BitReader ;
#[doc = "Field `CC4DE` writer - Capture/Compare 4 DMA request enable"] pub type Cc4deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMDE` reader - COM DMA request enable"] pub type ComdeR = crate :: BitReader ;
#[doc = "Field `COMDE` writer - COM DMA request enable"] pub type ComdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TDE` reader - Trigger DMA request enable"] pub type TdeR = crate :: BitReader ;
#[doc = "Field `TDE` writer - Trigger DMA request enable"] pub type TdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC5IE` reader - Capture/Compare 5 interrupt enable"] pub type Cc5ieR = crate :: BitReader ;
#[doc = "Field `CC5IE` writer - Capture/Compare 5 interrupt enable"] pub type Cc5ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC5DE` reader - Capture/Compare 5 DMA request enable"] pub type Cc5deR = crate :: BitReader ;
#[doc = "Field `CC5DE` writer - Capture/Compare 5 DMA request enable"] pub type Cc5deW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& self) -> Cc2ieR { Cc2ieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& self) -> Cc3ieR { Cc3ieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& self) -> Cc4ieR { Cc4ieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& self) -> ComieR { ComieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& self) -> TieR { TieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& self) -> BieR { BieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& self) -> Cc2deR { Cc2deR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& self) -> Cc3deR { Cc3deR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& self) -> Cc4deR { Cc4deR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - COM DMA request enable"]
#[inline (always)] pub fn comde (& self) -> ComdeR { ComdeR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& self) -> TdeR { TdeR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 16 - Capture/Compare 5 interrupt enable"]
#[inline (always)] pub fn cc5ie (& self) -> Cc5ieR { Cc5ieR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Capture/Compare 5 DMA request enable"]
#[inline (always)] pub fn cc5de (& self) -> Cc5deR { Cc5deR :: new (((self . bits >> 17) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& mut self) -> Cc2ieW < '_ , DierSpec > { Cc2ieW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& mut self) -> Cc3ieW < '_ , DierSpec > { Cc3ieW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& mut self) -> Cc4ieW < '_ , DierSpec > { Cc4ieW :: new (self , 4) }
#[doc = "Bit 5 - COM interrupt enable"]
#[inline (always)] pub fn comie (& mut self) -> ComieW < '_ , DierSpec > { ComieW :: new (self , 5) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& mut self) -> TieW < '_ , DierSpec > { TieW :: new (self , 6) }
#[doc = "Bit 7 - Break interrupt enable"]
#[inline (always)] pub fn bie (& mut self) -> BieW < '_ , DierSpec > { BieW :: new (self , 7) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& mut self) -> Cc2deW < '_ , DierSpec > { Cc2deW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& mut self) -> Cc3deW < '_ , DierSpec > { Cc3deW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& mut self) -> Cc4deW < '_ , DierSpec > { Cc4deW :: new (self , 12) }
#[doc = "Bit 13 - COM DMA request enable"]
#[inline (always)] pub fn comde (& mut self) -> ComdeW < '_ , DierSpec > { ComdeW :: new (self , 13) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& mut self) -> TdeW < '_ , DierSpec > { TdeW :: new (self , 14) }
#[doc = "Bit 16 - Capture/Compare 5 interrupt enable"]
#[inline (always)] pub fn cc5ie (& mut self) -> Cc5ieW < '_ , DierSpec > { Cc5ieW :: new (self , 16) }
#[doc = "Bit 17 - Capture/Compare 5 DMA request enable"]
#[inline (always)] pub fn cc5de (& mut self) -> Cc5deW < '_ , DierSpec > { Cc5deW :: new (self , 17) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/Compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/Compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IF` reader - Capture/Compare 2 interrupt flag"] pub type Cc2ifR = crate :: BitReader ;
#[doc = "Field `CC2IF` writer - Capture/Compare 2 interrupt flag"] pub type Cc2ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IF` reader - Capture/Compare 3 interrupt flag"] pub type Cc3ifR = crate :: BitReader ;
#[doc = "Field `CC3IF` writer - Capture/Compare 3 interrupt flag"] pub type Cc3ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IF` reader - Capture/Compare 4 interrupt flag"] pub type Cc4ifR = crate :: BitReader ;
#[doc = "Field `CC4IF` writer - Capture/Compare 4 interrupt flag"] pub type Cc4ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIF` reader - COM interrupt flag"] pub type ComifR = crate :: BitReader ;
#[doc = "Field `COMIF` writer - COM interrupt flag"] pub type ComifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIF` reader - Trigger interrupt flag"] pub type TifR = crate :: BitReader ;
#[doc = "Field `TIF` writer - Trigger interrupt flag"] pub type TifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIF` reader - Break interrupt flag"] pub type BifR = crate :: BitReader ;
#[doc = "Field `BIF` writer - Break interrupt flag"] pub type BifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2OF` reader - Capture/Compare 2 overcapture flag"] pub type Cc2ofR = crate :: BitReader ;
#[doc = "Field `CC2OF` writer - Capture/Compare 2 overcapture flag"] pub type Cc2ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3OF` reader - Capture/Compare 3 overcapture flag"] pub type Cc3ofR = crate :: BitReader ;
#[doc = "Field `CC3OF` writer - Capture/Compare 3 overcapture flag"] pub type Cc3ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4OF` reader - Capture/Compare 4 overcapture flag"] pub type Cc4ofR = crate :: BitReader ;
#[doc = "Field `CC4OF` writer - Capture/Compare 4 overcapture flag"] pub type Cc4ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC5IF` reader - Capture/Compare 5 interrupt flag"] pub type Cc5ifR = crate :: BitReader ;
#[doc = "Field `CC5IF` writer - Capture/Compare 5 interrupt flag"] pub type Cc5ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& self) -> Cc2ifR { Cc2ifR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& self) -> Cc3ifR { Cc3ifR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& self) -> Cc4ifR { Cc4ifR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& self) -> ComifR { ComifR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& self) -> TifR { TifR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& self) -> BifR { BifR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& self) -> Cc2ofR { Cc2ofR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& self) -> Cc3ofR { Cc3ofR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& self) -> Cc4ofR { Cc4ofR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 16 - Capture/Compare 5 interrupt flag"]
#[inline (always)] pub fn cc5if (& self) -> Cc5ifR { Cc5ifR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& mut self) -> Cc2ifW < '_ , SrSpec > { Cc2ifW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& mut self) -> Cc3ifW < '_ , SrSpec > { Cc3ifW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& mut self) -> Cc4ifW < '_ , SrSpec > { Cc4ifW :: new (self , 4) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& mut self) -> ComifW < '_ , SrSpec > { ComifW :: new (self , 5) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& mut self) -> TifW < '_ , SrSpec > { TifW :: new (self , 6) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& mut self) -> BifW < '_ , SrSpec > { BifW :: new (self , 7) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& mut self) -> Cc2ofW < '_ , SrSpec > { Cc2ofW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& mut self) -> Cc3ofW < '_ , SrSpec > { Cc3ofW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& mut self) -> Cc4ofW < '_ , SrSpec > { Cc4ofW :: new (self , 12) }
#[doc = "Bit 16 - Capture/Compare 5 interrupt flag"]
#[inline (always)] pub fn cc5if (& mut self) -> Cc5ifW < '_ , SrSpec > { Cc5ifW :: new (self , 16) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/Compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2G` writer - Capture/Compare 2 generation"] pub type Cc2gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3G` writer - Capture/Compare 3 generation"] pub type Cc3gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4G` writer - Capture/Compare 4 generation"] pub type Cc4gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMG` writer - Capture/Compare control update generation"] pub type ComgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TG` writer - Trigger generation"] pub type TgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BG` writer - Break generation"] pub type BgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC5G` writer - Capture/Compare 5 generation"] pub type Cc5gW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 generation"]
#[inline (always)] pub fn cc2g (& mut self) -> Cc2gW < '_ , EgrSpec > { Cc2gW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 generation"]
#[inline (always)] pub fn cc3g (& mut self) -> Cc3gW < '_ , EgrSpec > { Cc3gW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 generation"]
#[inline (always)] pub fn cc4g (& mut self) -> Cc4gW < '_ , EgrSpec > { Cc4gW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare control update generation"]
#[inline (always)] pub fn comg (& mut self) -> ComgW < '_ , EgrSpec > { ComgW :: new (self , 5) }
#[doc = "Bit 6 - Trigger generation"]
#[inline (always)] pub fn tg (& mut self) -> TgW < '_ , EgrSpec > { TgW :: new (self , 6) }
#[doc = "Bit 7 - Break generation"]
#[inline (always)] pub fn bg (& mut self) -> BgW < '_ , EgrSpec > { BgW :: new (self , 7) }
#[doc = "Bit 16 - Capture/Compare 5 generation"]
#[inline (always)] pub fn cc5g (& mut self) -> Cc5gW < '_ , EgrSpec > { Cc5gW :: new (self , 16) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 2 output enable"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 2 output enable"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC1CE` reader - Output compare 1 clear enable"] pub type Oc1ceR = crate :: BitReader ;
#[doc = "Field `OC1CE` writer - Output compare 1 clear enable"] pub type Oc1ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2S` reader - Capure/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capure/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC2FE` reader - Output compare 4 fast enable"] pub type Oc2feR = crate :: BitReader ;
#[doc = "Field `OC2FE` writer - Output compare 4 fast enable"] pub type Oc2feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2PE` reader - Output compare 2 preload enable"] pub type Oc2peR = crate :: BitReader ;
#[doc = "Field `OC2PE` writer - Output compare 2 preload enable"] pub type Oc2peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M` reader - Output compare 2 mode"] pub type Oc2mR = crate :: FieldReader ;
#[doc = "Field `OC2M` writer - Output compare 2 mode"] pub type Oc2mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC2CE` reader - Output compare 2 clear enable"] pub type Oc2ceR = crate :: BitReader ;
#[doc = "Field `OC2CE` writer - Output compare 2 clear enable"] pub type Oc2ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& self) -> Oc1ceR { Oc1ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capure/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc2fe (& self) -> Oc2feR { Oc2feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& self) -> Oc2peR { Oc2peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& self) -> Oc2mR { Oc2mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& self) -> Oc2ceR { Oc2ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& mut self) -> Oc1ceW < '_ , Ccmr1OutputSpec > { Oc1ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capure/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1OutputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc2fe (& mut self) -> Oc2feW < '_ , Ccmr1OutputSpec > { Oc2feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& mut self) -> Oc2peW < '_ , Ccmr1OutputSpec > { Oc2peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& mut self) -> Oc2mW < '_ , Ccmr1OutputSpec > { Oc2mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& mut self) -> Oc2ceW < '_ , Ccmr1OutputSpec > { Oc2ceW :: new (self , 15) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2PSC` reader - Input capture 2 prescaler"] pub type Ic2pscR = crate :: FieldReader ;
#[doc = "Field `IC2PSC` writer - Input capture 2 prescaler"] pub type Ic2pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2F` reader - Input capture 2 filter"] pub type Ic2fR = crate :: FieldReader ;
#[doc = "Field `IC2F` writer - Input capture 2 filter"] pub type Ic2fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& self) -> Ic2pscR { Ic2pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& self) -> Ic2fR { Ic2fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1InputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& mut self) -> Ic2pscW < '_ , Ccmr1InputSpec > { Ic2pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& mut self) -> Ic2fW < '_ , Ccmr1InputSpec > { Ic2fW :: new (self , 12) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCMR2_Output (rw) register accessor: capture/compare mode register 2(output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_output`] module"]
#[doc (alias = "CCMR2_Output")] pub type Ccmr2Output = crate :: Reg < ccmr2_output :: Ccmr2OutputSpec > ;
#[doc = "capture/compare mode register 2(output mode)"] pub mod ccmr2_output {
#[doc = "Register `CCMR2_Output` reader"] pub type R = crate :: R < Ccmr2OutputSpec > ;
#[doc = "Register `CCMR2_Output` writer"] pub type W = crate :: W < Ccmr2OutputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC3FE` reader - Output compare 3 fast enable"] pub type Oc3feR = crate :: BitReader ;
#[doc = "Field `OC3FE` writer - Output compare 3 fast enable"] pub type Oc3feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3PE` reader - Output compare 3 preload enable"] pub type Oc3peR = crate :: BitReader ;
#[doc = "Field `OC3PE` writer - Output compare 3 preload enable"] pub type Oc3peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3M` reader - Output compare 3 mode"] pub type Oc3mR = crate :: FieldReader ;
#[doc = "Field `OC3M` writer - Output compare 3 mode"] pub type Oc3mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC3CE` reader - Output compare 3 clear enable"] pub type Oc3ceR = crate :: BitReader ;
#[doc = "Field `OC3CE` writer - Output compare 3 clear enable"] pub type Oc3ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC4FE` reader - Output compare 4 fast enable"] pub type Oc4feR = crate :: BitReader ;
#[doc = "Field `OC4FE` writer - Output compare 4 fast enable"] pub type Oc4feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4PE` reader - Output compare 4 preload enable"] pub type Oc4peR = crate :: BitReader ;
#[doc = "Field `OC4PE` writer - Output compare 4 preload enable"] pub type Oc4peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4M` reader - Output compare 4 mode"] pub type Oc4mR = crate :: FieldReader ;
#[doc = "Field `OC4M` writer - Output compare 4 mode"] pub type Oc4mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC4CE` reader - Output compare 4 clear enable"] pub type Oc4ceR = crate :: BitReader ;
#[doc = "Field `OC4CE` writer - Output compare 4 clear enable"] pub type Oc4ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& self) -> Oc3feR { Oc3feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& self) -> Oc3peR { Oc3peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& self) -> Oc3mR { Oc3mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& self) -> Oc3ceR { Oc3ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& self) -> Oc4feR { Oc4feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& self) -> Oc4peR { Oc4peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& self) -> Oc4mR { Oc4mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& self) -> Oc4ceR { Oc4ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2OutputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& mut self) -> Oc3feW < '_ , Ccmr2OutputSpec > { Oc3feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& mut self) -> Oc3peW < '_ , Ccmr2OutputSpec > { Oc3peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& mut self) -> Oc3mW < '_ , Ccmr2OutputSpec > { Oc3mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& mut self) -> Oc3ceW < '_ , Ccmr2OutputSpec > { Oc3ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2OutputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& mut self) -> Oc4feW < '_ , Ccmr2OutputSpec > { Oc4feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& mut self) -> Oc4peW < '_ , Ccmr2OutputSpec > { Oc4peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& mut self) -> Oc4mW < '_ , Ccmr2OutputSpec > { Oc4mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& mut self) -> Oc4ceW < '_ , Ccmr2OutputSpec > { Oc4ceW :: new (self , 15) } }
#[doc = "capture/compare mode register 2(output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2OutputSpec ; impl crate :: RegisterSpec for Ccmr2OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_output::R`](R) reader structure"] impl crate :: Readable for Ccmr2OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_output::W`](W) writer structure"] impl crate :: Writable for Ccmr2OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Output to value 0"] impl crate :: Resettable for Ccmr2OutputSpec { } }
#[doc = "CCMR2_Input (rw) register accessor: capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_input`] module"]
#[doc (alias = "CCMR2_Input")] pub type Ccmr2Input = crate :: Reg < ccmr2_input :: Ccmr2InputSpec > ;
#[doc = "capture/compare mode register 2 (input mode)"] pub mod ccmr2_input {
#[doc = "Register `CCMR2_Input` reader"] pub type R = crate :: R < Ccmr2InputSpec > ;
#[doc = "Register `CCMR2_Input` writer"] pub type W = crate :: W < Ccmr2InputSpec > ;
#[doc = "Field `CC3S` reader - Capture/compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3PSC` reader - Input capture 3 prescaler"] pub type Ic3pscR = crate :: FieldReader ;
#[doc = "Field `IC3PSC` writer - Input capture 3 prescaler"] pub type Ic3pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3F` reader - Input capture 3 filter"] pub type Ic3fR = crate :: FieldReader ;
#[doc = "Field `IC3F` writer - Input capture 3 filter"] pub type Ic3fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4PSC` reader - Input capture 4 prescaler"] pub type Ic4pscR = crate :: FieldReader ;
#[doc = "Field `IC4PSC` writer - Input capture 4 prescaler"] pub type Ic4pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4F` reader - Input capture 4 filter"] pub type Ic4fR = crate :: FieldReader ;
#[doc = "Field `IC4F` writer - Input capture 4 filter"] pub type Ic4fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& self) -> Ic3pscR { Ic3pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& self) -> Ic3fR { Ic3fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& self) -> Ic4pscR { Ic4pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& self) -> Ic4fR { Ic4fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2InputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& mut self) -> Ic3pscW < '_ , Ccmr2InputSpec > { Ic3pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& mut self) -> Ic3fW < '_ , Ccmr2InputSpec > { Ic3fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2InputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& mut self) -> Ic4pscW < '_ , Ccmr2InputSpec > { Ic4pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& mut self) -> Ic4fW < '_ , Ccmr2InputSpec > { Ic4fW :: new (self , 12) } }
#[doc = "capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2InputSpec ; impl crate :: RegisterSpec for Ccmr2InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_input::R`](R) reader structure"] impl crate :: Readable for Ccmr2InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_input::W`](W) writer structure"] impl crate :: Writable for Ccmr2InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Input to value 0"] impl crate :: Resettable for Ccmr2InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NE` reader - Capture/Compare 1 complementary output enable"] pub type Cc1neR = crate :: BitReader ;
#[doc = "Field `CC1NE` writer - Capture/Compare 1 complementary output enable"] pub type Cc1neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 complementary output polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 complementary output polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2E` reader - Capture/Compare 2 output enable"] pub type Cc2eR = crate :: BitReader ;
#[doc = "Field `CC2E` writer - Capture/Compare 2 output enable"] pub type Cc2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2P` reader - Capture/Compare 2 output polarity"] pub type Cc2pR = crate :: BitReader ;
#[doc = "Field `CC2P` writer - Capture/Compare 2 output polarity"] pub type Cc2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2NE` reader - Capture/Compare 2 complementary output enable"] pub type Cc2neR = crate :: BitReader ;
#[doc = "Field `CC2NE` writer - Capture/Compare 2 complementary output enable"] pub type Cc2neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2NP` reader - Capture/Compare 2 complementary output polarity"] pub type Cc2npR = crate :: BitReader ;
#[doc = "Field `CC2NP` writer - Capture/Compare 2 complementary output polarity"] pub type Cc2npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3E` reader - Capture/Compare 3 output enable"] pub type Cc3eR = crate :: BitReader ;
#[doc = "Field `CC3E` writer - Capture/Compare 3 output enable"] pub type Cc3eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3P` reader - Capture/Compare 3 output polarity"] pub type Cc3pR = crate :: BitReader ;
#[doc = "Field `CC3P` writer - Capture/Compare 3 output polarity"] pub type Cc3pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3NE` reader - Capture/Compare 3 complementary output enable"] pub type Cc3neR = crate :: BitReader ;
#[doc = "Field `CC3NE` writer - Capture/Compare 3 complementary output enable"] pub type Cc3neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3NP` reader - Capture/Compare 3 complementary output polarity"] pub type Cc3npR = crate :: BitReader ;
#[doc = "Field `CC3NP` writer - Capture/Compare 3 complementary output polarity"] pub type Cc3npW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4E` reader - Capture/Compare 4 output enable"] pub type Cc4eR = crate :: BitReader ;
#[doc = "Field `CC4E` writer - Capture/Compare 4 output enable"] pub type Cc4eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4P` reader - Capture/Compare 4 output polarity"] pub type Cc4pR = crate :: BitReader ;
#[doc = "Field `CC4P` writer - Capture/Compare 4 output polarity"] pub type Cc4pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC5E` reader - Capture/Compare 5 output enable"] pub type Cc5eR = crate :: BitReader ;
#[doc = "Field `CC5E` writer - Capture/Compare 5 output enable"] pub type Cc5eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC5P` reader - Capture/Compare 5 output polarity"] pub type Cc5pR = crate :: BitReader ;
#[doc = "Field `CC5P` writer - Capture/Compare 5 output polarity"] pub type Cc5pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& self) -> Cc1neR { Cc1neR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 complementary output polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& self) -> Cc2eR { Cc2eR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Capture/Compare 2 output polarity"]
#[inline (always)] pub fn cc2p (& self) -> Cc2pR { Cc2pR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
#[inline (always)] pub fn cc2ne (& self) -> Cc2neR { Cc2neR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Capture/Compare 2 complementary output polarity"]
#[inline (always)] pub fn cc2np (& self) -> Cc2npR { Cc2npR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& self) -> Cc3eR { Cc3eR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 3 output polarity"]
#[inline (always)] pub fn cc3p (& self) -> Cc3pR { Cc3pR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
#[inline (always)] pub fn cc3ne (& self) -> Cc3neR { Cc3neR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 complementary output polarity"]
#[inline (always)] pub fn cc3np (& self) -> Cc3npR { Cc3npR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& self) -> Cc4eR { Cc4eR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Capture/Compare 4 output polarity"]
#[inline (always)] pub fn cc4p (& self) -> Cc4pR { Cc4pR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 16 - Capture/Compare 5 output enable"]
#[inline (always)] pub fn cc5e (& self) -> Cc5eR { Cc5eR :: new (((self . bits >> 16) & 1) != 0) }
#[doc = "Bit 17 - Capture/Compare 5 output polarity"]
#[inline (always)] pub fn cc5p (& self) -> Cc5pR { Cc5pR :: new (((self . bits >> 17) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& mut self) -> Cc1neW < '_ , CcerSpec > { Cc1neW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 1 complementary output polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& mut self) -> Cc2eW < '_ , CcerSpec > { Cc2eW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare 2 output polarity"]
#[inline (always)] pub fn cc2p (& mut self) -> Cc2pW < '_ , CcerSpec > { Cc2pW :: new (self , 5) }
#[doc = "Bit 6 - Capture/Compare 2 complementary output enable"]
#[inline (always)] pub fn cc2ne (& mut self) -> Cc2neW < '_ , CcerSpec > { Cc2neW :: new (self , 6) }
#[doc = "Bit 7 - Capture/Compare 2 complementary output polarity"]
#[inline (always)] pub fn cc2np (& mut self) -> Cc2npW < '_ , CcerSpec > { Cc2npW :: new (self , 7) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& mut self) -> Cc3eW < '_ , CcerSpec > { Cc3eW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 3 output polarity"]
#[inline (always)] pub fn cc3p (& mut self) -> Cc3pW < '_ , CcerSpec > { Cc3pW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 3 complementary output enable"]
#[inline (always)] pub fn cc3ne (& mut self) -> Cc3neW < '_ , CcerSpec > { Cc3neW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 complementary output polarity"]
#[inline (always)] pub fn cc3np (& mut self) -> Cc3npW < '_ , CcerSpec > { Cc3npW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& mut self) -> Cc4eW < '_ , CcerSpec > { Cc4eW :: new (self , 12) }
#[doc = "Bit 13 - Capture/Compare 4 output polarity"]
#[inline (always)] pub fn cc4p (& mut self) -> Cc4pW < '_ , CcerSpec > { Cc4pW :: new (self , 13) }
#[doc = "Bit 16 - Capture/Compare 5 output enable"]
#[inline (always)] pub fn cc5e (& mut self) -> Cc5eW < '_ , CcerSpec > { Cc5eW :: new (self , 16) }
#[doc = "Bit 17 - Capture/Compare 5 output polarity"]
#[inline (always)] pub fn cc5p (& mut self) -> Cc5pW < '_ , CcerSpec > { Cc5pW :: new (self , 17) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - Counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "RCR (rw) register accessor: repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rcr`] module"]
#[doc (alias = "RCR")] pub type Rcr = crate :: Reg < rcr :: RcrSpec > ;
#[doc = "repetition counter register"] pub mod rcr {
#[doc = "Register `RCR` reader"] pub type R = crate :: R < RcrSpec > ;
#[doc = "Register `RCR` writer"] pub type W = crate :: W < RcrSpec > ;
#[doc = "Field `REP` reader - Repetition counter value"] pub type RepR = crate :: FieldReader ;
#[doc = "Field `REP` writer - Repetition counter value"] pub type RepW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& self) -> RepR { RepR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& mut self) -> RepW < '_ , RcrSpec > { RepW :: new (self , 0) } }
#[doc = "repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RcrSpec ; impl crate :: RegisterSpec for RcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rcr::R`](R) reader structure"] impl crate :: Readable for RcrSpec { }
#[doc = "`write(|w| ..)` method takes [`rcr::W`](W) writer structure"] impl crate :: Writable for RcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RCR to value 0"] impl crate :: Resettable for RcrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CCR2 (rw) register accessor: capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "capture/compare register 2"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `CCR2` reader - Capture/Compare 2 value"] pub type Ccr2R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR2` writer - Capture/Compare 2 value"] pub type Ccr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& self) -> Ccr2R { Ccr2R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& mut self) -> Ccr2W < '_ , Ccr2Spec > { Ccr2W :: new (self , 0) } }
#[doc = "capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CCR3 (rw) register accessor: capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "capture/compare register 3"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `CCR3` reader - Capture/Compare 3 value"] pub type Ccr3R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR3` writer - Capture/Compare 3 value"] pub type Ccr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 3 value"]
#[inline (always)] pub fn ccr3 (& self) -> Ccr3R { Ccr3R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 3 value"]
#[inline (always)] pub fn ccr3 (& mut self) -> Ccr3W < '_ , Ccr3Spec > { Ccr3W :: new (self , 0) } }
#[doc = "capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CCR4 (rw) register accessor: capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "capture/compare register 4"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `CCR4` reader - Capture/Compare 4 value"] pub type Ccr4R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR4` writer - Capture/Compare 4 value"] pub type Ccr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 4 value"]
#[inline (always)] pub fn ccr4 (& self) -> Ccr4R { Ccr4R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 4 value"]
#[inline (always)] pub fn ccr4 (& mut self) -> Ccr4W < '_ , Ccr4Spec > { Ccr4W :: new (self , 0) } }
#[doc = "capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "BDTR (rw) register accessor: break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bdtr`] module"]
#[doc (alias = "BDTR")] pub type Bdtr = crate :: Reg < bdtr :: BdtrSpec > ;
#[doc = "break and dead-time register"] pub mod bdtr {
#[doc = "Register `BDTR` reader"] pub type R = crate :: R < BdtrSpec > ;
#[doc = "Register `BDTR` writer"] pub type W = crate :: W < BdtrSpec > ;
#[doc = "Field `DTG` reader - Dead-time generator setup"] pub type DtgR = crate :: FieldReader ;
#[doc = "Field `DTG` writer - Dead-time generator setup"] pub type DtgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `LOCK` reader - Lock configuration"] pub type LockR = crate :: FieldReader ;
#[doc = "Field `LOCK` writer - Lock configuration"] pub type LockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSSI` reader - Off-state selection for Idle mode"] pub type OssiR = crate :: BitReader ;
#[doc = "Field `OSSI` writer - Off-state selection for Idle mode"] pub type OssiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSSR` reader - Off-state selection for Run mode"] pub type OssrR = crate :: BitReader ;
#[doc = "Field `OSSR` writer - Off-state selection for Run mode"] pub type OssrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKE` reader - Break enable"] pub type BkeR = crate :: BitReader ;
#[doc = "Field `BKE` writer - Break enable"] pub type BkeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKP` reader - Break polarity"] pub type BkpR = crate :: BitReader ;
#[doc = "Field `BKP` writer - Break polarity"] pub type BkpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AOE` reader - Automatic output enable"] pub type AoeR = crate :: BitReader ;
#[doc = "Field `AOE` writer - Automatic output enable"] pub type AoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MOE` reader - Main output enable"] pub type MoeR = crate :: BitReader ;
#[doc = "Field `MOE` writer - Main output enable"] pub type MoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DOE` reader - Direct output enable"] pub type DoeR = crate :: BitReader ;
#[doc = "Field `DOE` writer - Direct output enable"] pub type DoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& self) -> DtgR { DtgR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& self) -> OssiR { OssiR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& self) -> OssrR { OssrR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& self) -> BkeR { BkeR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& self) -> AoeR { AoeR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& self) -> MoeR { MoeR :: new (((self . bits >> 15) & 1) != 0) }
#[doc = "Bit 16 - Direct output enable"]
#[inline (always)] pub fn doe (& self) -> DoeR { DoeR :: new (((self . bits >> 16) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Dead-time generator setup"]
#[inline (always)] pub fn dtg (& mut self) -> DtgW < '_ , BdtrSpec > { DtgW :: new (self , 0) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , BdtrSpec > { LockW :: new (self , 8) }
#[doc = "Bit 10 - Off-state selection for Idle mode"]
#[inline (always)] pub fn ossi (& mut self) -> OssiW < '_ , BdtrSpec > { OssiW :: new (self , 10) }
#[doc = "Bit 11 - Off-state selection for Run mode"]
#[inline (always)] pub fn ossr (& mut self) -> OssrW < '_ , BdtrSpec > { OssrW :: new (self , 11) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& mut self) -> BkeW < '_ , BdtrSpec > { BkeW :: new (self , 12) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , BdtrSpec > { BkpW :: new (self , 13) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& mut self) -> AoeW < '_ , BdtrSpec > { AoeW :: new (self , 14) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& mut self) -> MoeW < '_ , BdtrSpec > { MoeW :: new (self , 15) }
#[doc = "Bit 16 - Direct output enable"]
#[inline (always)] pub fn doe (& mut self) -> DoeW < '_ , BdtrSpec > { DoeW :: new (self , 16) } }
#[doc = "break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdtrSpec ; impl crate :: RegisterSpec for BdtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bdtr::R`](R) reader structure"] impl crate :: Readable for BdtrSpec { }
#[doc = "`write(|w| ..)` method takes [`bdtr::W`](W) writer structure"] impl crate :: Writable for BdtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BDTR to value 0"] impl crate :: Resettable for BdtrSpec { } }
#[doc = "DCR (w) register accessor: DMA control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (w) register accessor: DMA address for full transfer\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } }
#[doc = "CCMR3_Output (rw) register accessor: capture/compare mode register 3 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr3_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr3_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr3_output`] module"]
#[doc (alias = "CCMR3_Output")] pub type Ccmr3Output = crate :: Reg < ccmr3_output :: Ccmr3OutputSpec > ;
#[doc = "capture/compare mode register 3 (output mode)"] pub mod ccmr3_output {
#[doc = "Register `CCMR3_Output` reader"] pub type R = crate :: R < Ccmr3OutputSpec > ;
#[doc = "Register `CCMR3_Output` writer"] pub type W = crate :: W < Ccmr3OutputSpec > ;
#[doc = "Field `OC5FE` reader - Output compare 5 fast enable"] pub type Oc5feR = crate :: BitReader ;
#[doc = "Field `OC5FE` writer - Output compare 5 fast enable"] pub type Oc5feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC5PE` reader - Output compare 5 preload enable"] pub type Oc5peR = crate :: BitReader ;
#[doc = "Field `OC5PE` writer - Output compare 5 preload enable"] pub type Oc5peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC5M` reader - Output compare 5 mode"] pub type Oc5mR = crate :: FieldReader ;
#[doc = "Field `OC5M` writer - Output compare 5 mode"] pub type Oc5mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC5CE` reader - Output compare 5 clear enable"] pub type Oc5ceR = crate :: BitReader ;
#[doc = "Field `OC5CE` writer - Output compare 5 clear enable"] pub type Oc5ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - Output compare 5 fast enable"]
#[inline (always)] pub fn oc5fe (& self) -> Oc5feR { Oc5feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 5 preload enable"]
#[inline (always)] pub fn oc5pe (& self) -> Oc5peR { Oc5peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 5 mode"]
#[inline (always)] pub fn oc5m (& self) -> Oc5mR { Oc5mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 5 clear enable"]
#[inline (always)] pub fn oc5ce (& self) -> Oc5ceR { Oc5ceR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 2 - Output compare 5 fast enable"]
#[inline (always)] pub fn oc5fe (& mut self) -> Oc5feW < '_ , Ccmr3OutputSpec > { Oc5feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 5 preload enable"]
#[inline (always)] pub fn oc5pe (& mut self) -> Oc5peW < '_ , Ccmr3OutputSpec > { Oc5peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 5 mode"]
#[inline (always)] pub fn oc5m (& mut self) -> Oc5mW < '_ , Ccmr3OutputSpec > { Oc5mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 5 clear enable"]
#[inline (always)] pub fn oc5ce (& mut self) -> Oc5ceW < '_ , Ccmr3OutputSpec > { Oc5ceW :: new (self , 7) } }
#[doc = "capture/compare mode register 3 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr3_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr3_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr3OutputSpec ; impl crate :: RegisterSpec for Ccmr3OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr3_output::R`](R) reader structure"] impl crate :: Readable for Ccmr3OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr3_output::W`](W) writer structure"] impl crate :: Writable for Ccmr3OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR3_Output to value 0"] impl crate :: Resettable for Ccmr3OutputSpec { } }
#[doc = "CCR5 (rw) register accessor: capture/compare register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr5`] module"]
#[doc (alias = "CCR5")] pub type Ccr5 = crate :: Reg < ccr5 :: Ccr5Spec > ;
#[doc = "capture/compare register 5"] pub mod ccr5 {
#[doc = "Register `CCR5` reader"] pub type R = crate :: R < Ccr5Spec > ;
#[doc = "Register `CCR5` writer"] pub type W = crate :: W < Ccr5Spec > ;
#[doc = "Field `CCR5` reader - Capture/Compare 5 value"] pub type Ccr5R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR5` writer - Capture/Compare 5 value"] pub type Ccr5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 5 value"]
#[inline (always)] pub fn ccr5 (& self) -> Ccr5R { Ccr5R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 5 value"]
#[inline (always)] pub fn ccr5 (& mut self) -> Ccr5W < '_ , Ccr5Spec > { Ccr5W :: new (self , 0) } }
#[doc = "capture/compare register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr5Spec ; impl crate :: RegisterSpec for Ccr5Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr5::R`](R) reader structure"] impl crate :: Readable for Ccr5Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr5::W`](W) writer structure"] impl crate :: Writable for Ccr5Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR5 to value 0"] impl crate :: Resettable for Ccr5Spec { } } }
#[doc = "General purpose timer"] pub type Tim2 = crate :: Periph < tim2 :: RegisterBlock , 0x4000_0000 > ; impl core :: fmt :: Debug for Tim2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim2") . finish () } }
#[doc = "General purpose timer"] pub mod tim2 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , smcr : Smcr , dier : Dier , sr : Sr , egr : Egr , _reserved_6_ccmr1 : [u8 ; 0x04] , _reserved_7_ccmr2 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , _reserved12 : [u8 ; 0x04] , ccr1 : Ccr1 , ccr2 : Ccr2 , ccr3 : Ccr3 , ccr4 : Ccr4 , _reserved16 : [u8 ; 0x04] , dcr : Dcr , dmar : Dmar , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - slave mode control register 1"]
#[inline (always)] pub const fn smcr (& self) -> & Smcr { & self . smcr }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (input mode)"]
#[inline (always)] pub const fn ccmr2_input (& self) -> & Ccmr2Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - capture/compare mode register 2(output mode)"]
#[inline (always)] pub const fn ccmr2_output (& self) -> & Ccmr2Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x38 - capture/compare register 2"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x3c - capture/compare register 3"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x40 - capture/compare register 4"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMS` reader - Center-aligned mode selection"] pub type CmsR = crate :: FieldReader ;
#[doc = "Field `CMS` writer - Center-aligned mode selection"] pub type CmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& self) -> CmsR { CmsR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Cr1Spec > { DirW :: new (self , 4) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& mut self) -> CmsW < '_ , Cr1Spec > { CmsW :: new (self , 5) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCDS` reader - Capture/Compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/Compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TI1S` reader - TI1 selection"] pub type Ti1sR = crate :: BitReader ;
#[doc = "Field `TI1S` writer - TI1 selection"] pub type Ti1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - Capture/Compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& self) -> Ti1sR { Ti1sR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 3 - Capture/Compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& mut self) -> Ti1sW < '_ , Cr2Spec > { Ti1sW :: new (self , 7) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMCR (rw) register accessor: slave mode control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smcr`] module"]
#[doc (alias = "SMCR")] pub type Smcr = crate :: Reg < smcr :: SmcrSpec > ;
#[doc = "slave mode control register 1"] pub mod smcr {
#[doc = "Register `SMCR` reader"] pub type R = crate :: R < SmcrSpec > ;
#[doc = "Register `SMCR` writer"] pub type W = crate :: W < SmcrSpec > ;
#[doc = "Field `SMS` reader - Slave mode selection"] pub type SmsR = crate :: FieldReader ;
#[doc = "Field `SMS` writer - Slave mode selection"] pub type SmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OCCS` reader - Output compare clear selection"] pub type OccsR = crate :: BitReader ;
#[doc = "Field `OCCS` writer - Output compare clear selection"] pub type OccsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TS` reader - Trigger selection"] pub type TsR = crate :: FieldReader ;
#[doc = "Field `TS` writer - Trigger selection"] pub type TsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSM` reader - Master/slave mode"] pub type MsmR = crate :: BitReader ;
#[doc = "Field `MSM` writer - Master/slave mode"] pub type MsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETF` reader - External trigger filter"] pub type EtfR = crate :: FieldReader ;
#[doc = "Field `ETF` writer - External trigger filter"] pub type EtfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ETPS` reader - External trigger prescaler"] pub type EtpsR = crate :: FieldReader ;
#[doc = "Field `ETPS` writer - External trigger prescaler"] pub type EtpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECE` reader - External clock enable"] pub type EceR = crate :: BitReader ;
#[doc = "Field `ECE` writer - External clock enable"] pub type EceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETP` reader - External trigger polarity"] pub type EtpR = crate :: BitReader ;
#[doc = "Field `ETP` writer - External trigger polarity"] pub type EtpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& self) -> SmsR { SmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - Output compare clear selection"]
#[inline (always)] pub fn occs (& self) -> OccsR { OccsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& self) -> TsR { TsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Master/slave mode"]
#[inline (always)] pub fn msm (& self) -> MsmR { MsmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& self) -> EtfR { EtfR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& self) -> EtpsR { EtpsR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& self) -> EceR { EceR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& self) -> EtpR { EtpR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& mut self) -> SmsW < '_ , SmcrSpec > { SmsW :: new (self , 0) }
#[doc = "Bit 3 - Output compare clear selection"]
#[inline (always)] pub fn occs (& mut self) -> OccsW < '_ , SmcrSpec > { OccsW :: new (self , 3) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& mut self) -> TsW < '_ , SmcrSpec > { TsW :: new (self , 4) }
#[doc = "Bit 7 - Master/slave mode"]
#[inline (always)] pub fn msm (& mut self) -> MsmW < '_ , SmcrSpec > { MsmW :: new (self , 7) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& mut self) -> EtfW < '_ , SmcrSpec > { EtfW :: new (self , 8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& mut self) -> EtpsW < '_ , SmcrSpec > { EtpsW :: new (self , 12) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& mut self) -> EceW < '_ , SmcrSpec > { EceW :: new (self , 14) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& mut self) -> EtpW < '_ , SmcrSpec > { EtpW :: new (self , 15) } }
#[doc = "slave mode control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SmcrSpec ; impl crate :: RegisterSpec for SmcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smcr::R`](R) reader structure"] impl crate :: Readable for SmcrSpec { }
#[doc = "`write(|w| ..)` method takes [`smcr::W`](W) writer structure"] impl crate :: Writable for SmcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMCR to value 0"] impl crate :: Resettable for SmcrSpec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IE` reader - Capture/Compare 2 interrupt enable"] pub type Cc2ieR = crate :: BitReader ;
#[doc = "Field `CC2IE` writer - Capture/Compare 2 interrupt enable"] pub type Cc2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IE` reader - Capture/Compare 3 interrupt enable"] pub type Cc3ieR = crate :: BitReader ;
#[doc = "Field `CC3IE` writer - Capture/Compare 3 interrupt enable"] pub type Cc3ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IE` reader - Capture/Compare 4 interrupt enable"] pub type Cc4ieR = crate :: BitReader ;
#[doc = "Field `CC4IE` writer - Capture/Compare 4 interrupt enable"] pub type Cc4ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIE` reader - Trigger interrupt enable"] pub type TieR = crate :: BitReader ;
#[doc = "Field `TIE` writer - Trigger interrupt enable"] pub type TieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2DE` reader - Capture/Compare 2 DMA request enable"] pub type Cc2deR = crate :: BitReader ;
#[doc = "Field `CC2DE` writer - Capture/Compare 2 DMA request enable"] pub type Cc2deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3DE` reader - Capture/Compare 3 DMA request enable"] pub type Cc3deR = crate :: BitReader ;
#[doc = "Field `CC3DE` writer - Capture/Compare 3 DMA request enable"] pub type Cc3deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4DE` reader - Capture/Compare 4 DMA request enable"] pub type Cc4deR = crate :: BitReader ;
#[doc = "Field `CC4DE` writer - Capture/Compare 4 DMA request enable"] pub type Cc4deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TDE` reader - Trigger DMA request enable"] pub type TdeR = crate :: BitReader ;
#[doc = "Field `TDE` writer - Trigger DMA request enable"] pub type TdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& self) -> Cc2ieR { Cc2ieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& self) -> Cc3ieR { Cc3ieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& self) -> Cc4ieR { Cc4ieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& self) -> TieR { TieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& self) -> Cc2deR { Cc2deR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& self) -> Cc3deR { Cc3deR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& self) -> Cc4deR { Cc4deR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& self) -> TdeR { TdeR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& mut self) -> Cc2ieW < '_ , DierSpec > { Cc2ieW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& mut self) -> Cc3ieW < '_ , DierSpec > { Cc3ieW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& mut self) -> Cc4ieW < '_ , DierSpec > { Cc4ieW :: new (self , 4) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& mut self) -> TieW < '_ , DierSpec > { TieW :: new (self , 6) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& mut self) -> Cc2deW < '_ , DierSpec > { Cc2deW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& mut self) -> Cc3deW < '_ , DierSpec > { Cc3deW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& mut self) -> Cc4deW < '_ , DierSpec > { Cc4deW :: new (self , 12) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& mut self) -> TdeW < '_ , DierSpec > { TdeW :: new (self , 14) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/Compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/Compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IF` reader - Capture/Compare 2 interrupt flag"] pub type Cc2ifR = crate :: BitReader ;
#[doc = "Field `CC2IF` writer - Capture/Compare 2 interrupt flag"] pub type Cc2ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IF` reader - Capture/Compare 3 interrupt flag"] pub type Cc3ifR = crate :: BitReader ;
#[doc = "Field `CC3IF` writer - Capture/Compare 3 interrupt flag"] pub type Cc3ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IF` reader - Capture/Compare 4 interrupt flag"] pub type Cc4ifR = crate :: BitReader ;
#[doc = "Field `CC4IF` writer - Capture/Compare 4 interrupt flag"] pub type Cc4ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIF` reader - Trigger interrupt flag"] pub type TifR = crate :: BitReader ;
#[doc = "Field `TIF` writer - Trigger interrupt flag"] pub type TifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2OF` reader - Capture/Compare 2 overcapture flag"] pub type Cc2ofR = crate :: BitReader ;
#[doc = "Field `CC2OF` writer - Capture/Compare 2 overcapture flag"] pub type Cc2ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3OF` reader - Capture/Compare 3 overcapture flag"] pub type Cc3ofR = crate :: BitReader ;
#[doc = "Field `CC3OF` writer - Capture/Compare 3 overcapture flag"] pub type Cc3ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4OF` reader - Capture/Compare 4 overcapture flag"] pub type Cc4ofR = crate :: BitReader ;
#[doc = "Field `CC4OF` writer - Capture/Compare 4 overcapture flag"] pub type Cc4ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& self) -> Cc2ifR { Cc2ifR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& self) -> Cc3ifR { Cc3ifR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& self) -> Cc4ifR { Cc4ifR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& self) -> TifR { TifR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& self) -> Cc2ofR { Cc2ofR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& self) -> Cc3ofR { Cc3ofR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& self) -> Cc4ofR { Cc4ofR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& mut self) -> Cc2ifW < '_ , SrSpec > { Cc2ifW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& mut self) -> Cc3ifW < '_ , SrSpec > { Cc3ifW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& mut self) -> Cc4ifW < '_ , SrSpec > { Cc4ifW :: new (self , 4) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& mut self) -> TifW < '_ , SrSpec > { TifW :: new (self , 6) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& mut self) -> Cc2ofW < '_ , SrSpec > { Cc2ofW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& mut self) -> Cc3ofW < '_ , SrSpec > { Cc3ofW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& mut self) -> Cc4ofW < '_ , SrSpec > { Cc4ofW :: new (self , 12) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2G` writer - Capture/compare 2 generation"] pub type Cc2gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3G` writer - Capture/compare 3 generation"] pub type Cc3gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4G` writer - Capture/compare 4 generation"] pub type Cc4gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TG` writer - Trigger generation"] pub type TgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 2 - Capture/compare 2 generation"]
#[inline (always)] pub fn cc2g (& mut self) -> Cc2gW < '_ , EgrSpec > { Cc2gW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare 3 generation"]
#[inline (always)] pub fn cc3g (& mut self) -> Cc3gW < '_ , EgrSpec > { Cc3gW :: new (self , 3) }
#[doc = "Bit 4 - Capture/compare 4 generation"]
#[inline (always)] pub fn cc4g (& mut self) -> Cc4gW < '_ , EgrSpec > { Cc4gW :: new (self , 4) }
#[doc = "Bit 6 - Trigger generation"]
#[inline (always)] pub fn tg (& mut self) -> TgW < '_ , EgrSpec > { TgW :: new (self , 6) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 2 output enable"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 2 output enable"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC1CE` reader - Output compare 1 clear enable"] pub type Oc1ceR = crate :: BitReader ;
#[doc = "Field `OC1CE` writer - Output compare 1 clear enable"] pub type Oc1ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2S` reader - Capure/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capure/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC2FE` reader - Output compare 4 fast enable"] pub type Oc2feR = crate :: BitReader ;
#[doc = "Field `OC2FE` writer - Output compare 4 fast enable"] pub type Oc2feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2PE` reader - Output compare 2 preload enable"] pub type Oc2peR = crate :: BitReader ;
#[doc = "Field `OC2PE` writer - Output compare 2 preload enable"] pub type Oc2peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M` reader - Output compare 2 mode"] pub type Oc2mR = crate :: FieldReader ;
#[doc = "Field `OC2M` writer - Output compare 2 mode"] pub type Oc2mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC2CE` reader - Output compare 2 clear enable"] pub type Oc2ceR = crate :: BitReader ;
#[doc = "Field `OC2CE` writer - Output compare 2 clear enable"] pub type Oc2ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& self) -> Oc1ceR { Oc1ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capure/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc2fe (& self) -> Oc2feR { Oc2feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& self) -> Oc2peR { Oc2peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& self) -> Oc2mR { Oc2mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& self) -> Oc2ceR { Oc2ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& mut self) -> Oc1ceW < '_ , Ccmr1OutputSpec > { Oc1ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capure/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1OutputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc2fe (& mut self) -> Oc2feW < '_ , Ccmr1OutputSpec > { Oc2feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& mut self) -> Oc2peW < '_ , Ccmr1OutputSpec > { Oc2peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& mut self) -> Oc2mW < '_ , Ccmr1OutputSpec > { Oc2mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& mut self) -> Oc2ceW < '_ , Ccmr1OutputSpec > { Oc2ceW :: new (self , 15) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2PSC` reader - Input capture 2 prescaler"] pub type Ic2pscR = crate :: FieldReader ;
#[doc = "Field `IC2PSC` writer - Input capture 2 prescaler"] pub type Ic2pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2F` reader - Input capture 2 filter"] pub type Ic2fR = crate :: FieldReader ;
#[doc = "Field `IC2F` writer - Input capture 2 filter"] pub type Ic2fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& self) -> Ic2pscR { Ic2pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& self) -> Ic2fR { Ic2fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1InputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& mut self) -> Ic2pscW < '_ , Ccmr1InputSpec > { Ic2pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& mut self) -> Ic2fW < '_ , Ccmr1InputSpec > { Ic2fW :: new (self , 12) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCMR2_Output (rw) register accessor: capture/compare mode register 2(output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_output`] module"]
#[doc (alias = "CCMR2_Output")] pub type Ccmr2Output = crate :: Reg < ccmr2_output :: Ccmr2OutputSpec > ;
#[doc = "capture/compare mode register 2(output mode)"] pub mod ccmr2_output {
#[doc = "Register `CCMR2_Output` reader"] pub type R = crate :: R < Ccmr2OutputSpec > ;
#[doc = "Register `CCMR2_Output` writer"] pub type W = crate :: W < Ccmr2OutputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC3FE` reader - Output compare 3 fast enable"] pub type Oc3feR = crate :: BitReader ;
#[doc = "Field `OC3FE` writer - Output compare 3 fast enable"] pub type Oc3feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3PE` reader - Output compare 3 preload enable"] pub type Oc3peR = crate :: BitReader ;
#[doc = "Field `OC3PE` writer - Output compare 3 preload enable"] pub type Oc3peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3M` reader - Output compare 3 mode"] pub type Oc3mR = crate :: FieldReader ;
#[doc = "Field `OC3M` writer - Output compare 3 mode"] pub type Oc3mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC3CE` reader - Output compare 3 clear enable"] pub type Oc3ceR = crate :: BitReader ;
#[doc = "Field `OC3CE` writer - Output compare 3 clear enable"] pub type Oc3ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC4FE` reader - Output compare 4 fast enable"] pub type Oc4feR = crate :: BitReader ;
#[doc = "Field `OC4FE` writer - Output compare 4 fast enable"] pub type Oc4feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4PE` reader - Output compare 4 preload enable"] pub type Oc4peR = crate :: BitReader ;
#[doc = "Field `OC4PE` writer - Output compare 4 preload enable"] pub type Oc4peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4M` reader - Output compare 4 mode"] pub type Oc4mR = crate :: FieldReader ;
#[doc = "Field `OC4M` writer - Output compare 4 mode"] pub type Oc4mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC4CE` reader - Output compare 4 clear enable"] pub type Oc4ceR = crate :: BitReader ;
#[doc = "Field `OC4CE` writer - Output compare 4 clear enable"] pub type Oc4ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& self) -> Oc3feR { Oc3feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& self) -> Oc3peR { Oc3peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& self) -> Oc3mR { Oc3mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& self) -> Oc3ceR { Oc3ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& self) -> Oc4feR { Oc4feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& self) -> Oc4peR { Oc4peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& self) -> Oc4mR { Oc4mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& self) -> Oc4ceR { Oc4ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2OutputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& mut self) -> Oc3feW < '_ , Ccmr2OutputSpec > { Oc3feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& mut self) -> Oc3peW < '_ , Ccmr2OutputSpec > { Oc3peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& mut self) -> Oc3mW < '_ , Ccmr2OutputSpec > { Oc3mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& mut self) -> Oc3ceW < '_ , Ccmr2OutputSpec > { Oc3ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2OutputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& mut self) -> Oc4feW < '_ , Ccmr2OutputSpec > { Oc4feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& mut self) -> Oc4peW < '_ , Ccmr2OutputSpec > { Oc4peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& mut self) -> Oc4mW < '_ , Ccmr2OutputSpec > { Oc4mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& mut self) -> Oc4ceW < '_ , Ccmr2OutputSpec > { Oc4ceW :: new (self , 15) } }
#[doc = "capture/compare mode register 2(output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2OutputSpec ; impl crate :: RegisterSpec for Ccmr2OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_output::R`](R) reader structure"] impl crate :: Readable for Ccmr2OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_output::W`](W) writer structure"] impl crate :: Writable for Ccmr2OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Output to value 0"] impl crate :: Resettable for Ccmr2OutputSpec { } }
#[doc = "CCMR2_Input (rw) register accessor: capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_input`] module"]
#[doc (alias = "CCMR2_Input")] pub type Ccmr2Input = crate :: Reg < ccmr2_input :: Ccmr2InputSpec > ;
#[doc = "capture/compare mode register 2 (input mode)"] pub mod ccmr2_input {
#[doc = "Register `CCMR2_Input` reader"] pub type R = crate :: R < Ccmr2InputSpec > ;
#[doc = "Register `CCMR2_Input` writer"] pub type W = crate :: W < Ccmr2InputSpec > ;
#[doc = "Field `CC3S` reader - Capture/compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3PSC` reader - Input capture 3 prescaler"] pub type Ic3pscR = crate :: FieldReader ;
#[doc = "Field `IC3PSC` writer - Input capture 3 prescaler"] pub type Ic3pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3F` reader - Input capture 3 filter"] pub type Ic3fR = crate :: FieldReader ;
#[doc = "Field `IC3F` writer - Input capture 3 filter"] pub type Ic3fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4PSC` reader - Input capture 4 prescaler"] pub type Ic4pscR = crate :: FieldReader ;
#[doc = "Field `IC4PSC` writer - Input capture 4 prescaler"] pub type Ic4pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4F` reader - Input capture 4 filter"] pub type Ic4fR = crate :: FieldReader ;
#[doc = "Field `IC4F` writer - Input capture 4 filter"] pub type Ic4fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& self) -> Ic3pscR { Ic3pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& self) -> Ic3fR { Ic3fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& self) -> Ic4pscR { Ic4pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& self) -> Ic4fR { Ic4fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2InputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& mut self) -> Ic3pscW < '_ , Ccmr2InputSpec > { Ic3pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& mut self) -> Ic3fW < '_ , Ccmr2InputSpec > { Ic3fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2InputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& mut self) -> Ic4pscW < '_ , Ccmr2InputSpec > { Ic4pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& mut self) -> Ic4fW < '_ , Ccmr2InputSpec > { Ic4fW :: new (self , 12) } }
#[doc = "capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2InputSpec ; impl crate :: RegisterSpec for Ccmr2InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_input::R`](R) reader structure"] impl crate :: Readable for Ccmr2InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_input::W`](W) writer structure"] impl crate :: Writable for Ccmr2InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Input to value 0"] impl crate :: Resettable for Ccmr2InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2E` reader - Capture/Compare 2 output enable"] pub type Cc2eR = crate :: BitReader ;
#[doc = "Field `CC2E` writer - Capture/Compare 2 output enable"] pub type Cc2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2P` reader - Capture/Compare 2 output polarity"] pub type Cc2pR = crate :: BitReader ;
#[doc = "Field `CC2P` writer - Capture/Compare 2 output polarity"] pub type Cc2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3E` reader - Capture/Compare 3 output enable"] pub type Cc3eR = crate :: BitReader ;
#[doc = "Field `CC3E` writer - Capture/Compare 3 output enable"] pub type Cc3eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3P` reader - Capture/Compare 3 output polarity"] pub type Cc3pR = crate :: BitReader ;
#[doc = "Field `CC3P` writer - Capture/Compare 3 output polarity"] pub type Cc3pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4E` reader - Capture/Compare 4 output enable"] pub type Cc4eR = crate :: BitReader ;
#[doc = "Field `CC4E` writer - Capture/Compare 4 output enable"] pub type Cc4eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4P` reader - Capture/Compare 4 output polarity"] pub type Cc4pR = crate :: BitReader ;
#[doc = "Field `CC4P` writer - Capture/Compare 4 output polarity"] pub type Cc4pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& self) -> Cc2eR { Cc2eR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Capture/Compare 2 output polarity"]
#[inline (always)] pub fn cc2p (& self) -> Cc2pR { Cc2pR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& self) -> Cc3eR { Cc3eR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 3 output polarity"]
#[inline (always)] pub fn cc3p (& self) -> Cc3pR { Cc3pR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& self) -> Cc4eR { Cc4eR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Capture/Compare 4 output polarity"]
#[inline (always)] pub fn cc4p (& self) -> Cc4pR { Cc4pR :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& mut self) -> Cc2eW < '_ , CcerSpec > { Cc2eW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare 2 output polarity"]
#[inline (always)] pub fn cc2p (& mut self) -> Cc2pW < '_ , CcerSpec > { Cc2pW :: new (self , 5) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& mut self) -> Cc3eW < '_ , CcerSpec > { Cc3eW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 3 output polarity"]
#[inline (always)] pub fn cc3p (& mut self) -> Cc3pW < '_ , CcerSpec > { Cc3pW :: new (self , 9) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& mut self) -> Cc4eW < '_ , CcerSpec > { Cc4eW :: new (self , 12) }
#[doc = "Bit 13 - Capture/Compare 4 output polarity"]
#[inline (always)] pub fn cc4p (& mut self) -> Cc4pW < '_ , CcerSpec > { Cc4pW :: new (self , 13) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u32 > ;
#[doc = "Field `CNT` writer - Counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto reload value"] pub type ArrR = crate :: FieldReader < u32 > ;
#[doc = "Field `ARR` writer - Auto reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Auto reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Auto reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u32 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CCR2 (rw) register accessor: capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "capture/compare register 2"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `CCR2` reader - Capture/Compare 2 value"] pub type Ccr2R = crate :: FieldReader < u32 > ;
#[doc = "Field `CCR2` writer - Capture/Compare 2 value"] pub type Ccr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& self) -> Ccr2R { Ccr2R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& mut self) -> Ccr2W < '_ , Ccr2Spec > { Ccr2W :: new (self , 0) } }
#[doc = "capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CCR3 (rw) register accessor: capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "capture/compare register 3"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `CCR3` reader - Capture/Compare 3 value"] pub type Ccr3R = crate :: FieldReader < u32 > ;
#[doc = "Field `CCR3` writer - Capture/Compare 3 value"] pub type Ccr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Capture/Compare 3 value"]
#[inline (always)] pub fn ccr3 (& self) -> Ccr3R { Ccr3R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Capture/Compare 3 value"]
#[inline (always)] pub fn ccr3 (& mut self) -> Ccr3W < '_ , Ccr3Spec > { Ccr3W :: new (self , 0) } }
#[doc = "capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CCR4 (rw) register accessor: capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "capture/compare register 4"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `CCR4` reader - Capture/Compare 4 value"] pub type Ccr4R = crate :: FieldReader < u32 > ;
#[doc = "Field `CCR4` writer - Capture/Compare 4 value"] pub type Ccr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - Capture/Compare 4 value"]
#[inline (always)] pub fn ccr4 (& self) -> Ccr4R { Ccr4R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - Capture/Compare 4 value"]
#[inline (always)] pub fn ccr4 (& mut self) -> Ccr4W < '_ , Ccr4Spec > { Ccr4W :: new (self , 0) } }
#[doc = "capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "DCR (w) register accessor: DMA control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (w) register accessor: DMA address for full transfer\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } } }
#[doc = "General purpose timer"] pub type Tim3 = crate :: Periph < tim3 :: RegisterBlock , 0x4000_0400 > ; impl core :: fmt :: Debug for Tim3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim3") . finish () } }
#[doc = "General purpose timer"] pub mod tim3 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , smcr : Smcr , dier : Dier , sr : Sr , egr : Egr , _reserved_6_ccmr1 : [u8 ; 0x04] , _reserved_7_ccmr2 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , _reserved12 : [u8 ; 0x04] , ccr1 : Ccr1 , ccr2 : Ccr2 , ccr3 : Ccr3 , ccr4 : Ccr4 , _reserved16 : [u8 ; 0x04] , dcr : Dcr , dmar : Dmar , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x08 - slave mode control register 1"]
#[inline (always)] pub const fn smcr (& self) -> & Smcr { & self . smcr }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x1c - capture/compare mode register 2 (input mode)"]
#[inline (always)] pub const fn ccmr2_input (& self) -> & Ccmr2Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - capture/compare mode register 2(output mode)"]
#[inline (always)] pub const fn ccmr2_output (& self) -> & Ccmr2Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x38 - capture/compare register 2"]
#[inline (always)] pub const fn ccr2 (& self) -> & Ccr2 { & self . ccr2 }
#[doc = "0x3c - capture/compare register 3"]
#[inline (always)] pub const fn ccr3 (& self) -> & Ccr3 { & self . ccr3 }
#[doc = "0x40 - capture/compare register 4"]
#[inline (always)] pub const fn ccr4 (& self) -> & Ccr4 { & self . ccr4 }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIR` reader - Direction"] pub type DirR = crate :: BitReader ;
#[doc = "Field `DIR` writer - Direction"] pub type DirW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CMS` reader - Center-aligned mode selection"] pub type CmsR = crate :: FieldReader ;
#[doc = "Field `CMS` writer - Center-aligned mode selection"] pub type CmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& self) -> CmsR { CmsR :: new (((self . bits >> 5) & 3) as u8) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 4 - Direction"]
#[inline (always)] pub fn dir (& mut self) -> DirW < '_ , Cr1Spec > { DirW :: new (self , 4) }
#[doc = "Bits 5:6 - Center-aligned mode selection"]
#[inline (always)] pub fn cms (& mut self) -> CmsW < '_ , Cr1Spec > { CmsW :: new (self , 5) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCDS` reader - Capture/Compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/Compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MMS` reader - Master mode selection"] pub type MmsR = crate :: FieldReader ;
#[doc = "Field `MMS` writer - Master mode selection"] pub type MmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `TI1S` reader - TI1 selection"] pub type Ti1sR = crate :: BitReader ;
#[doc = "Field `TI1S` writer - TI1 selection"] pub type Ti1sW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - Capture/Compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& self) -> MmsR { MmsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& self) -> Ti1sR { Ti1sR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 3 - Capture/Compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bits 4:6 - Master mode selection"]
#[inline (always)] pub fn mms (& mut self) -> MmsW < '_ , Cr2Spec > { MmsW :: new (self , 4) }
#[doc = "Bit 7 - TI1 selection"]
#[inline (always)] pub fn ti1s (& mut self) -> Ti1sW < '_ , Cr2Spec > { Ti1sW :: new (self , 7) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "SMCR (rw) register accessor: slave mode control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@smcr`] module"]
#[doc (alias = "SMCR")] pub type Smcr = crate :: Reg < smcr :: SmcrSpec > ;
#[doc = "slave mode control register 1"] pub mod smcr {
#[doc = "Register `SMCR` reader"] pub type R = crate :: R < SmcrSpec > ;
#[doc = "Register `SMCR` writer"] pub type W = crate :: W < SmcrSpec > ;
#[doc = "Field `SMS` reader - Slave mode selection"] pub type SmsR = crate :: FieldReader ;
#[doc = "Field `SMS` writer - Slave mode selection"] pub type SmsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OCCS` reader - Output compare clear selection"] pub type OccsR = crate :: BitReader ;
#[doc = "Field `OCCS` writer - Output compare clear selection"] pub type OccsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TS` reader - Trigger selection"] pub type TsR = crate :: FieldReader ;
#[doc = "Field `TS` writer - Trigger selection"] pub type TsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `MSM` reader - Master/slave mode"] pub type MsmR = crate :: BitReader ;
#[doc = "Field `MSM` writer - Master/slave mode"] pub type MsmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETF` reader - External trigger filter"] pub type EtfR = crate :: FieldReader ;
#[doc = "Field `ETF` writer - External trigger filter"] pub type EtfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `ETPS` reader - External trigger prescaler"] pub type EtpsR = crate :: FieldReader ;
#[doc = "Field `ETPS` writer - External trigger prescaler"] pub type EtpsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `ECE` reader - External clock enable"] pub type EceR = crate :: BitReader ;
#[doc = "Field `ECE` writer - External clock enable"] pub type EceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ETP` reader - External trigger polarity"] pub type EtpR = crate :: BitReader ;
#[doc = "Field `ETP` writer - External trigger polarity"] pub type EtpW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& self) -> SmsR { SmsR :: new ((self . bits & 7) as u8) }
#[doc = "Bit 3 - Output compare clear selection"]
#[inline (always)] pub fn occs (& self) -> OccsR { OccsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& self) -> TsR { TsR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Master/slave mode"]
#[inline (always)] pub fn msm (& self) -> MsmR { MsmR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& self) -> EtfR { EtfR :: new (((self . bits >> 8) & 0x0f) as u8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& self) -> EtpsR { EtpsR :: new (((self . bits >> 12) & 3) as u8) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& self) -> EceR { EceR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& self) -> EtpR { EtpR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - Slave mode selection"]
#[inline (always)] pub fn sms (& mut self) -> SmsW < '_ , SmcrSpec > { SmsW :: new (self , 0) }
#[doc = "Bit 3 - Output compare clear selection"]
#[inline (always)] pub fn occs (& mut self) -> OccsW < '_ , SmcrSpec > { OccsW :: new (self , 3) }
#[doc = "Bits 4:6 - Trigger selection"]
#[inline (always)] pub fn ts (& mut self) -> TsW < '_ , SmcrSpec > { TsW :: new (self , 4) }
#[doc = "Bit 7 - Master/slave mode"]
#[inline (always)] pub fn msm (& mut self) -> MsmW < '_ , SmcrSpec > { MsmW :: new (self , 7) }
#[doc = "Bits 8:11 - External trigger filter"]
#[inline (always)] pub fn etf (& mut self) -> EtfW < '_ , SmcrSpec > { EtfW :: new (self , 8) }
#[doc = "Bits 12:13 - External trigger prescaler"]
#[inline (always)] pub fn etps (& mut self) -> EtpsW < '_ , SmcrSpec > { EtpsW :: new (self , 12) }
#[doc = "Bit 14 - External clock enable"]
#[inline (always)] pub fn ece (& mut self) -> EceW < '_ , SmcrSpec > { EceW :: new (self , 14) }
#[doc = "Bit 15 - External trigger polarity"]
#[inline (always)] pub fn etp (& mut self) -> EtpW < '_ , SmcrSpec > { EtpW :: new (self , 15) } }
#[doc = "slave mode control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`smcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`smcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SmcrSpec ; impl crate :: RegisterSpec for SmcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`smcr::R`](R) reader structure"] impl crate :: Readable for SmcrSpec { }
#[doc = "`write(|w| ..)` method takes [`smcr::W`](W) writer structure"] impl crate :: Writable for SmcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SMCR to value 0"] impl crate :: Resettable for SmcrSpec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IE` reader - Capture/Compare 2 interrupt enable"] pub type Cc2ieR = crate :: BitReader ;
#[doc = "Field `CC2IE` writer - Capture/Compare 2 interrupt enable"] pub type Cc2ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IE` reader - Capture/Compare 3 interrupt enable"] pub type Cc3ieR = crate :: BitReader ;
#[doc = "Field `CC3IE` writer - Capture/Compare 3 interrupt enable"] pub type Cc3ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IE` reader - Capture/Compare 4 interrupt enable"] pub type Cc4ieR = crate :: BitReader ;
#[doc = "Field `CC4IE` writer - Capture/Compare 4 interrupt enable"] pub type Cc4ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIE` reader - Trigger interrupt enable"] pub type TieR = crate :: BitReader ;
#[doc = "Field `TIE` writer - Trigger interrupt enable"] pub type TieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2DE` reader - Capture/Compare 2 DMA request enable"] pub type Cc2deR = crate :: BitReader ;
#[doc = "Field `CC2DE` writer - Capture/Compare 2 DMA request enable"] pub type Cc2deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3DE` reader - Capture/Compare 3 DMA request enable"] pub type Cc3deR = crate :: BitReader ;
#[doc = "Field `CC3DE` writer - Capture/Compare 3 DMA request enable"] pub type Cc3deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4DE` reader - Capture/Compare 4 DMA request enable"] pub type Cc4deR = crate :: BitReader ;
#[doc = "Field `CC4DE` writer - Capture/Compare 4 DMA request enable"] pub type Cc4deW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TDE` reader - Trigger DMA request enable"] pub type TdeR = crate :: BitReader ;
#[doc = "Field `TDE` writer - Trigger DMA request enable"] pub type TdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& self) -> Cc2ieR { Cc2ieR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& self) -> Cc3ieR { Cc3ieR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& self) -> Cc4ieR { Cc4ieR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& self) -> TieR { TieR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& self) -> Cc2deR { Cc2deR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& self) -> Cc3deR { Cc3deR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& self) -> Cc4deR { Cc4deR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& self) -> TdeR { TdeR :: new (((self . bits >> 14) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt enable"]
#[inline (always)] pub fn cc2ie (& mut self) -> Cc2ieW < '_ , DierSpec > { Cc2ieW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt enable"]
#[inline (always)] pub fn cc3ie (& mut self) -> Cc3ieW < '_ , DierSpec > { Cc3ieW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt enable"]
#[inline (always)] pub fn cc4ie (& mut self) -> Cc4ieW < '_ , DierSpec > { Cc4ieW :: new (self , 4) }
#[doc = "Bit 6 - Trigger interrupt enable"]
#[inline (always)] pub fn tie (& mut self) -> TieW < '_ , DierSpec > { TieW :: new (self , 6) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 DMA request enable"]
#[inline (always)] pub fn cc2de (& mut self) -> Cc2deW < '_ , DierSpec > { Cc2deW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 DMA request enable"]
#[inline (always)] pub fn cc3de (& mut self) -> Cc3deW < '_ , DierSpec > { Cc3deW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 DMA request enable"]
#[inline (always)] pub fn cc4de (& mut self) -> Cc4deW < '_ , DierSpec > { Cc4deW :: new (self , 12) }
#[doc = "Bit 14 - Trigger DMA request enable"]
#[inline (always)] pub fn tde (& mut self) -> TdeW < '_ , DierSpec > { TdeW :: new (self , 14) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/Compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/Compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2IF` reader - Capture/Compare 2 interrupt flag"] pub type Cc2ifR = crate :: BitReader ;
#[doc = "Field `CC2IF` writer - Capture/Compare 2 interrupt flag"] pub type Cc2ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3IF` reader - Capture/Compare 3 interrupt flag"] pub type Cc3ifR = crate :: BitReader ;
#[doc = "Field `CC3IF` writer - Capture/Compare 3 interrupt flag"] pub type Cc3ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4IF` reader - Capture/Compare 4 interrupt flag"] pub type Cc4ifR = crate :: BitReader ;
#[doc = "Field `CC4IF` writer - Capture/Compare 4 interrupt flag"] pub type Cc4ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TIF` reader - Trigger interrupt flag"] pub type TifR = crate :: BitReader ;
#[doc = "Field `TIF` writer - Trigger interrupt flag"] pub type TifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2OF` reader - Capture/Compare 2 overcapture flag"] pub type Cc2ofR = crate :: BitReader ;
#[doc = "Field `CC2OF` writer - Capture/Compare 2 overcapture flag"] pub type Cc2ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3OF` reader - Capture/Compare 3 overcapture flag"] pub type Cc3ofR = crate :: BitReader ;
#[doc = "Field `CC3OF` writer - Capture/Compare 3 overcapture flag"] pub type Cc3ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4OF` reader - Capture/Compare 4 overcapture flag"] pub type Cc4ofR = crate :: BitReader ;
#[doc = "Field `CC4OF` writer - Capture/Compare 4 overcapture flag"] pub type Cc4ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& self) -> Cc2ifR { Cc2ifR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& self) -> Cc3ifR { Cc3ifR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& self) -> Cc4ifR { Cc4ifR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& self) -> TifR { TifR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Capture/Compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& self) -> Cc2ofR { Cc2ofR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& self) -> Cc3ofR { Cc3ofR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& self) -> Cc4ofR { Cc4ofR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 2 interrupt flag"]
#[inline (always)] pub fn cc2if (& mut self) -> Cc2ifW < '_ , SrSpec > { Cc2ifW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 3 interrupt flag"]
#[inline (always)] pub fn cc3if (& mut self) -> Cc3ifW < '_ , SrSpec > { Cc3ifW :: new (self , 3) }
#[doc = "Bit 4 - Capture/Compare 4 interrupt flag"]
#[inline (always)] pub fn cc4if (& mut self) -> Cc4ifW < '_ , SrSpec > { Cc4ifW :: new (self , 4) }
#[doc = "Bit 6 - Trigger interrupt flag"]
#[inline (always)] pub fn tif (& mut self) -> TifW < '_ , SrSpec > { TifW :: new (self , 6) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) }
#[doc = "Bit 10 - Capture/Compare 2 overcapture flag"]
#[inline (always)] pub fn cc2of (& mut self) -> Cc2ofW < '_ , SrSpec > { Cc2ofW :: new (self , 10) }
#[doc = "Bit 11 - Capture/Compare 3 overcapture flag"]
#[inline (always)] pub fn cc3of (& mut self) -> Cc3ofW < '_ , SrSpec > { Cc3ofW :: new (self , 11) }
#[doc = "Bit 12 - Capture/Compare 4 overcapture flag"]
#[inline (always)] pub fn cc4of (& mut self) -> Cc4ofW < '_ , SrSpec > { Cc4ofW :: new (self , 12) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2G` writer - Capture/compare 2 generation"] pub type Cc2gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3G` writer - Capture/compare 3 generation"] pub type Cc3gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4G` writer - Capture/compare 4 generation"] pub type Cc4gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TG` writer - Trigger generation"] pub type TgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 2 - Capture/compare 2 generation"]
#[inline (always)] pub fn cc2g (& mut self) -> Cc2gW < '_ , EgrSpec > { Cc2gW :: new (self , 2) }
#[doc = "Bit 3 - Capture/compare 3 generation"]
#[inline (always)] pub fn cc3g (& mut self) -> Cc3gW < '_ , EgrSpec > { Cc3gW :: new (self , 3) }
#[doc = "Bit 4 - Capture/compare 4 generation"]
#[inline (always)] pub fn cc4g (& mut self) -> Cc4gW < '_ , EgrSpec > { Cc4gW :: new (self , 4) }
#[doc = "Bit 6 - Trigger generation"]
#[inline (always)] pub fn tg (& mut self) -> TgW < '_ , EgrSpec > { TgW :: new (self , 6) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 2 output enable"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 2 output enable"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC1CE` reader - Output compare 1 clear enable"] pub type Oc1ceR = crate :: BitReader ;
#[doc = "Field `OC1CE` writer - Output compare 1 clear enable"] pub type Oc1ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2S` reader - Capure/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capure/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC2FE` reader - Output compare 4 fast enable"] pub type Oc2feR = crate :: BitReader ;
#[doc = "Field `OC2FE` writer - Output compare 4 fast enable"] pub type Oc2feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2PE` reader - Output compare 2 preload enable"] pub type Oc2peR = crate :: BitReader ;
#[doc = "Field `OC2PE` writer - Output compare 2 preload enable"] pub type Oc2peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC2M` reader - Output compare 2 mode"] pub type Oc2mR = crate :: FieldReader ;
#[doc = "Field `OC2M` writer - Output compare 2 mode"] pub type Oc2mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC2CE` reader - Output compare 2 clear enable"] pub type Oc2ceR = crate :: BitReader ;
#[doc = "Field `OC2CE` writer - Output compare 2 clear enable"] pub type Oc2ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& self) -> Oc1ceR { Oc1ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capure/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc2fe (& self) -> Oc2feR { Oc2feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& self) -> Oc2peR { Oc2peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& self) -> Oc2mR { Oc2mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& self) -> Oc2ceR { Oc2ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 1 clear enable"]
#[inline (always)] pub fn oc1ce (& mut self) -> Oc1ceW < '_ , Ccmr1OutputSpec > { Oc1ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capure/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1OutputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc2fe (& mut self) -> Oc2feW < '_ , Ccmr1OutputSpec > { Oc2feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 2 preload enable"]
#[inline (always)] pub fn oc2pe (& mut self) -> Oc2peW < '_ , Ccmr1OutputSpec > { Oc2peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 2 mode"]
#[inline (always)] pub fn oc2m (& mut self) -> Oc2mW < '_ , Ccmr1OutputSpec > { Oc2mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 2 clear enable"]
#[inline (always)] pub fn oc2ce (& mut self) -> Oc2ceW < '_ , Ccmr1OutputSpec > { Oc2ceW :: new (self , 15) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC2S` reader - Capture/Compare 2 selection"] pub type Cc2sR = crate :: FieldReader ;
#[doc = "Field `CC2S` writer - Capture/Compare 2 selection"] pub type Cc2sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2PSC` reader - Input capture 2 prescaler"] pub type Ic2pscR = crate :: FieldReader ;
#[doc = "Field `IC2PSC` writer - Input capture 2 prescaler"] pub type Ic2pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC2F` reader - Input capture 2 filter"] pub type Ic2fR = crate :: FieldReader ;
#[doc = "Field `IC2F` writer - Input capture 2 filter"] pub type Ic2fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& self) -> Cc2sR { Cc2sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& self) -> Ic2pscR { Ic2pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& self) -> Ic2fR { Ic2fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 2 selection"]
#[inline (always)] pub fn cc2s (& mut self) -> Cc2sW < '_ , Ccmr1InputSpec > { Cc2sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 2 prescaler"]
#[inline (always)] pub fn ic2psc (& mut self) -> Ic2pscW < '_ , Ccmr1InputSpec > { Ic2pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 2 filter"]
#[inline (always)] pub fn ic2f (& mut self) -> Ic2fW < '_ , Ccmr1InputSpec > { Ic2fW :: new (self , 12) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCMR2_Output (rw) register accessor: capture/compare mode register 2(output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_output`] module"]
#[doc (alias = "CCMR2_Output")] pub type Ccmr2Output = crate :: Reg < ccmr2_output :: Ccmr2OutputSpec > ;
#[doc = "capture/compare mode register 2(output mode)"] pub mod ccmr2_output {
#[doc = "Register `CCMR2_Output` reader"] pub type R = crate :: R < Ccmr2OutputSpec > ;
#[doc = "Register `CCMR2_Output` writer"] pub type W = crate :: W < Ccmr2OutputSpec > ;
#[doc = "Field `CC3S` reader - Capture/Compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/Compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC3FE` reader - Output compare 3 fast enable"] pub type Oc3feR = crate :: BitReader ;
#[doc = "Field `OC3FE` writer - Output compare 3 fast enable"] pub type Oc3feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3PE` reader - Output compare 3 preload enable"] pub type Oc3peR = crate :: BitReader ;
#[doc = "Field `OC3PE` writer - Output compare 3 preload enable"] pub type Oc3peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC3M` reader - Output compare 3 mode"] pub type Oc3mR = crate :: FieldReader ;
#[doc = "Field `OC3M` writer - Output compare 3 mode"] pub type Oc3mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC3CE` reader - Output compare 3 clear enable"] pub type Oc3ceR = crate :: BitReader ;
#[doc = "Field `OC3CE` writer - Output compare 3 clear enable"] pub type Oc3ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC4FE` reader - Output compare 4 fast enable"] pub type Oc4feR = crate :: BitReader ;
#[doc = "Field `OC4FE` writer - Output compare 4 fast enable"] pub type Oc4feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4PE` reader - Output compare 4 preload enable"] pub type Oc4peR = crate :: BitReader ;
#[doc = "Field `OC4PE` writer - Output compare 4 preload enable"] pub type Oc4peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC4M` reader - Output compare 4 mode"] pub type Oc4mR = crate :: FieldReader ;
#[doc = "Field `OC4M` writer - Output compare 4 mode"] pub type Oc4mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OC4CE` reader - Output compare 4 clear enable"] pub type Oc4ceR = crate :: BitReader ;
#[doc = "Field `OC4CE` writer - Output compare 4 clear enable"] pub type Oc4ceW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& self) -> Oc3feR { Oc3feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& self) -> Oc3peR { Oc3peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& self) -> Oc3mR { Oc3mR :: new (((self . bits >> 4) & 7) as u8) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& self) -> Oc3ceR { Oc3ceR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& self) -> Oc4feR { Oc4feR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& self) -> Oc4peR { Oc4peR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& self) -> Oc4mR { Oc4mR :: new (((self . bits >> 12) & 7) as u8) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& self) -> Oc4ceR { Oc4ceR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2OutputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 3 fast enable"]
#[inline (always)] pub fn oc3fe (& mut self) -> Oc3feW < '_ , Ccmr2OutputSpec > { Oc3feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 3 preload enable"]
#[inline (always)] pub fn oc3pe (& mut self) -> Oc3peW < '_ , Ccmr2OutputSpec > { Oc3peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 3 mode"]
#[inline (always)] pub fn oc3m (& mut self) -> Oc3mW < '_ , Ccmr2OutputSpec > { Oc3mW :: new (self , 4) }
#[doc = "Bit 7 - Output compare 3 clear enable"]
#[inline (always)] pub fn oc3ce (& mut self) -> Oc3ceW < '_ , Ccmr2OutputSpec > { Oc3ceW :: new (self , 7) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2OutputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bit 10 - Output compare 4 fast enable"]
#[inline (always)] pub fn oc4fe (& mut self) -> Oc4feW < '_ , Ccmr2OutputSpec > { Oc4feW :: new (self , 10) }
#[doc = "Bit 11 - Output compare 4 preload enable"]
#[inline (always)] pub fn oc4pe (& mut self) -> Oc4peW < '_ , Ccmr2OutputSpec > { Oc4peW :: new (self , 11) }
#[doc = "Bits 12:14 - Output compare 4 mode"]
#[inline (always)] pub fn oc4m (& mut self) -> Oc4mW < '_ , Ccmr2OutputSpec > { Oc4mW :: new (self , 12) }
#[doc = "Bit 15 - Output compare 4 clear enable"]
#[inline (always)] pub fn oc4ce (& mut self) -> Oc4ceW < '_ , Ccmr2OutputSpec > { Oc4ceW :: new (self , 15) } }
#[doc = "capture/compare mode register 2(output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2OutputSpec ; impl crate :: RegisterSpec for Ccmr2OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_output::R`](R) reader structure"] impl crate :: Readable for Ccmr2OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_output::W`](W) writer structure"] impl crate :: Writable for Ccmr2OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Output to value 0"] impl crate :: Resettable for Ccmr2OutputSpec { } }
#[doc = "CCMR2_Input (rw) register accessor: capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr2_input`] module"]
#[doc (alias = "CCMR2_Input")] pub type Ccmr2Input = crate :: Reg < ccmr2_input :: Ccmr2InputSpec > ;
#[doc = "capture/compare mode register 2 (input mode)"] pub mod ccmr2_input {
#[doc = "Register `CCMR2_Input` reader"] pub type R = crate :: R < Ccmr2InputSpec > ;
#[doc = "Register `CCMR2_Input` writer"] pub type W = crate :: W < Ccmr2InputSpec > ;
#[doc = "Field `CC3S` reader - Capture/compare 3 selection"] pub type Cc3sR = crate :: FieldReader ;
#[doc = "Field `CC3S` writer - Capture/compare 3 selection"] pub type Cc3sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3PSC` reader - Input capture 3 prescaler"] pub type Ic3pscR = crate :: FieldReader ;
#[doc = "Field `IC3PSC` writer - Input capture 3 prescaler"] pub type Ic3pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC3F` reader - Input capture 3 filter"] pub type Ic3fR = crate :: FieldReader ;
#[doc = "Field `IC3F` writer - Input capture 3 filter"] pub type Ic3fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `CC4S` reader - Capture/Compare 4 selection"] pub type Cc4sR = crate :: FieldReader ;
#[doc = "Field `CC4S` writer - Capture/Compare 4 selection"] pub type Cc4sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4PSC` reader - Input capture 4 prescaler"] pub type Ic4pscR = crate :: FieldReader ;
#[doc = "Field `IC4PSC` writer - Input capture 4 prescaler"] pub type Ic4pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC4F` reader - Input capture 4 filter"] pub type Ic4fR = crate :: FieldReader ;
#[doc = "Field `IC4F` writer - Input capture 4 filter"] pub type Ic4fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/compare 3 selection"]
#[inline (always)] pub fn cc3s (& self) -> Cc3sR { Cc3sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& self) -> Ic3pscR { Ic3pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& self) -> Ic3fR { Ic3fR :: new (((self . bits >> 4) & 0x0f) as u8) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& self) -> Cc4sR { Cc4sR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& self) -> Ic4pscR { Ic4pscR :: new (((self . bits >> 10) & 3) as u8) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& self) -> Ic4fR { Ic4fR :: new (((self . bits >> 12) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/compare 3 selection"]
#[inline (always)] pub fn cc3s (& mut self) -> Cc3sW < '_ , Ccmr2InputSpec > { Cc3sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 3 prescaler"]
#[inline (always)] pub fn ic3psc (& mut self) -> Ic3pscW < '_ , Ccmr2InputSpec > { Ic3pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 3 filter"]
#[inline (always)] pub fn ic3f (& mut self) -> Ic3fW < '_ , Ccmr2InputSpec > { Ic3fW :: new (self , 4) }
#[doc = "Bits 8:9 - Capture/Compare 4 selection"]
#[inline (always)] pub fn cc4s (& mut self) -> Cc4sW < '_ , Ccmr2InputSpec > { Cc4sW :: new (self , 8) }
#[doc = "Bits 10:11 - Input capture 4 prescaler"]
#[inline (always)] pub fn ic4psc (& mut self) -> Ic4pscW < '_ , Ccmr2InputSpec > { Ic4pscW :: new (self , 10) }
#[doc = "Bits 12:15 - Input capture 4 filter"]
#[inline (always)] pub fn ic4f (& mut self) -> Ic4fW < '_ , Ccmr2InputSpec > { Ic4fW :: new (self , 12) } }
#[doc = "capture/compare mode register 2 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr2_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr2_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr2InputSpec ; impl crate :: RegisterSpec for Ccmr2InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr2_input::R`](R) reader structure"] impl crate :: Readable for Ccmr2InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr2_input::W`](W) writer structure"] impl crate :: Writable for Ccmr2InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR2_Input to value 0"] impl crate :: Resettable for Ccmr2InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2E` reader - Capture/Compare 2 output enable"] pub type Cc2eR = crate :: BitReader ;
#[doc = "Field `CC2E` writer - Capture/Compare 2 output enable"] pub type Cc2eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC2P` reader - Capture/Compare 2 output polarity"] pub type Cc2pR = crate :: BitReader ;
#[doc = "Field `CC2P` writer - Capture/Compare 2 output polarity"] pub type Cc2pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3E` reader - Capture/Compare 3 output enable"] pub type Cc3eR = crate :: BitReader ;
#[doc = "Field `CC3E` writer - Capture/Compare 3 output enable"] pub type Cc3eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC3P` reader - Capture/Compare 3 output polarity"] pub type Cc3pR = crate :: BitReader ;
#[doc = "Field `CC3P` writer - Capture/Compare 3 output polarity"] pub type Cc3pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4E` reader - Capture/Compare 4 output enable"] pub type Cc4eR = crate :: BitReader ;
#[doc = "Field `CC4E` writer - Capture/Compare 4 output enable"] pub type Cc4eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC4P` reader - Capture/Compare 4 output polarity"] pub type Cc4pR = crate :: BitReader ;
#[doc = "Field `CC4P` writer - Capture/Compare 4 output polarity"] pub type Cc4pW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& self) -> Cc2eR { Cc2eR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Capture/Compare 2 output polarity"]
#[inline (always)] pub fn cc2p (& self) -> Cc2pR { Cc2pR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& self) -> Cc3eR { Cc3eR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 3 output polarity"]
#[inline (always)] pub fn cc3p (& self) -> Cc3pR { Cc3pR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& self) -> Cc4eR { Cc4eR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Capture/Compare 4 output polarity"]
#[inline (always)] pub fn cc4p (& self) -> Cc4pR { Cc4pR :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 4 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc2e (& mut self) -> Cc2eW < '_ , CcerSpec > { Cc2eW :: new (self , 4) }
#[doc = "Bit 5 - Capture/Compare 2 output polarity"]
#[inline (always)] pub fn cc2p (& mut self) -> Cc2pW < '_ , CcerSpec > { Cc2pW :: new (self , 5) }
#[doc = "Bit 8 - Capture/Compare 3 output enable"]
#[inline (always)] pub fn cc3e (& mut self) -> Cc3eW < '_ , CcerSpec > { Cc3eW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 3 output polarity"]
#[inline (always)] pub fn cc3p (& mut self) -> Cc3pW < '_ , CcerSpec > { Cc3pW :: new (self , 9) }
#[doc = "Bit 12 - Capture/Compare 4 output enable"]
#[inline (always)] pub fn cc4e (& mut self) -> Cc4eW < '_ , CcerSpec > { Cc4eW :: new (self , 12) }
#[doc = "Bit 13 - Capture/Compare 4 output polarity"]
#[inline (always)] pub fn cc4p (& mut self) -> Cc4pW < '_ , CcerSpec > { Cc4pW :: new (self , 13) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - Counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "CCR2 (rw) register accessor: capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr2`] module"]
#[doc (alias = "CCR2")] pub type Ccr2 = crate :: Reg < ccr2 :: Ccr2Spec > ;
#[doc = "capture/compare register 2"] pub mod ccr2 {
#[doc = "Register `CCR2` reader"] pub type R = crate :: R < Ccr2Spec > ;
#[doc = "Register `CCR2` writer"] pub type W = crate :: W < Ccr2Spec > ;
#[doc = "Field `CCR2` reader - Capture/Compare 2 value"] pub type Ccr2R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR2` writer - Capture/Compare 2 value"] pub type Ccr2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& self) -> Ccr2R { Ccr2R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 2 value"]
#[inline (always)] pub fn ccr2 (& mut self) -> Ccr2W < '_ , Ccr2Spec > { Ccr2W :: new (self , 0) } }
#[doc = "capture/compare register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr2Spec ; impl crate :: RegisterSpec for Ccr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr2::R`](R) reader structure"] impl crate :: Readable for Ccr2Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr2::W`](W) writer structure"] impl crate :: Writable for Ccr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR2 to value 0"] impl crate :: Resettable for Ccr2Spec { } }
#[doc = "CCR3 (rw) register accessor: capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr3`] module"]
#[doc (alias = "CCR3")] pub type Ccr3 = crate :: Reg < ccr3 :: Ccr3Spec > ;
#[doc = "capture/compare register 3"] pub mod ccr3 {
#[doc = "Register `CCR3` reader"] pub type R = crate :: R < Ccr3Spec > ;
#[doc = "Register `CCR3` writer"] pub type W = crate :: W < Ccr3Spec > ;
#[doc = "Field `CCR3` reader - Capture/Compare 3 value"] pub type Ccr3R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR3` writer - Capture/Compare 3 value"] pub type Ccr3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 3 value"]
#[inline (always)] pub fn ccr3 (& self) -> Ccr3R { Ccr3R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 3 value"]
#[inline (always)] pub fn ccr3 (& mut self) -> Ccr3W < '_ , Ccr3Spec > { Ccr3W :: new (self , 0) } }
#[doc = "capture/compare register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr3Spec ; impl crate :: RegisterSpec for Ccr3Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr3::R`](R) reader structure"] impl crate :: Readable for Ccr3Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr3::W`](W) writer structure"] impl crate :: Writable for Ccr3Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR3 to value 0"] impl crate :: Resettable for Ccr3Spec { } }
#[doc = "CCR4 (rw) register accessor: capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr4`] module"]
#[doc (alias = "CCR4")] pub type Ccr4 = crate :: Reg < ccr4 :: Ccr4Spec > ;
#[doc = "capture/compare register 4"] pub mod ccr4 {
#[doc = "Register `CCR4` reader"] pub type R = crate :: R < Ccr4Spec > ;
#[doc = "Register `CCR4` writer"] pub type W = crate :: W < Ccr4Spec > ;
#[doc = "Field `CCR4` reader - Capture/Compare 4 value"] pub type Ccr4R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR4` writer - Capture/Compare 4 value"] pub type Ccr4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 4 value"]
#[inline (always)] pub fn ccr4 (& self) -> Ccr4R { Ccr4R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 4 value"]
#[inline (always)] pub fn ccr4 (& mut self) -> Ccr4W < '_ , Ccr4Spec > { Ccr4W :: new (self , 0) } }
#[doc = "capture/compare register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr4Spec ; impl crate :: RegisterSpec for Ccr4Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr4::R`](R) reader structure"] impl crate :: Readable for Ccr4Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr4::W`](W) writer structure"] impl crate :: Writable for Ccr4Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR4 to value 0"] impl crate :: Resettable for Ccr4Spec { } }
#[doc = "DCR (w) register accessor: DMA control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (w) register accessor: DMA address for full transfer\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } } }
#[doc = "Basic purpose timer"] pub type Tim14 = crate :: Periph < tim14 :: RegisterBlock , 0x4001_4000 > ; impl core :: fmt :: Debug for Tim14 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim14") . finish () } }
#[doc = "Basic purpose timer"] pub mod tim14 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , _reserved1 : [u8 ; 0x08] , dier : Dier , sr : Sr , egr : Egr , _reserved_4_ccmr1 : [u8 ; 0x04] , _reserved5 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , _reserved9 : [u8 ; 0x04] , ccr1 : Ccr1 , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/Compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/Compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (w) register accessor: event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` writer - Capture/Compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) } }
#[doc = "event generation register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 2 output enable"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 2 output enable"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 complementary output polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 complementary output polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 complementary output polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 3 - Capture/Compare 1 complementary output polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - Counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - auto-reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - auto-reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - auto-reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - auto-reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } } }
#[doc = "Basic purpose timer"] pub type Tim16 = crate :: Periph < tim16 :: RegisterBlock , 0x4001_4400 > ; impl core :: fmt :: Debug for Tim16 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim16") . finish () } }
#[doc = "Basic purpose timer"] pub mod tim16 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , _reserved2 : [u8 ; 0x04] , dier : Dier , sr : Sr , egr : Egr , _reserved_5_ccmr1 : [u8 ; 0x04] , _reserved6 : [u8 ; 0x04] , ccer : Ccer , cnt : Cnt , psc : Psc , arr : Arr , rcr : Rcr , ccr1 : Ccr1 , _reserved12 : [u8 ; 0x0c] , bdtr : Bdtr , dcr : Dcr , dmar : Dmar , } impl RegisterBlock {
#[doc = "0x00 - control register 1"]
#[inline (always)] pub const fn cr1 (& self) -> & Cr1 { & self . cr1 }
#[doc = "0x04 - control register 2"]
#[inline (always)] pub const fn cr2 (& self) -> & Cr2 { & self . cr2 }
#[doc = "0x0c - DMA/Interrupt enable register"]
#[inline (always)] pub const fn dier (& self) -> & Dier { & self . dier }
#[doc = "0x10 - status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr }
#[doc = "0x14 - event generation register"]
#[inline (always)] pub const fn egr (& self) -> & Egr { & self . egr }
#[doc = "0x18 - capture/compare mode register 1 (input mode)"]
#[inline (always)] pub const fn ccmr1_input (& self) -> & Ccmr1Input { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - capture/compare mode register 1 (output mode)"]
#[inline (always)] pub const fn ccmr1_output (& self) -> & Ccmr1Output { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x20 - capture/compare enable register"]
#[inline (always)] pub const fn ccer (& self) -> & Ccer { & self . ccer }
#[doc = "0x24 - counter"]
#[inline (always)] pub const fn cnt (& self) -> & Cnt { & self . cnt }
#[doc = "0x28 - prescaler"]
#[inline (always)] pub const fn psc (& self) -> & Psc { & self . psc }
#[doc = "0x2c - auto-reload register"]
#[inline (always)] pub const fn arr (& self) -> & Arr { & self . arr }
#[doc = "0x30 - repetition counter register"]
#[inline (always)] pub const fn rcr (& self) -> & Rcr { & self . rcr }
#[doc = "0x34 - capture/compare register 1"]
#[inline (always)] pub const fn ccr1 (& self) -> & Ccr1 { & self . ccr1 }
#[doc = "0x44 - break and dead-time register"]
#[inline (always)] pub const fn bdtr (& self) -> & Bdtr { & self . bdtr }
#[doc = "0x48 - DMA control register"]
#[inline (always)] pub const fn dcr (& self) -> & Dcr { & self . dcr }
#[doc = "0x4c - DMA address for full transfer"]
#[inline (always)] pub const fn dmar (& self) -> & Dmar { & self . dmar } }
#[doc = "CR1 (rw) register accessor: control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`] module"]
#[doc (alias = "CR1")] pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ;
#[doc = "control register 1"] pub mod cr1 {
#[doc = "Register `CR1` reader"] pub type R = crate :: R < Cr1Spec > ;
#[doc = "Register `CR1` writer"] pub type W = crate :: W < Cr1Spec > ;
#[doc = "Field `CEN` reader - Counter enable"] pub type CenR = crate :: BitReader ;
#[doc = "Field `CEN` writer - Counter enable"] pub type CenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDIS` reader - Update disable"] pub type UdisR = crate :: BitReader ;
#[doc = "Field `UDIS` writer - Update disable"] pub type UdisW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `URS` reader - Update request source"] pub type UrsR = crate :: BitReader ;
#[doc = "Field `URS` writer - Update request source"] pub type UrsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OPM` reader - One pulse mode"] pub type OpmR = crate :: BitReader ;
#[doc = "Field `OPM` writer - One pulse mode"] pub type OpmW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ARPE` reader - Auto-reload preload enable"] pub type ArpeR = crate :: BitReader ;
#[doc = "Field `ARPE` writer - Auto-reload preload enable"] pub type ArpeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CKD` reader - Clock division"] pub type CkdR = crate :: FieldReader ;
#[doc = "Field `CKD` writer - Clock division"] pub type CkdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& self) -> CenR { CenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& self) -> UdisR { UdisR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& self) -> UrsR { UrsR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - One pulse mode"]
#[inline (always)] pub fn opm (& self) -> OpmR { OpmR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& self) -> ArpeR { ArpeR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& self) -> CkdR { CkdR :: new (((self . bits >> 8) & 3) as u8) } } impl W {
#[doc = "Bit 0 - Counter enable"]
#[inline (always)] pub fn cen (& mut self) -> CenW < '_ , Cr1Spec > { CenW :: new (self , 0) }
#[doc = "Bit 1 - Update disable"]
#[inline (always)] pub fn udis (& mut self) -> UdisW < '_ , Cr1Spec > { UdisW :: new (self , 1) }
#[doc = "Bit 2 - Update request source"]
#[inline (always)] pub fn urs (& mut self) -> UrsW < '_ , Cr1Spec > { UrsW :: new (self , 2) }
#[doc = "Bit 3 - One pulse mode"]
#[inline (always)] pub fn opm (& mut self) -> OpmW < '_ , Cr1Spec > { OpmW :: new (self , 3) }
#[doc = "Bit 7 - Auto-reload preload enable"]
#[inline (always)] pub fn arpe (& mut self) -> ArpeW < '_ , Cr1Spec > { ArpeW :: new (self , 7) }
#[doc = "Bits 8:9 - Clock division"]
#[inline (always)] pub fn ckd (& mut self) -> CkdW < '_ , Cr1Spec > { CkdW :: new (self , 8) } }
#[doc = "control register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr1::R`](R) reader structure"] impl crate :: Readable for Cr1Spec { }
#[doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"] impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR1 to value 0"] impl crate :: Resettable for Cr1Spec { } }
#[doc = "CR2 (rw) register accessor: control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`] module"]
#[doc (alias = "CR2")] pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ;
#[doc = "control register 2"] pub mod cr2 {
#[doc = "Register `CR2` reader"] pub type R = crate :: R < Cr2Spec > ;
#[doc = "Register `CR2` writer"] pub type W = crate :: W < Cr2Spec > ;
#[doc = "Field `CCPC` reader - Capture/compare preloaded control"] pub type CcpcR = crate :: BitReader ;
#[doc = "Field `CCPC` writer - Capture/compare preloaded control"] pub type CcpcW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCUS` reader - Capture/compare control update selection"] pub type CcusR = crate :: BitReader ;
#[doc = "Field `CCUS` writer - Capture/compare control update selection"] pub type CcusW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CCDS` reader - Capture/Compare DMA selection"] pub type CcdsR = crate :: BitReader ;
#[doc = "Field `CCDS` writer - Capture/Compare DMA selection"] pub type CcdsW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1` reader - Output idle state 1"] pub type Ois1R = crate :: BitReader ;
#[doc = "Field `OIS1` writer - Output idle state 1"] pub type Ois1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OIS1N` reader - Output idle state 1"] pub type Ois1nR = crate :: BitReader ;
#[doc = "Field `OIS1N` writer - Output idle state 1"] pub type Ois1nW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& self) -> CcpcR { CcpcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& self) -> CcusR { CcusR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare DMA selection"]
#[inline (always)] pub fn ccds (& self) -> CcdsR { CcdsR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 8 - Output idle state 1"]
#[inline (always)] pub fn ois1 (& self) -> Ois1R { Ois1R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Output idle state 1"]
#[inline (always)] pub fn ois1n (& self) -> Ois1nR { Ois1nR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/compare preloaded control"]
#[inline (always)] pub fn ccpc (& mut self) -> CcpcW < '_ , Cr2Spec > { CcpcW :: new (self , 0) }
#[doc = "Bit 2 - Capture/compare control update selection"]
#[inline (always)] pub fn ccus (& mut self) -> CcusW < '_ , Cr2Spec > { CcusW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare DMA selection"]
#[inline (always)] pub fn ccds (& mut self) -> CcdsW < '_ , Cr2Spec > { CcdsW :: new (self , 3) }
#[doc = "Bit 8 - Output idle state 1"]
#[inline (always)] pub fn ois1 (& mut self) -> Ois1W < '_ , Cr2Spec > { Ois1W :: new (self , 8) }
#[doc = "Bit 9 - Output idle state 1"]
#[inline (always)] pub fn ois1n (& mut self) -> Ois1nW < '_ , Cr2Spec > { Ois1nW :: new (self , 9) } }
#[doc = "control register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr2::R`](R) reader structure"] impl crate :: Readable for Cr2Spec { }
#[doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"] impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR2 to value 0"] impl crate :: Resettable for Cr2Spec { } }
#[doc = "DIER (rw) register accessor: DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dier`] module"]
#[doc (alias = "DIER")] pub type Dier = crate :: Reg < dier :: DierSpec > ;
#[doc = "DMA/Interrupt enable register"] pub mod dier {
#[doc = "Register `DIER` reader"] pub type R = crate :: R < DierSpec > ;
#[doc = "Register `DIER` writer"] pub type W = crate :: W < DierSpec > ;
#[doc = "Field `UIE` reader - Update interrupt enable"] pub type UieR = crate :: BitReader ;
#[doc = "Field `UIE` writer - Update interrupt enable"] pub type UieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IE` reader - Capture/Compare 1 interrupt enable"] pub type Cc1ieR = crate :: BitReader ;
#[doc = "Field `CC1IE` writer - Capture/Compare 1 interrupt enable"] pub type Cc1ieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIE` reader - Compare interrupt enable"] pub type ComieR = crate :: BitReader ;
#[doc = "Field `COMIE` writer - Compare interrupt enable"] pub type ComieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIE` reader - break interrupt enable"] pub type BieR = crate :: BitReader ;
#[doc = "Field `BIE` writer - break interrupt enable"] pub type BieW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UDE` reader - Update DMA request enable"] pub type UdeR = crate :: BitReader ;
#[doc = "Field `UDE` writer - Update DMA request enable"] pub type UdeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1DE` reader - Capture/Compare 1 DMA request enable"] pub type Cc1deR = crate :: BitReader ;
#[doc = "Field `CC1DE` writer - Capture/Compare 1 DMA request enable"] pub type Cc1deW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& self) -> UieR { UieR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& self) -> Cc1ieR { Cc1ieR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 5 - Compare interrupt enable"]
#[inline (always)] pub fn comie (& self) -> ComieR { ComieR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - break interrupt enable"]
#[inline (always)] pub fn bie (& self) -> BieR { BieR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& self) -> UdeR { UdeR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& self) -> Cc1deR { Cc1deR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt enable"]
#[inline (always)] pub fn uie (& mut self) -> UieW < '_ , DierSpec > { UieW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt enable"]
#[inline (always)] pub fn cc1ie (& mut self) -> Cc1ieW < '_ , DierSpec > { Cc1ieW :: new (self , 1) }
#[doc = "Bit 5 - Compare interrupt enable"]
#[inline (always)] pub fn comie (& mut self) -> ComieW < '_ , DierSpec > { ComieW :: new (self , 5) }
#[doc = "Bit 7 - break interrupt enable"]
#[inline (always)] pub fn bie (& mut self) -> BieW < '_ , DierSpec > { BieW :: new (self , 7) }
#[doc = "Bit 8 - Update DMA request enable"]
#[inline (always)] pub fn ude (& mut self) -> UdeW < '_ , DierSpec > { UdeW :: new (self , 8) }
#[doc = "Bit 9 - Capture/Compare 1 DMA request enable"]
#[inline (always)] pub fn cc1de (& mut self) -> Cc1deW < '_ , DierSpec > { Cc1deW :: new (self , 9) } }
#[doc = "DMA/Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`dier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DierSpec ; impl crate :: RegisterSpec for DierSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`dier::R`](R) reader structure"] impl crate :: Readable for DierSpec { }
#[doc = "`write(|w| ..)` method takes [`dier::W`](W) writer structure"] impl crate :: Writable for DierSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIER to value 0"] impl crate :: Resettable for DierSpec { } }
#[doc = "SR (rw) register accessor: status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SrSpec > ;
#[doc = "Field `UIF` reader - Update interrupt flag"] pub type UifR = crate :: BitReader ;
#[doc = "Field `UIF` writer - Update interrupt flag"] pub type UifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1IF` reader - Capture/Compare 1 interrupt flag"] pub type Cc1ifR = crate :: BitReader ;
#[doc = "Field `CC1IF` writer - Capture/Compare 1 interrupt flag"] pub type Cc1ifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMIF` reader - COM interrupt flag"] pub type ComifR = crate :: BitReader ;
#[doc = "Field `COMIF` writer - COM interrupt flag"] pub type ComifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BIF` reader - Break interrupt flag"] pub type BifR = crate :: BitReader ;
#[doc = "Field `BIF` writer - Break interrupt flag"] pub type BifW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1OF` reader - Capture/Compare 1 overcapture flag"] pub type Cc1ofR = crate :: BitReader ;
#[doc = "Field `CC1OF` writer - Capture/Compare 1 overcapture flag"] pub type Cc1ofW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& self) -> UifR { UifR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& self) -> Cc1ifR { Cc1ifR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& self) -> ComifR { ComifR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& self) -> BifR { BifR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& self) -> Cc1ofR { Cc1ofR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update interrupt flag"]
#[inline (always)] pub fn uif (& mut self) -> UifW < '_ , SrSpec > { UifW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 interrupt flag"]
#[inline (always)] pub fn cc1if (& mut self) -> Cc1ifW < '_ , SrSpec > { Cc1ifW :: new (self , 1) }
#[doc = "Bit 5 - COM interrupt flag"]
#[inline (always)] pub fn comif (& mut self) -> ComifW < '_ , SrSpec > { ComifW :: new (self , 5) }
#[doc = "Bit 7 - Break interrupt flag"]
#[inline (always)] pub fn bif (& mut self) -> BifW < '_ , SrSpec > { BifW :: new (self , 7) }
#[doc = "Bit 9 - Capture/Compare 1 overcapture flag"]
#[inline (always)] pub fn cc1of (& mut self) -> Cc1ofW < '_ , SrSpec > { Cc1ofW :: new (self , 9) } }
#[doc = "status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } }
#[doc = "EGR (rw) register accessor: event generation register\n\nYou can [`read`](crate::Reg::read) this register and get [`egr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@egr`] module"]
#[doc (alias = "EGR")] pub type Egr = crate :: Reg < egr :: EgrSpec > ;
#[doc = "event generation register"] pub mod egr {
#[doc = "Register `EGR` reader"] pub type R = crate :: R < EgrSpec > ;
#[doc = "Register `EGR` writer"] pub type W = crate :: W < EgrSpec > ;
#[doc = "Field `UG` reader - Update generation"] pub type UgR = crate :: BitReader ;
#[doc = "Field `UG` writer - Update generation"] pub type UgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1G` reader - Capture/compare 1 generation"] pub type Cc1gR = crate :: BitReader ;
#[doc = "Field `CC1G` writer - Capture/compare 1 generation"] pub type Cc1gW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `COMG` reader - Capture/Compare control update generation"] pub type ComgR = crate :: BitReader ;
#[doc = "Field `COMG` writer - Capture/Compare control update generation"] pub type ComgW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BG` reader - Break generation"] pub type BgR = crate :: BitReader ;
#[doc = "Field `BG` writer - Break generation"] pub type BgW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& self) -> UgR { UgR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& self) -> Cc1gR { Cc1gR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 5 - Capture/Compare control update generation"]
#[inline (always)] pub fn comg (& self) -> ComgR { ComgR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - Break generation"]
#[inline (always)] pub fn bg (& self) -> BgR { BgR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Update generation"]
#[inline (always)] pub fn ug (& mut self) -> UgW < '_ , EgrSpec > { UgW :: new (self , 0) }
#[doc = "Bit 1 - Capture/compare 1 generation"]
#[inline (always)] pub fn cc1g (& mut self) -> Cc1gW < '_ , EgrSpec > { Cc1gW :: new (self , 1) }
#[doc = "Bit 5 - Capture/Compare control update generation"]
#[inline (always)] pub fn comg (& mut self) -> ComgW < '_ , EgrSpec > { ComgW :: new (self , 5) }
#[doc = "Bit 7 - Break generation"]
#[inline (always)] pub fn bg (& mut self) -> BgW < '_ , EgrSpec > { BgW :: new (self , 7) } }
#[doc = "event generation register\n\nYou can [`read`](crate::Reg::read) this register and get [`egr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`egr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct EgrSpec ; impl crate :: RegisterSpec for EgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`egr::R`](R) reader structure"] impl crate :: Readable for EgrSpec { }
#[doc = "`write(|w| ..)` method takes [`egr::W`](W) writer structure"] impl crate :: Writable for EgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets EGR to value 0"] impl crate :: Resettable for EgrSpec { } }
#[doc = "CCMR1_Output (rw) register accessor: capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_output`] module"]
#[doc (alias = "CCMR1_Output")] pub type Ccmr1Output = crate :: Reg < ccmr1_output :: Ccmr1OutputSpec > ;
#[doc = "capture/compare mode register 1 (output mode)"] pub mod ccmr1_output {
#[doc = "Register `CCMR1_Output` reader"] pub type R = crate :: R < Ccmr1OutputSpec > ;
#[doc = "Register `CCMR1_Output` writer"] pub type W = crate :: W < Ccmr1OutputSpec > ;
#[doc = "Field `CC1S` reader - Capture/Compare 2 output enable"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/Compare 2 output enable"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OC1FE` reader - Output compare 1 fast enable"] pub type Oc1feR = crate :: BitReader ;
#[doc = "Field `OC1FE` writer - Output compare 1 fast enable"] pub type Oc1feW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1PE` reader - Output compare 1 preload enable"] pub type Oc1peR = crate :: BitReader ;
#[doc = "Field `OC1PE` writer - Output compare 1 preload enable"] pub type Oc1peW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OC1M` reader - Output compare 1 mode"] pub type Oc1mR = crate :: FieldReader ;
#[doc = "Field `OC1M` writer - Output compare 1 mode"] pub type Oc1mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& self) -> Oc1feR { Oc1feR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& self) -> Oc1peR { Oc1peR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& self) -> Oc1mR { Oc1mR :: new (((self . bits >> 4) & 7) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/Compare 2 output enable"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1OutputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bit 2 - Output compare 1 fast enable"]
#[inline (always)] pub fn oc1fe (& mut self) -> Oc1feW < '_ , Ccmr1OutputSpec > { Oc1feW :: new (self , 2) }
#[doc = "Bit 3 - Output compare 1 preload enable"]
#[inline (always)] pub fn oc1pe (& mut self) -> Oc1peW < '_ , Ccmr1OutputSpec > { Oc1peW :: new (self , 3) }
#[doc = "Bits 4:6 - Output compare 1 mode"]
#[inline (always)] pub fn oc1m (& mut self) -> Oc1mW < '_ , Ccmr1OutputSpec > { Oc1mW :: new (self , 4) } }
#[doc = "capture/compare mode register 1 (output mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1OutputSpec ; impl crate :: RegisterSpec for Ccmr1OutputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_output::R`](R) reader structure"] impl crate :: Readable for Ccmr1OutputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_output::W`](W) writer structure"] impl crate :: Writable for Ccmr1OutputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Output to value 0"] impl crate :: Resettable for Ccmr1OutputSpec { } }
#[doc = "CCMR1_Input (rw) register accessor: capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccmr1_input`] module"]
#[doc (alias = "CCMR1_Input")] pub type Ccmr1Input = crate :: Reg < ccmr1_input :: Ccmr1InputSpec > ;
#[doc = "capture/compare mode register 1 (input mode)"] pub mod ccmr1_input {
#[doc = "Register `CCMR1_Input` reader"] pub type R = crate :: R < Ccmr1InputSpec > ;
#[doc = "Register `CCMR1_Input` writer"] pub type W = crate :: W < Ccmr1InputSpec > ;
#[doc = "Field `CC1S` reader - Capture/compare 1 selection"] pub type Cc1sR = crate :: FieldReader ;
#[doc = "Field `CC1S` writer - Capture/compare 1 selection"] pub type Cc1sW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1PSC` reader - Input capture 1 prescaler"] pub type Ic1pscR = crate :: FieldReader ;
#[doc = "Field `IC1PSC` writer - Input capture 1 prescaler"] pub type Ic1pscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `IC1F` reader - Input capture 1 filter"] pub type Ic1fR = crate :: FieldReader ;
#[doc = "Field `IC1F` writer - Input capture 1 filter"] pub type Ic1fW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& self) -> Cc1sR { Cc1sR :: new ((self . bits & 3) as u8) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& self) -> Ic1pscR { Ic1pscR :: new (((self . bits >> 2) & 3) as u8) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& self) -> Ic1fR { Ic1fR :: new (((self . bits >> 4) & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:1 - Capture/compare 1 selection"]
#[inline (always)] pub fn cc1s (& mut self) -> Cc1sW < '_ , Ccmr1InputSpec > { Cc1sW :: new (self , 0) }
#[doc = "Bits 2:3 - Input capture 1 prescaler"]
#[inline (always)] pub fn ic1psc (& mut self) -> Ic1pscW < '_ , Ccmr1InputSpec > { Ic1pscW :: new (self , 2) }
#[doc = "Bits 4:7 - Input capture 1 filter"]
#[inline (always)] pub fn ic1f (& mut self) -> Ic1fW < '_ , Ccmr1InputSpec > { Ic1fW :: new (self , 4) } }
#[doc = "capture/compare mode register 1 (input mode)\n\nYou can [`read`](crate::Reg::read) this register and get [`ccmr1_input::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccmr1_input::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccmr1InputSpec ; impl crate :: RegisterSpec for Ccmr1InputSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccmr1_input::R`](R) reader structure"] impl crate :: Readable for Ccmr1InputSpec { }
#[doc = "`write(|w| ..)` method takes [`ccmr1_input::W`](W) writer structure"] impl crate :: Writable for Ccmr1InputSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCMR1_Input to value 0"] impl crate :: Resettable for Ccmr1InputSpec { } }
#[doc = "CCER (rw) register accessor: capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccer`] module"]
#[doc (alias = "CCER")] pub type Ccer = crate :: Reg < ccer :: CcerSpec > ;
#[doc = "capture/compare enable register"] pub mod ccer {
#[doc = "Register `CCER` reader"] pub type R = crate :: R < CcerSpec > ;
#[doc = "Register `CCER` writer"] pub type W = crate :: W < CcerSpec > ;
#[doc = "Field `CC1E` reader - Capture/Compare 1 output enable"] pub type Cc1eR = crate :: BitReader ;
#[doc = "Field `CC1E` writer - Capture/Compare 1 output enable"] pub type Cc1eW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1P` reader - Capture/Compare 1 output polarity"] pub type Cc1pR = crate :: BitReader ;
#[doc = "Field `CC1P` writer - Capture/Compare 1 output polarity"] pub type Cc1pW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NE` reader - Capture/Compare 1 complementary output enable"] pub type Cc1neR = crate :: BitReader ;
#[doc = "Field `CC1NE` writer - Capture/Compare 1 complementary output enable"] pub type Cc1neW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CC1NP` reader - Capture/Compare 1 complementary output Polarity"] pub type Cc1npR = crate :: BitReader ;
#[doc = "Field `CC1NP` writer - Capture/Compare 1 complementary output Polarity"] pub type Cc1npW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& self) -> Cc1eR { Cc1eR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& self) -> Cc1pR { Cc1pR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& self) -> Cc1neR { Cc1neR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Capture/Compare 1 complementary output Polarity"]
#[inline (always)] pub fn cc1np (& self) -> Cc1npR { Cc1npR :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Capture/Compare 1 output enable"]
#[inline (always)] pub fn cc1e (& mut self) -> Cc1eW < '_ , CcerSpec > { Cc1eW :: new (self , 0) }
#[doc = "Bit 1 - Capture/Compare 1 output polarity"]
#[inline (always)] pub fn cc1p (& mut self) -> Cc1pW < '_ , CcerSpec > { Cc1pW :: new (self , 1) }
#[doc = "Bit 2 - Capture/Compare 1 complementary output enable"]
#[inline (always)] pub fn cc1ne (& mut self) -> Cc1neW < '_ , CcerSpec > { Cc1neW :: new (self , 2) }
#[doc = "Bit 3 - Capture/Compare 1 complementary output Polarity"]
#[inline (always)] pub fn cc1np (& mut self) -> Cc1npW < '_ , CcerSpec > { Cc1npW :: new (self , 3) } }
#[doc = "capture/compare enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcerSpec ; impl crate :: RegisterSpec for CcerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccer::R`](R) reader structure"] impl crate :: Readable for CcerSpec { }
#[doc = "`write(|w| ..)` method takes [`ccer::W`](W) writer structure"] impl crate :: Writable for CcerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCER to value 0"] impl crate :: Resettable for CcerSpec { } }
#[doc = "CNT (rw) register accessor: counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
#[doc (alias = "CNT")] pub type Cnt = crate :: Reg < cnt :: CntSpec > ;
#[doc = "counter"] pub mod cnt {
#[doc = "Register `CNT` reader"] pub type R = crate :: R < CntSpec > ;
#[doc = "Register `CNT` writer"] pub type W = crate :: W < CntSpec > ;
#[doc = "Field `CNT` reader - Counter value"] pub type CntR = crate :: FieldReader < u16 > ;
#[doc = "Field `CNT` writer - Counter value"] pub type CntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Counter value"]
#[inline (always)] pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Counter value"]
#[inline (always)] pub fn cnt (& mut self) -> CntW < '_ , CntSpec > { CntW :: new (self , 0) } }
#[doc = "counter\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt::R`](R) reader structure"] impl crate :: Readable for CntSpec { }
#[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"] impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT to value 0"] impl crate :: Resettable for CntSpec { } }
#[doc = "PSC (rw) register accessor: prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@psc`] module"]
#[doc (alias = "PSC")] pub type Psc = crate :: Reg < psc :: PscSpec > ;
#[doc = "prescaler"] pub mod psc {
#[doc = "Register `PSC` reader"] pub type R = crate :: R < PscSpec > ;
#[doc = "Register `PSC` writer"] pub type W = crate :: W < PscSpec > ;
#[doc = "Field `PSC` reader - Prescaler value"] pub type PscR = crate :: FieldReader < u16 > ;
#[doc = "Field `PSC` writer - Prescaler value"] pub type PscW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& self) -> PscR { PscR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Prescaler value"]
#[inline (always)] pub fn psc (& mut self) -> PscW < '_ , PscSpec > { PscW :: new (self , 0) } }
#[doc = "prescaler\n\nYou can [`read`](crate::Reg::read) this register and get [`psc::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`psc::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PscSpec ; impl crate :: RegisterSpec for PscSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`psc::R`](R) reader structure"] impl crate :: Readable for PscSpec { }
#[doc = "`write(|w| ..)` method takes [`psc::W`](W) writer structure"] impl crate :: Writable for PscSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PSC to value 0"] impl crate :: Resettable for PscSpec { } }
#[doc = "ARR (rw) register accessor: auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`] module"]
#[doc (alias = "ARR")] pub type Arr = crate :: Reg < arr :: ArrSpec > ;
#[doc = "auto-reload register"] pub mod arr {
#[doc = "Register `ARR` reader"] pub type R = crate :: R < ArrSpec > ;
#[doc = "Register `ARR` writer"] pub type W = crate :: W < ArrSpec > ;
#[doc = "Field `ARR` reader - Auto reload value"] pub type ArrR = crate :: FieldReader < u16 > ;
#[doc = "Field `ARR` writer - Auto reload value"] pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Auto reload value"]
#[inline (always)] pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Auto reload value"]
#[inline (always)] pub fn arr (& mut self) -> ArrW < '_ , ArrSpec > { ArrW :: new (self , 0) } }
#[doc = "auto-reload register\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`arr::R`](R) reader structure"] impl crate :: Readable for ArrSpec { }
#[doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"] impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ARR to value 0"] impl crate :: Resettable for ArrSpec { } }
#[doc = "RCR (rw) register accessor: repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rcr`] module"]
#[doc (alias = "RCR")] pub type Rcr = crate :: Reg < rcr :: RcrSpec > ;
#[doc = "repetition counter register"] pub mod rcr {
#[doc = "Register `RCR` reader"] pub type R = crate :: R < RcrSpec > ;
#[doc = "Register `RCR` writer"] pub type W = crate :: W < RcrSpec > ;
#[doc = "Field `REP` reader - Repetition counter value"] pub type RepR = crate :: FieldReader ;
#[doc = "Field `REP` writer - Repetition counter value"] pub type RepW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& self) -> RepR { RepR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Repetition counter value"]
#[inline (always)] pub fn rep (& mut self) -> RepW < '_ , RcrSpec > { RepW :: new (self , 0) } }
#[doc = "repetition counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`rcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RcrSpec ; impl crate :: RegisterSpec for RcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rcr::R`](R) reader structure"] impl crate :: Readable for RcrSpec { }
#[doc = "`write(|w| ..)` method takes [`rcr::W`](W) writer structure"] impl crate :: Writable for RcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RCR to value 0"] impl crate :: Resettable for RcrSpec { } }
#[doc = "CCR1 (rw) register accessor: capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr1`] module"]
#[doc (alias = "CCR1")] pub type Ccr1 = crate :: Reg < ccr1 :: Ccr1Spec > ;
#[doc = "capture/compare register 1"] pub mod ccr1 {
#[doc = "Register `CCR1` reader"] pub type R = crate :: R < Ccr1Spec > ;
#[doc = "Register `CCR1` writer"] pub type W = crate :: W < Ccr1Spec > ;
#[doc = "Field `CCR1` reader - Capture/Compare 1 value"] pub type Ccr1R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR1` writer - Capture/Compare 1 value"] pub type Ccr1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& self) -> Ccr1R { Ccr1R :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Capture/Compare 1 value"]
#[inline (always)] pub fn ccr1 (& mut self) -> Ccr1W < '_ , Ccr1Spec > { Ccr1W :: new (self , 0) } }
#[doc = "capture/compare register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct Ccr1Spec ; impl crate :: RegisterSpec for Ccr1Spec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr1::R`](R) reader structure"] impl crate :: Readable for Ccr1Spec { }
#[doc = "`write(|w| ..)` method takes [`ccr1::W`](W) writer structure"] impl crate :: Writable for Ccr1Spec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR1 to value 0"] impl crate :: Resettable for Ccr1Spec { } }
#[doc = "BDTR (rw) register accessor: break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bdtr`] module"]
#[doc (alias = "BDTR")] pub type Bdtr = crate :: Reg < bdtr :: BdtrSpec > ;
#[doc = "break and dead-time register"] pub mod bdtr {
#[doc = "Register `BDTR` reader"] pub type R = crate :: R < BdtrSpec > ;
#[doc = "Register `BDTR` writer"] pub type W = crate :: W < BdtrSpec > ;
#[doc = "Field `DTG` reader - Dead-time generation setup"] pub type DtgR = crate :: FieldReader ;
#[doc = "Field `DTG` writer - Dead-time generation setup"] pub type DtgW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `LOCK` reader - Lock configuration"] pub type LockR = crate :: FieldReader ;
#[doc = "Field `LOCK` writer - Lock configuration"] pub type LockW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `OSSI` reader - Off-state selection for idle mode"] pub type OssiR = crate :: BitReader ;
#[doc = "Field `OSSI` writer - Off-state selection for idle mode"] pub type OssiW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSSR` reader - Off-state selection for run mode"] pub type OssrR = crate :: BitReader ;
#[doc = "Field `OSSR` writer - Off-state selection for run mode"] pub type OssrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKE` reader - Break enable"] pub type BkeR = crate :: BitReader ;
#[doc = "Field `BKE` writer - Break enable"] pub type BkeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BKP` reader - Break polarity"] pub type BkpR = crate :: BitReader ;
#[doc = "Field `BKP` writer - Break polarity"] pub type BkpW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AOE` reader - Automatic output enable"] pub type AoeR = crate :: BitReader ;
#[doc = "Field `AOE` writer - Automatic output enable"] pub type AoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MOE` reader - Main output enable"] pub type MoeR = crate :: BitReader ;
#[doc = "Field `MOE` writer - Main output enable"] pub type MoeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:7 - Dead-time generation setup"]
#[inline (always)] pub fn dtg (& self) -> DtgR { DtgR :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& self) -> LockR { LockR :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 10 - Off-state selection for idle mode"]
#[inline (always)] pub fn ossi (& self) -> OssiR { OssiR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Off-state selection for run mode"]
#[inline (always)] pub fn ossr (& self) -> OssrR { OssrR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& self) -> BkeR { BkeR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& self) -> BkpR { BkpR :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& self) -> AoeR { AoeR :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& self) -> MoeR { MoeR :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:7 - Dead-time generation setup"]
#[inline (always)] pub fn dtg (& mut self) -> DtgW < '_ , BdtrSpec > { DtgW :: new (self , 0) }
#[doc = "Bits 8:9 - Lock configuration"]
#[inline (always)] pub fn lock (& mut self) -> LockW < '_ , BdtrSpec > { LockW :: new (self , 8) }
#[doc = "Bit 10 - Off-state selection for idle mode"]
#[inline (always)] pub fn ossi (& mut self) -> OssiW < '_ , BdtrSpec > { OssiW :: new (self , 10) }
#[doc = "Bit 11 - Off-state selection for run mode"]
#[inline (always)] pub fn ossr (& mut self) -> OssrW < '_ , BdtrSpec > { OssrW :: new (self , 11) }
#[doc = "Bit 12 - Break enable"]
#[inline (always)] pub fn bke (& mut self) -> BkeW < '_ , BdtrSpec > { BkeW :: new (self , 12) }
#[doc = "Bit 13 - Break polarity"]
#[inline (always)] pub fn bkp (& mut self) -> BkpW < '_ , BdtrSpec > { BkpW :: new (self , 13) }
#[doc = "Bit 14 - Automatic output enable"]
#[inline (always)] pub fn aoe (& mut self) -> AoeW < '_ , BdtrSpec > { AoeW :: new (self , 14) }
#[doc = "Bit 15 - Main output enable"]
#[inline (always)] pub fn moe (& mut self) -> MoeW < '_ , BdtrSpec > { MoeW :: new (self , 15) } }
#[doc = "break and dead-time register\n\nYou can [`read`](crate::Reg::read) this register and get [`bdtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bdtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BdtrSpec ; impl crate :: RegisterSpec for BdtrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`bdtr::R`](R) reader structure"] impl crate :: Readable for BdtrSpec { }
#[doc = "`write(|w| ..)` method takes [`bdtr::W`](W) writer structure"] impl crate :: Writable for BdtrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BDTR to value 0"] impl crate :: Resettable for BdtrSpec { } }
#[doc = "DCR (w) register accessor: DMA control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dcr`] module"]
#[doc (alias = "DCR")] pub type Dcr = crate :: Reg < dcr :: DcrSpec > ;
#[doc = "DMA control register"] pub mod dcr {
#[doc = "Register `DCR` writer"] pub type W = crate :: W < DcrSpec > ;
#[doc = "Field `DBA` writer - DMA base address"] pub type DbaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `DBL` writer - DMA burst length"] pub type DblW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ; impl W {
#[doc = "Bits 0:4 - DMA base address"]
#[inline (always)] pub fn dba (& mut self) -> DbaW < '_ , DcrSpec > { DbaW :: new (self , 0) }
#[doc = "Bits 8:12 - DMA burst length"]
#[inline (always)] pub fn dbl (& mut self) -> DblW < '_ , DcrSpec > { DblW :: new (self , 8) } }
#[doc = "DMA control register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dcr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DcrSpec ; impl crate :: RegisterSpec for DcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`dcr::W`](W) writer structure"] impl crate :: Writable for DcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DCR to value 0"] impl crate :: Resettable for DcrSpec { } }
#[doc = "DMAR (w) register accessor: DMA address for full transfer\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dmar`] module"]
#[doc (alias = "DMAR")] pub type Dmar = crate :: Reg < dmar :: DmarSpec > ;
#[doc = "DMA address for full transfer"] pub mod dmar {
#[doc = "Register `DMAR` writer"] pub type W = crate :: W < DmarSpec > ;
#[doc = "Field `DMAB` writer - DMA register for burst accesses"] pub type DmabW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bits 0:15 - DMA register for burst accesses"]
#[inline (always)] pub fn dmab (& mut self) -> DmabW < '_ , DmarSpec > { DmabW :: new (self , 0) } }
#[doc = "DMA address for full transfer\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dmar::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DmarSpec ; impl crate :: RegisterSpec for DmarSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`dmar::W`](W) writer structure"] impl crate :: Writable for DmarSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMAR to value 0"] impl crate :: Resettable for DmarSpec { } } }
#[doc = "Basic purpose timer"] pub type Tim17 = crate :: Periph < tim16 :: RegisterBlock , 0x4001_4800 > ; impl core :: fmt :: Debug for Tim17 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tim17") . finish () } }
#[doc = "Basic purpose timer"] pub use self :: tim16 as tim17 ;
#[doc = "Universal asynchronous receiver transmitter"] pub type Uart1 = crate :: Periph < uart1 :: RegisterBlock , 0x4001_3800 > ; impl core :: fmt :: Debug for Uart1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart1") . finish () } }
#[doc = "Universal asynchronous receiver transmitter"] pub mod uart1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { tdr : Tdr , rdr : Rdr , csr : Csr , isr : Isr , ier : Ier , icr : Icr , gcr : Gcr , ccr : Ccr , brr : Brr , fra : Fra , rxaddr : Rxaddr , rxmask : Rxmask , scr : Scr , } impl RegisterBlock {
#[doc = "0x00 - Transmit data register"]
#[inline (always)] pub const fn tdr (& self) -> & Tdr { & self . tdr }
#[doc = "0x04 - Receive data register"]
#[inline (always)] pub const fn rdr (& self) -> & Rdr { & self . rdr }
#[doc = "0x08 - Current status register"]
#[inline (always)] pub const fn csr (& self) -> & Csr { & self . csr }
#[doc = "0x0c - Interrupt status register"]
#[inline (always)] pub const fn isr (& self) -> & Isr { & self . isr }
#[doc = "0x10 - Interrupt enable register"]
#[inline (always)] pub const fn ier (& self) -> & Ier { & self . ier }
#[doc = "0x14 - ICR"]
#[inline (always)] pub const fn icr (& self) -> & Icr { & self . icr }
#[doc = "0x18 - Global control register"]
#[inline (always)] pub const fn gcr (& self) -> & Gcr { & self . gcr }
#[doc = "0x1c - common control register"]
#[inline (always)] pub const fn ccr (& self) -> & Ccr { & self . ccr }
#[doc = "0x20 - Baud rate register"]
#[inline (always)] pub const fn brr (& self) -> & Brr { & self . brr }
#[doc = "0x24 - Fractional baud rate register"]
#[inline (always)] pub const fn fra (& self) -> & Fra { & self . fra }
#[doc = "0x28 - RXADDR"]
#[inline (always)] pub const fn rxaddr (& self) -> & Rxaddr { & self . rxaddr }
#[doc = "0x2c - RXMASK"]
#[inline (always)] pub const fn rxmask (& self) -> & Rxmask { & self . rxmask }
#[doc = "0x30 - SCR"]
#[inline (always)] pub const fn scr (& self) -> & Scr { & self . scr } }
#[doc = "TDR (rw) register accessor: Transmit data register\n\nYou can [`read`](crate::Reg::read) this register and get [`tdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tdr`] module"]
#[doc (alias = "TDR")] pub type Tdr = crate :: Reg < tdr :: TdrSpec > ;
#[doc = "Transmit data register"] pub mod tdr {
#[doc = "Register `TDR` reader"] pub type R = crate :: R < TdrSpec > ;
#[doc = "Register `TDR` writer"] pub type W = crate :: W < TdrSpec > ;
#[doc = "Field `TXREG` reader - Transmit data register"] pub type TxregR = crate :: FieldReader ;
#[doc = "Field `TXREG` writer - Transmit data register"] pub type TxregW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Transmit data register"]
#[inline (always)] pub fn txreg (& self) -> TxregR { TxregR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Transmit data register"]
#[inline (always)] pub fn txreg (& mut self) -> TxregW < '_ , TdrSpec > { TxregW :: new (self , 0) } }
#[doc = "Transmit data register\n\nYou can [`read`](crate::Reg::read) this register and get [`tdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TdrSpec ; impl crate :: RegisterSpec for TdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`tdr::R`](R) reader structure"] impl crate :: Readable for TdrSpec { }
#[doc = "`write(|w| ..)` method takes [`tdr::W`](W) writer structure"] impl crate :: Writable for TdrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TDR to value 0"] impl crate :: Resettable for TdrSpec { } }
#[doc = "RDR (r) register accessor: Receive data register\n\nYou can [`read`](crate::Reg::read) this register and get [`rdr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rdr`] module"]
#[doc (alias = "RDR")] pub type Rdr = crate :: Reg < rdr :: RdrSpec > ;
#[doc = "Receive data register"] pub mod rdr {
#[doc = "Register `RDR` reader"] pub type R = crate :: R < RdrSpec > ;
#[doc = "Field `RXREG` reader - Receive data register"] pub type RxregR = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - Receive data register"]
#[inline (always)] pub fn rxreg (& self) -> RxregR { RxregR :: new ((self . bits & 0xff) as u8) } }
#[doc = "Receive data register\n\nYou can [`read`](crate::Reg::read) this register and get [`rdr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RdrSpec ; impl crate :: RegisterSpec for RdrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rdr::R`](R) reader structure"] impl crate :: Readable for RdrSpec { }
#[doc = "`reset()` method sets RDR to value 0"] impl crate :: Resettable for RdrSpec { } }
#[doc = "CSR (r) register accessor: Current status register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@csr`] module"]
#[doc (alias = "CSR")] pub type Csr = crate :: Reg < csr :: CsrSpec > ;
#[doc = "Current status register"] pub mod csr {
#[doc = "Register `CSR` reader"] pub type R = crate :: R < CsrSpec > ;
#[doc = "Field `TXC` reader - Transmit complete flag bit"] pub type TxcR = crate :: BitReader ;
#[doc = "Field `RXAVL` reader - Receive valid data flag bit"] pub type RxavlR = crate :: BitReader ;
#[doc = "Field `TXFULL` reader - Transmit buffer full flag bit"] pub type TxfullR = crate :: BitReader ;
#[doc = "Field `TXBUF_EMPTY` reader - Transmit buffer empty flag bit"] pub type TxbufEmptyR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Transmit complete flag bit"]
#[inline (always)] pub fn txc (& self) -> TxcR { TxcR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receive valid data flag bit"]
#[inline (always)] pub fn rxavl (& self) -> RxavlR { RxavlR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Transmit buffer full flag bit"]
#[inline (always)] pub fn txfull (& self) -> TxfullR { TxfullR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Transmit buffer empty flag bit"]
#[inline (always)] pub fn txbuf_empty (& self) -> TxbufEmptyR { TxbufEmptyR :: new (((self . bits >> 3) & 1) != 0) } }
#[doc = "Current status register\n\nYou can [`read`](crate::Reg::read) this register and get [`csr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CsrSpec ; impl crate :: RegisterSpec for CsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`csr::R`](R) reader structure"] impl crate :: Readable for CsrSpec { }
#[doc = "`reset()` method sets CSR to value 0x09"] impl crate :: Resettable for CsrSpec { const RESET_VALUE : u32 = 0x09 ; } }
#[doc = "ISR (r) register accessor: Interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`] module"]
#[doc (alias = "ISR")] pub type Isr = crate :: Reg < isr :: IsrSpec > ;
#[doc = "Interrupt status register"] pub mod isr {
#[doc = "Register `ISR` reader"] pub type R = crate :: R < IsrSpec > ;
#[doc = "Field `TX_INTF` reader - Transmit buffer empty interrupt flag bit"] pub type TxIntfR = crate :: BitReader ;
#[doc = "Field `RX_INTF` reader - Receive valid data interrupt flag bit"] pub type RxIntfR = crate :: BitReader ;
#[doc = "Field `TXC_INTF` reader - UART Transmit Complete Interrupt Flag bit"] pub type TxcIntfR = crate :: BitReader ;
#[doc = "Field `RXOERR_INTF` reader - Receive overflow error interrupt flag bit"] pub type RxoerrIntfR = crate :: BitReader ;
#[doc = "Field `RXPERR_INTF` reader - Parity error interrupt flag bit"] pub type RxperrIntfR = crate :: BitReader ;
#[doc = "Field `RXFERR_INTF` reader - Frame error interrupt flag bit"] pub type RxferrIntfR = crate :: BitReader ;
#[doc = "Field `RXBRK_INTF` reader - Receive frame break interrupt flag bit"] pub type RxbrkIntfR = crate :: BitReader ;
#[doc = "Field `TXBRK_INTF` reader - Transmit Break Frame Interrupt Flag Bit"] pub type TxbrkIntfR = crate :: BitReader ;
#[doc = "Field `RXB8_INTF` reader - Receive Bit 8 Interrupt Flag Bit"] pub type Rxb8IntfR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Transmit buffer empty interrupt flag bit"]
#[inline (always)] pub fn tx_intf (& self) -> TxIntfR { TxIntfR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receive valid data interrupt flag bit"]
#[inline (always)] pub fn rx_intf (& self) -> RxIntfR { RxIntfR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - UART Transmit Complete Interrupt Flag bit"]
#[inline (always)] pub fn txc_intf (& self) -> TxcIntfR { TxcIntfR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Receive overflow error interrupt flag bit"]
#[inline (always)] pub fn rxoerr_intf (& self) -> RxoerrIntfR { RxoerrIntfR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Parity error interrupt flag bit"]
#[inline (always)] pub fn rxperr_intf (& self) -> RxperrIntfR { RxperrIntfR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Frame error interrupt flag bit"]
#[inline (always)] pub fn rxferr_intf (& self) -> RxferrIntfR { RxferrIntfR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Receive frame break interrupt flag bit"]
#[inline (always)] pub fn rxbrk_intf (& self) -> RxbrkIntfR { RxbrkIntfR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transmit Break Frame Interrupt Flag Bit"]
#[inline (always)] pub fn txbrk_intf (& self) -> TxbrkIntfR { TxbrkIntfR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Receive Bit 8 Interrupt Flag Bit"]
#[inline (always)] pub fn rxb8_intf (& self) -> Rxb8IntfR { Rxb8IntfR :: new (((self . bits >> 8) & 1) != 0) } }
#[doc = "Interrupt status register\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr::R`](R) reader structure"] impl crate :: Readable for IsrSpec { }
#[doc = "`reset()` method sets ISR to value 0"] impl crate :: Resettable for IsrSpec { } }
#[doc = "IER (rw) register accessor: Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"]
#[doc (alias = "IER")] pub type Ier = crate :: Reg < ier :: IerSpec > ;
#[doc = "Interrupt enable register"] pub mod ier {
#[doc = "Register `IER` reader"] pub type R = crate :: R < IerSpec > ;
#[doc = "Register `IER` writer"] pub type W = crate :: W < IerSpec > ;
#[doc = "Field `TXIEN` reader - Transmit buffer empty interrupt enable bit"] pub type TxienR = crate :: BitReader ;
#[doc = "Field `TXIEN` writer - Transmit buffer empty interrupt enable bit"] pub type TxienW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXIEN` reader - Receive buffer interrupt enable bit"] pub type RxienR = crate :: BitReader ;
#[doc = "Field `RXIEN` writer - Receive buffer interrupt enable bit"] pub type RxienW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXC_IEN` reader - Transmit complete interrupt enable bit"] pub type TxcIenR = crate :: BitReader ;
#[doc = "Field `TXC_IEN` writer - Transmit complete interrupt enable bit"] pub type TxcIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXOERREN` reader - Receive overflow error interrupt enable bit"] pub type RxoerrenR = crate :: BitReader ;
#[doc = "Field `RXOERREN` writer - Receive overflow error interrupt enable bit"] pub type RxoerrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXPERREN` reader - Parity error interrupt enable bit"] pub type RxperrenR = crate :: BitReader ;
#[doc = "Field `RXPERREN` writer - Parity error interrupt enable bit"] pub type RxperrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFERREN` reader - Frame error interrupt enable bit"] pub type RxferrenR = crate :: BitReader ;
#[doc = "Field `RXFERREN` writer - Frame error interrupt enable bit"] pub type RxferrenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXBRKEN` reader - Receive frame break interrupt enable bit"] pub type RxbrkenR = crate :: BitReader ;
#[doc = "Field `RXBRKEN` writer - Receive frame break interrupt enable bit"] pub type RxbrkenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXBRK_IEN` reader - Transmit Break Frame Interrupt Enable Bit"] pub type TxbrkIenR = crate :: BitReader ;
#[doc = "Field `TXBRK_IEN` writer - Transmit Break Frame Interrupt Enable Bit"] pub type TxbrkIenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXB8_IEN` reader - Receive Bit 8 Interrupt Enable Bit"] pub type Rxb8IenR = crate :: BitReader ;
#[doc = "Field `RXB8_IEN` writer - Receive Bit 8 Interrupt Enable Bit"] pub type Rxb8IenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Transmit buffer empty interrupt enable bit"]
#[inline (always)] pub fn txien (& self) -> TxienR { TxienR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Receive buffer interrupt enable bit"]
#[inline (always)] pub fn rxien (& self) -> RxienR { RxienR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Transmit complete interrupt enable bit"]
#[inline (always)] pub fn txc_ien (& self) -> TxcIenR { TxcIenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Receive overflow error interrupt enable bit"]
#[inline (always)] pub fn rxoerren (& self) -> RxoerrenR { RxoerrenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Parity error interrupt enable bit"]
#[inline (always)] pub fn rxperren (& self) -> RxperrenR { RxperrenR :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Frame error interrupt enable bit"]
#[inline (always)] pub fn rxferren (& self) -> RxferrenR { RxferrenR :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - Receive frame break interrupt enable bit"]
#[inline (always)] pub fn rxbrken (& self) -> RxbrkenR { RxbrkenR :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Transmit Break Frame Interrupt Enable Bit"]
#[inline (always)] pub fn txbrk_ien (& self) -> TxbrkIenR { TxbrkIenR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Receive Bit 8 Interrupt Enable Bit"]
#[inline (always)] pub fn rxb8_ien (& self) -> Rxb8IenR { Rxb8IenR :: new (((self . bits >> 8) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Transmit buffer empty interrupt enable bit"]
#[inline (always)] pub fn txien (& mut self) -> TxienW < '_ , IerSpec > { TxienW :: new (self , 0) }
#[doc = "Bit 1 - Receive buffer interrupt enable bit"]
#[inline (always)] pub fn rxien (& mut self) -> RxienW < '_ , IerSpec > { RxienW :: new (self , 1) }
#[doc = "Bit 2 - Transmit complete interrupt enable bit"]
#[inline (always)] pub fn txc_ien (& mut self) -> TxcIenW < '_ , IerSpec > { TxcIenW :: new (self , 2) }
#[doc = "Bit 3 - Receive overflow error interrupt enable bit"]
#[inline (always)] pub fn rxoerren (& mut self) -> RxoerrenW < '_ , IerSpec > { RxoerrenW :: new (self , 3) }
#[doc = "Bit 4 - Parity error interrupt enable bit"]
#[inline (always)] pub fn rxperren (& mut self) -> RxperrenW < '_ , IerSpec > { RxperrenW :: new (self , 4) }
#[doc = "Bit 5 - Frame error interrupt enable bit"]
#[inline (always)] pub fn rxferren (& mut self) -> RxferrenW < '_ , IerSpec > { RxferrenW :: new (self , 5) }
#[doc = "Bit 6 - Receive frame break interrupt enable bit"]
#[inline (always)] pub fn rxbrken (& mut self) -> RxbrkenW < '_ , IerSpec > { RxbrkenW :: new (self , 6) }
#[doc = "Bit 7 - Transmit Break Frame Interrupt Enable Bit"]
#[inline (always)] pub fn txbrk_ien (& mut self) -> TxbrkIenW < '_ , IerSpec > { TxbrkIenW :: new (self , 7) }
#[doc = "Bit 8 - Receive Bit 8 Interrupt Enable Bit"]
#[inline (always)] pub fn rxb8_ien (& mut self) -> Rxb8IenW < '_ , IerSpec > { Rxb8IenW :: new (self , 8) } }
#[doc = "Interrupt enable register\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IerSpec ; impl crate :: RegisterSpec for IerSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ier::R`](R) reader structure"] impl crate :: Readable for IerSpec { }
#[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"] impl crate :: Writable for IerSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IER to value 0"] impl crate :: Resettable for IerSpec { } }
#[doc = "ICR (w) register accessor: ICR\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`] module"]
#[doc (alias = "ICR")] pub type Icr = crate :: Reg < icr :: IcrSpec > ;
#[doc = "ICR"] pub mod icr {
#[doc = "Register `ICR` writer"] pub type W = crate :: W < IcrSpec > ;
#[doc = "Field `TXICLR` writer - Transmit buffer empty interrupt clear bit"] pub type TxiclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXICLR` writer - Receive interrupt clear bit"] pub type RxiclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXC_CLR` writer - Transmit complete interrupt clear bit"] pub type TxcClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXOERRCLR` writer - Receive overflow error interrupt clear bit"] pub type RxoerrclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXPERRCLR` writer - Parity error interrupt clear bit"] pub type RxperrclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXFERRCLR` writer - Frame error interrupt clear bit"] pub type RxferrclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXBRKCLR` writer - Receive frame break interrupt clear bit"] pub type RxbrkclrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXBRK_CLR` writer - Transmit Break Frame Interrupt clear Bit"] pub type TxbrkClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXB8_CLR` writer - Receive Bit 8 Interrupt clear Bit"] pub type Rxb8ClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W {
#[doc = "Bit 0 - Transmit buffer empty interrupt clear bit"]
#[inline (always)] pub fn txiclr (& mut self) -> TxiclrW < '_ , IcrSpec > { TxiclrW :: new (self , 0) }
#[doc = "Bit 1 - Receive interrupt clear bit"]
#[inline (always)] pub fn rxiclr (& mut self) -> RxiclrW < '_ , IcrSpec > { RxiclrW :: new (self , 1) }
#[doc = "Bit 2 - Transmit complete interrupt clear bit"]
#[inline (always)] pub fn txc_clr (& mut self) -> TxcClrW < '_ , IcrSpec > { TxcClrW :: new (self , 2) }
#[doc = "Bit 3 - Receive overflow error interrupt clear bit"]
#[inline (always)] pub fn rxoerrclr (& mut self) -> RxoerrclrW < '_ , IcrSpec > { RxoerrclrW :: new (self , 3) }
#[doc = "Bit 4 - Parity error interrupt clear bit"]
#[inline (always)] pub fn rxperrclr (& mut self) -> RxperrclrW < '_ , IcrSpec > { RxperrclrW :: new (self , 4) }
#[doc = "Bit 5 - Frame error interrupt clear bit"]
#[inline (always)] pub fn rxferrclr (& mut self) -> RxferrclrW < '_ , IcrSpec > { RxferrclrW :: new (self , 5) }
#[doc = "Bit 6 - Receive frame break interrupt clear bit"]
#[inline (always)] pub fn rxbrkclr (& mut self) -> RxbrkclrW < '_ , IcrSpec > { RxbrkclrW :: new (self , 6) }
#[doc = "Bit 7 - Transmit Break Frame Interrupt clear Bit"]
#[inline (always)] pub fn txbrk_clr (& mut self) -> TxbrkClrW < '_ , IcrSpec > { TxbrkClrW :: new (self , 7) }
#[doc = "Bit 8 - Receive Bit 8 Interrupt clear Bit"]
#[inline (always)] pub fn rxb8_clr (& mut self) -> Rxb8ClrW < '_ , IcrSpec > { Rxb8ClrW :: new (self , 8) } }
#[doc = "ICR\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"] impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ICR to value 0"] impl crate :: Resettable for IcrSpec { } }
#[doc = "GCR (rw) register accessor: Global control register\n\nYou can [`read`](crate::Reg::read) this register and get [`gcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gcr`] module"]
#[doc (alias = "GCR")] pub type Gcr = crate :: Reg < gcr :: GcrSpec > ;
#[doc = "Global control register"] pub mod gcr {
#[doc = "Register `GCR` reader"] pub type R = crate :: R < GcrSpec > ;
#[doc = "Register `GCR` writer"] pub type W = crate :: W < GcrSpec > ;
#[doc = "Field `UARTEN` reader - UART mode selection bit"] pub type UartenR = crate :: BitReader ;
#[doc = "Field `UARTEN` writer - UART mode selection bit"] pub type UartenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMAMODE` reader - DMA mode selection bit"] pub type DmamodeR = crate :: BitReader ;
#[doc = "Field `DMAMODE` writer - DMA mode selection bit"] pub type DmamodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AUTOFLOWEN` reader - Automatic flow control enable bit"] pub type AutoflowenR = crate :: BitReader ;
#[doc = "Field `AUTOFLOWEN` writer - Automatic flow control enable bit"] pub type AutoflowenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RXEN` reader - Enable receive"] pub type RxenR = crate :: BitReader ;
#[doc = "Field `RXEN` writer - Enable receive"] pub type RxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TXEN` reader - Enable transmit"] pub type TxenR = crate :: BitReader ;
#[doc = "Field `TXEN` writer - Enable transmit"] pub type TxenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - UART mode selection bit"]
#[inline (always)] pub fn uarten (& self) -> UartenR { UartenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - DMA mode selection bit"]
#[inline (always)] pub fn dmamode (& self) -> DmamodeR { DmamodeR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Automatic flow control enable bit"]
#[inline (always)] pub fn autoflowen (& self) -> AutoflowenR { AutoflowenR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - Enable receive"]
#[inline (always)] pub fn rxen (& self) -> RxenR { RxenR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - Enable transmit"]
#[inline (always)] pub fn txen (& self) -> TxenR { TxenR :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - UART mode selection bit"]
#[inline (always)] pub fn uarten (& mut self) -> UartenW < '_ , GcrSpec > { UartenW :: new (self , 0) }
#[doc = "Bit 1 - DMA mode selection bit"]
#[inline (always)] pub fn dmamode (& mut self) -> DmamodeW < '_ , GcrSpec > { DmamodeW :: new (self , 1) }
#[doc = "Bit 2 - Automatic flow control enable bit"]
#[inline (always)] pub fn autoflowen (& mut self) -> AutoflowenW < '_ , GcrSpec > { AutoflowenW :: new (self , 2) }
#[doc = "Bit 3 - Enable receive"]
#[inline (always)] pub fn rxen (& mut self) -> RxenW < '_ , GcrSpec > { RxenW :: new (self , 3) }
#[doc = "Bit 4 - Enable transmit"]
#[inline (always)] pub fn txen (& mut self) -> TxenW < '_ , GcrSpec > { TxenW :: new (self , 4) } }
#[doc = "Global control register\n\nYou can [`read`](crate::Reg::read) this register and get [`gcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`gcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GcrSpec ; impl crate :: RegisterSpec for GcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`gcr::R`](R) reader structure"] impl crate :: Readable for GcrSpec { }
#[doc = "`write(|w| ..)` method takes [`gcr::W`](W) writer structure"] impl crate :: Writable for GcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets GCR to value 0"] impl crate :: Resettable for GcrSpec { } }
#[doc = "CCR (rw) register accessor: common control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ccr`] module"]
#[doc (alias = "CCR")] pub type Ccr = crate :: Reg < ccr :: CcrSpec > ;
#[doc = "common control register"] pub mod ccr {
#[doc = "Register `CCR` reader"] pub type R = crate :: R < CcrSpec > ;
#[doc = "Register `CCR` writer"] pub type W = crate :: W < CcrSpec > ;
#[doc = "Field `PEN` reader - Parity enable bit"] pub type PenR = crate :: BitReader ;
#[doc = "Field `PEN` writer - Parity enable bit"] pub type PenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PSEL` reader - Parity selection bit"] pub type PselR = crate :: BitReader ;
#[doc = "Field `PSEL` writer - Parity selection bit"] pub type PselW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SPB0` reader - Stop bit 0 selection"] pub type Spb0R = crate :: BitReader ;
#[doc = "Field `SPB0` writer - Stop bit 0 selection"] pub type Spb0W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BRK` reader - UART transmit frame break"] pub type BrkR = crate :: BitReader ;
#[doc = "Field `BRK` writer - UART transmit frame break"] pub type BrkW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CHAR` reader - UART width bit"] pub type CharR = crate :: FieldReader ;
#[doc = "Field `CHAR` writer - UART width bit"] pub type CharW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SPB1` reader - Stop bit 1 selection bit"] pub type Spb1R = crate :: BitReader ;
#[doc = "Field `SPB1` writer - Stop bit 1 selection bit"] pub type Spb1W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B8RXD` reader - Synchronous frame receive"] pub type B8rxdR = crate :: BitReader ;
#[doc = "Field `B8RXD` writer - Synchronous frame receive"] pub type B8rxdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B8TXD` reader - Synchronous frame transmit"] pub type B8txdR = crate :: BitReader ;
#[doc = "Field `B8TXD` writer - Synchronous frame transmit"] pub type B8txdW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B8POL` reader - Synchronous frame polarity control bit"] pub type B8polR = crate :: BitReader ;
#[doc = "Field `B8POL` writer - Synchronous frame polarity control bit"] pub type B8polW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B8TOG` reader - Synchronous frame auto toggle bit"] pub type B8togR = crate :: BitReader ;
#[doc = "Field `B8TOG` writer - Synchronous frame auto toggle bit"] pub type B8togW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `B8EN` reader - Synchronous frame enable bit"] pub type B8enR = crate :: BitReader ;
#[doc = "Field `B8EN` writer - Synchronous frame enable bit"] pub type B8enW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RWU` reader - Receive wake up method"] pub type RwuR = crate :: BitReader ;
#[doc = "Field `RWU` writer - Receive wake up method"] pub type RwuW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAKE` reader - Wake up method"] pub type WakeR = crate :: BitReader ;
#[doc = "Field `WAKE` writer - Wake up method"] pub type WakeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Parity enable bit"]
#[inline (always)] pub fn pen (& self) -> PenR { PenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Parity selection bit"]
#[inline (always)] pub fn psel (& self) -> PselR { PselR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Stop bit 0 selection"]
#[inline (always)] pub fn spb0 (& self) -> Spb0R { Spb0R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - UART transmit frame break"]
#[inline (always)] pub fn brk (& self) -> BrkR { BrkR :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - UART width bit"]
#[inline (always)] pub fn char (& self) -> CharR { CharR :: new (((self . bits >> 4) & 3) as u8) }
#[doc = "Bit 6 - Stop bit 1 selection bit"]
#[inline (always)] pub fn spb1 (& self) -> Spb1R { Spb1R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - Synchronous frame receive"]
#[inline (always)] pub fn b8rxd (& self) -> B8rxdR { B8rxdR :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - Synchronous frame transmit"]
#[inline (always)] pub fn b8txd (& self) -> B8txdR { B8txdR :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - Synchronous frame polarity control bit"]
#[inline (always)] pub fn b8pol (& self) -> B8polR { B8polR :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - Synchronous frame auto toggle bit"]
#[inline (always)] pub fn b8tog (& self) -> B8togR { B8togR :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - Synchronous frame enable bit"]
#[inline (always)] pub fn b8en (& self) -> B8enR { B8enR :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - Receive wake up method"]
#[inline (always)] pub fn rwu (& self) -> RwuR { RwuR :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - Wake up method"]
#[inline (always)] pub fn wake (& self) -> WakeR { WakeR :: new (((self . bits >> 13) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Parity enable bit"]
#[inline (always)] pub fn pen (& mut self) -> PenW < '_ , CcrSpec > { PenW :: new (self , 0) }
#[doc = "Bit 1 - Parity selection bit"]
#[inline (always)] pub fn psel (& mut self) -> PselW < '_ , CcrSpec > { PselW :: new (self , 1) }
#[doc = "Bit 2 - Stop bit 0 selection"]
#[inline (always)] pub fn spb0 (& mut self) -> Spb0W < '_ , CcrSpec > { Spb0W :: new (self , 2) }
#[doc = "Bit 3 - UART transmit frame break"]
#[inline (always)] pub fn brk (& mut self) -> BrkW < '_ , CcrSpec > { BrkW :: new (self , 3) }
#[doc = "Bits 4:5 - UART width bit"]
#[inline (always)] pub fn char (& mut self) -> CharW < '_ , CcrSpec > { CharW :: new (self , 4) }
#[doc = "Bit 6 - Stop bit 1 selection bit"]
#[inline (always)] pub fn spb1 (& mut self) -> Spb1W < '_ , CcrSpec > { Spb1W :: new (self , 6) }
#[doc = "Bit 7 - Synchronous frame receive"]
#[inline (always)] pub fn b8rxd (& mut self) -> B8rxdW < '_ , CcrSpec > { B8rxdW :: new (self , 7) }
#[doc = "Bit 8 - Synchronous frame transmit"]
#[inline (always)] pub fn b8txd (& mut self) -> B8txdW < '_ , CcrSpec > { B8txdW :: new (self , 8) }
#[doc = "Bit 9 - Synchronous frame polarity control bit"]
#[inline (always)] pub fn b8pol (& mut self) -> B8polW < '_ , CcrSpec > { B8polW :: new (self , 9) }
#[doc = "Bit 10 - Synchronous frame auto toggle bit"]
#[inline (always)] pub fn b8tog (& mut self) -> B8togW < '_ , CcrSpec > { B8togW :: new (self , 10) }
#[doc = "Bit 11 - Synchronous frame enable bit"]
#[inline (always)] pub fn b8en (& mut self) -> B8enW < '_ , CcrSpec > { B8enW :: new (self , 11) }
#[doc = "Bit 12 - Receive wake up method"]
#[inline (always)] pub fn rwu (& mut self) -> RwuW < '_ , CcrSpec > { RwuW :: new (self , 12) }
#[doc = "Bit 13 - Wake up method"]
#[inline (always)] pub fn wake (& mut self) -> WakeW < '_ , CcrSpec > { WakeW :: new (self , 13) } }
#[doc = "common control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ccr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ccr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CcrSpec ; impl crate :: RegisterSpec for CcrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`ccr::R`](R) reader structure"] impl crate :: Readable for CcrSpec { }
#[doc = "`write(|w| ..)` method takes [`ccr::W`](W) writer structure"] impl crate :: Writable for CcrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CCR to value 0x30"] impl crate :: Resettable for CcrSpec { const RESET_VALUE : u32 = 0x30 ; } }
#[doc = "BRR (rw) register accessor: Baud rate register\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@brr`] module"]
#[doc (alias = "BRR")] pub type Brr = crate :: Reg < brr :: BrrSpec > ;
#[doc = "Baud rate register"] pub mod brr {
#[doc = "Register `BRR` reader"] pub type R = crate :: R < BrrSpec > ;
#[doc = "Register `BRR` writer"] pub type W = crate :: W < BrrSpec > ;
#[doc = "Field `DIV_MANTISSA` reader - Mantissa part of UARTDIV"] pub type DivMantissaR = crate :: FieldReader < u16 > ;
#[doc = "Field `DIV_MANTISSA` writer - Mantissa part of UARTDIV"] pub type DivMantissaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - Mantissa part of UARTDIV"]
#[inline (always)] pub fn div_mantissa (& self) -> DivMantissaR { DivMantissaR :: new ((self . bits & 0xffff) as u16) } } impl W {
#[doc = "Bits 0:15 - Mantissa part of UARTDIV"]
#[inline (always)] pub fn div_mantissa (& mut self) -> DivMantissaW < '_ , BrrSpec > { DivMantissaW :: new (self , 0) } }
#[doc = "Baud rate register\n\nYou can [`read`](crate::Reg::read) this register and get [`brr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`brr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BrrSpec ; impl crate :: RegisterSpec for BrrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`brr::R`](R) reader structure"] impl crate :: Readable for BrrSpec { }
#[doc = "`write(|w| ..)` method takes [`brr::W`](W) writer structure"] impl crate :: Writable for BrrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BRR to value 0x01"] impl crate :: Resettable for BrrSpec { const RESET_VALUE : u32 = 0x01 ; } }
#[doc = "FRA (rw) register accessor: Fractional baud rate register\n\nYou can [`read`](crate::Reg::read) this register and get [`fra::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fra::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fra`] module"]
#[doc (alias = "FRA")] pub type Fra = crate :: Reg < fra :: FraSpec > ;
#[doc = "Fractional baud rate register"] pub mod fra {
#[doc = "Register `FRA` reader"] pub type R = crate :: R < FraSpec > ;
#[doc = "Register `FRA` writer"] pub type W = crate :: W < FraSpec > ;
#[doc = "Field `DIV_Fraction` reader - Fractional part of UARTDIV"] pub type DivFractionR = crate :: FieldReader ;
#[doc = "Field `DIV_Fraction` writer - Fractional part of UARTDIV"] pub type DivFractionW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - Fractional part of UARTDIV"]
#[inline (always)] pub fn div_fraction (& self) -> DivFractionR { DivFractionR :: new ((self . bits & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - Fractional part of UARTDIV"]
#[inline (always)] pub fn div_fraction (& mut self) -> DivFractionW < '_ , FraSpec > { DivFractionW :: new (self , 0) } }
#[doc = "Fractional baud rate register\n\nYou can [`read`](crate::Reg::read) this register and get [`fra::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fra::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FraSpec ; impl crate :: RegisterSpec for FraSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`fra::R`](R) reader structure"] impl crate :: Readable for FraSpec { }
#[doc = "`write(|w| ..)` method takes [`fra::W`](W) writer structure"] impl crate :: Writable for FraSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FRA to value 0"] impl crate :: Resettable for FraSpec { } }
#[doc = "RXADDR (rw) register accessor: RXADDR\n\nYou can [`read`](crate::Reg::read) this register and get [`rxaddr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxaddr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxaddr`] module"]
#[doc (alias = "RXADDR")] pub type Rxaddr = crate :: Reg < rxaddr :: RxaddrSpec > ;
#[doc = "RXADDR"] pub mod rxaddr {
#[doc = "Register `RXADDR` reader"] pub type R = crate :: R < RxaddrSpec > ;
#[doc = "Register `RXADDR` writer"] pub type W = crate :: W < RxaddrSpec > ;
#[doc = "Field `RXADDR` reader - Synchronous frame match address"] pub type RxaddrR = crate :: FieldReader ;
#[doc = "Field `RXADDR` writer - Synchronous frame match address"] pub type RxaddrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Synchronous frame match address"]
#[inline (always)] pub fn rxaddr (& self) -> RxaddrR { RxaddrR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Synchronous frame match address"]
#[inline (always)] pub fn rxaddr (& mut self) -> RxaddrW < '_ , RxaddrSpec > { RxaddrW :: new (self , 0) } }
#[doc = "RXADDR\n\nYou can [`read`](crate::Reg::read) this register and get [`rxaddr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxaddr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxaddrSpec ; impl crate :: RegisterSpec for RxaddrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rxaddr::R`](R) reader structure"] impl crate :: Readable for RxaddrSpec { }
#[doc = "`write(|w| ..)` method takes [`rxaddr::W`](W) writer structure"] impl crate :: Writable for RxaddrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RXADDR to value 0"] impl crate :: Resettable for RxaddrSpec { } }
#[doc = "RXMASK (rw) register accessor: RXMASK\n\nYou can [`read`](crate::Reg::read) this register and get [`rxmask::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxmask::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxmask`] module"]
#[doc (alias = "RXMASK")] pub type Rxmask = crate :: Reg < rxmask :: RxmaskSpec > ;
#[doc = "RXMASK"] pub mod rxmask {
#[doc = "Register `RXMASK` reader"] pub type R = crate :: R < RxmaskSpec > ;
#[doc = "Register `RXMASK` writer"] pub type W = crate :: W < RxmaskSpec > ;
#[doc = "Field `RXMASK` reader - Synchronous frame match address mask"] pub type RxmaskR = crate :: FieldReader ;
#[doc = "Field `RXMASK` writer - Synchronous frame match address mask"] pub type RxmaskW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - Synchronous frame match address mask"]
#[inline (always)] pub fn rxmask (& self) -> RxmaskR { RxmaskR :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - Synchronous frame match address mask"]
#[inline (always)] pub fn rxmask (& mut self) -> RxmaskW < '_ , RxmaskSpec > { RxmaskW :: new (self , 0) } }
#[doc = "RXMASK\n\nYou can [`read`](crate::Reg::read) this register and get [`rxmask::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rxmask::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RxmaskSpec ; impl crate :: RegisterSpec for RxmaskSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`rxmask::R`](R) reader structure"] impl crate :: Readable for RxmaskSpec { }
#[doc = "`write(|w| ..)` method takes [`rxmask::W`](W) writer structure"] impl crate :: Writable for RxmaskSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RXMASK to value 0"] impl crate :: Resettable for RxmaskSpec { } }
#[doc = "SCR (rw) register accessor: SCR\n\nYou can [`read`](crate::Reg::read) this register and get [`scr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@scr`] module"]
#[doc (alias = "SCR")] pub type Scr = crate :: Reg < scr :: ScrSpec > ;
#[doc = "SCR"] pub mod scr {
#[doc = "Register `SCR` reader"] pub type R = crate :: R < ScrSpec > ;
#[doc = "Register `SCR` writer"] pub type W = crate :: W < ScrSpec > ;
#[doc = "Field `SCEN` reader - ISO7816 enable control bit"] pub type ScenR = crate :: BitReader ;
#[doc = "Field `SCEN` writer - ISO7816 enable control bit"] pub type ScenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SCAEN` reader - ISO7816 check auto-response bit"] pub type ScaenR = crate :: BitReader ;
#[doc = "Field `SCAEN` writer - ISO7816 check auto-response bit"] pub type ScaenW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NACK` reader - Master receive frame answer bit"] pub type NackR = crate :: BitReader ;
#[doc = "Field `NACK` writer - Master receive frame answer bit"] pub type NackW < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SCFCNT` reader - ISO7816 protection counter bit"] pub type ScfcntR = crate :: FieldReader ;
#[doc = "Field `SCFCNT` writer - ISO7816 protection counter bit"] pub type ScfcntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `HDSEL` reader - Single-wire half-duplex mode selection bit"] pub type HdselR = crate :: BitReader ;
#[doc = "Field `HDSEL` writer - Single-wire half-duplex mode selection bit"] pub type HdselW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - ISO7816 enable control bit"]
#[inline (always)] pub fn scen (& self) -> ScenR { ScenR :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - ISO7816 check auto-response bit"]
#[inline (always)] pub fn scaen (& self) -> ScaenR { ScaenR :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - Master receive frame answer bit"]
#[inline (always)] pub fn nack (& self) -> NackR { NackR :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 4:11 - ISO7816 protection counter bit"]
#[inline (always)] pub fn scfcnt (& self) -> ScfcntR { ScfcntR :: new (((self . bits >> 4) & 0xff) as u8) }
#[doc = "Bit 12 - Single-wire half-duplex mode selection bit"]
#[inline (always)] pub fn hdsel (& self) -> HdselR { HdselR :: new (((self . bits >> 12) & 1) != 0) } } impl W {
#[doc = "Bit 0 - ISO7816 enable control bit"]
#[inline (always)] pub fn scen (& mut self) -> ScenW < '_ , ScrSpec > { ScenW :: new (self , 0) }
#[doc = "Bit 1 - ISO7816 check auto-response bit"]
#[inline (always)] pub fn scaen (& mut self) -> ScaenW < '_ , ScrSpec > { ScaenW :: new (self , 1) }
#[doc = "Bit 2 - Master receive frame answer bit"]
#[inline (always)] pub fn nack (& mut self) -> NackW < '_ , ScrSpec > { NackW :: new (self , 2) }
#[doc = "Bits 4:11 - ISO7816 protection counter bit"]
#[inline (always)] pub fn scfcnt (& mut self) -> ScfcntW < '_ , ScrSpec > { ScfcntW :: new (self , 4) }
#[doc = "Bit 12 - Single-wire half-duplex mode selection bit"]
#[inline (always)] pub fn hdsel (& mut self) -> HdselW < '_ , ScrSpec > { HdselW :: new (self , 12) } }
#[doc = "SCR\n\nYou can [`read`](crate::Reg::read) this register and get [`scr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`scr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ScrSpec ; impl crate :: RegisterSpec for ScrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`scr::R`](R) reader structure"] impl crate :: Readable for ScrSpec { }
#[doc = "`write(|w| ..)` method takes [`scr::W`](W) writer structure"] impl crate :: Writable for ScrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SCR to value 0"] impl crate :: Resettable for ScrSpec { } } }
#[doc = "Universal asynchronous receiver transmitter"] pub type Uart2 = crate :: Periph < uart1 :: RegisterBlock , 0x4000_4400 > ; impl core :: fmt :: Debug for Uart2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart2") . finish () } }
#[doc = "Universal asynchronous receiver transmitter"] pub use self :: uart1 as uart2 ;
#[doc = "Window watchdog"] pub type Wwdg = crate :: Periph < wwdg :: RegisterBlock , 0x4000_2c00 > ; impl core :: fmt :: Debug for Wwdg { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Wwdg") . finish () } }
#[doc = "Window watchdog"] pub mod wwdg {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { cr : Cr , cfgr : Cfgr , sr : Sr , } impl RegisterBlock {
#[doc = "0x00 - Control register"]
#[inline (always)] pub const fn cr (& self) -> & Cr { & self . cr }
#[doc = "0x04 - Configuration register"]
#[inline (always)] pub const fn cfgr (& self) -> & Cfgr { & self . cfgr }
#[doc = "0x08 - Status register"]
#[inline (always)] pub const fn sr (& self) -> & Sr { & self . sr } }
#[doc = "CR (rw) register accessor: Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`] module"]
#[doc (alias = "CR")] pub type Cr = crate :: Reg < cr :: CrSpec > ;
#[doc = "Control register"] pub mod cr {
#[doc = "Register `CR` reader"] pub type R = crate :: R < CrSpec > ;
#[doc = "Register `CR` writer"] pub type W = crate :: W < CrSpec > ;
#[doc = "Field `T` reader - 7-bit counter"] pub type TR = crate :: FieldReader ;
#[doc = "Field `T` writer - 7-bit counter"] pub type TW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `WDGA` reader - Activation bit"] pub type WdgaR = crate :: BitReader ;
#[doc = "Field `WDGA` writer - Activation bit"] pub type WdgaW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - 7-bit counter"]
#[inline (always)] pub fn t (& self) -> TR { TR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bit 7 - Activation bit"]
#[inline (always)] pub fn wdga (& self) -> WdgaR { WdgaR :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - 7-bit counter"]
#[inline (always)] pub fn t (& mut self) -> TW < '_ , CrSpec > { TW :: new (self , 0) }
#[doc = "Bit 7 - Activation bit"]
#[inline (always)] pub fn wdga (& mut self) -> WdgaW < '_ , CrSpec > { WdgaW :: new (self , 7) } }
#[doc = "Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cr::R`](R) reader structure"] impl crate :: Readable for CrSpec { }
#[doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"] impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CR to value 0x7f"] impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0x7f ; } }
#[doc = "CFGR (rw) register accessor: Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
#[doc (alias = "CFGR")] pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ;
#[doc = "Configuration register"] pub mod cfgr {
#[doc = "Register `CFGR` reader"] pub type R = crate :: R < CfgrSpec > ;
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CfgrSpec > ;
#[doc = "Field `WINDOW` reader - 7-bit window value"] pub type WindowR = crate :: FieldReader ;
#[doc = "Field `WINDOW` writer - 7-bit window value"] pub type WindowW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `WDGTB` reader - Timer base"] pub type WdgtbR = crate :: FieldReader ;
#[doc = "Field `WDGTB` writer - Timer base"] pub type WdgtbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `EWI` reader - Early wakeup interrupt"] pub type EwiR = crate :: BitReader ;
#[doc = "Field `EWI` writer - Early wakeup interrupt"] pub type EwiW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - 7-bit window value"]
#[inline (always)] pub fn window (& self) -> WindowR { WindowR :: new ((self . bits & 0x7f) as u8) }
#[doc = "Bits 7:8 - Timer base"]
#[inline (always)] pub fn wdgtb (& self) -> WdgtbR { WdgtbR :: new (((self . bits >> 7) & 3) as u8) }
#[doc = "Bit 9 - Early wakeup interrupt"]
#[inline (always)] pub fn ewi (& self) -> EwiR { EwiR :: new (((self . bits >> 9) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - 7-bit window value"]
#[inline (always)] pub fn window (& mut self) -> WindowW < '_ , CfgrSpec > { WindowW :: new (self , 0) }
#[doc = "Bits 7:8 - Timer base"]
#[inline (always)] pub fn wdgtb (& mut self) -> WdgtbW < '_ , CfgrSpec > { WdgtbW :: new (self , 7) }
#[doc = "Bit 9 - Early wakeup interrupt"]
#[inline (always)] pub fn ewi (& mut self) -> EwiW < '_ , CfgrSpec > { EwiW :: new (self , 9) } }
#[doc = "Configuration register\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`cfgr::R`](R) reader structure"] impl crate :: Readable for CfgrSpec { }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0x7f"] impl crate :: Resettable for CfgrSpec { const RESET_VALUE : u32 = 0x7f ; } }
#[doc = "SR (r) register accessor: Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"]
#[doc (alias = "SR")] pub type Sr = crate :: Reg < sr :: SrSpec > ;
#[doc = "Status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SrSpec > ;
#[doc = "Field `EWIF` reader - Early wakeup interrupt flag"] pub type EwifR = crate :: BitReader ; impl R {
#[doc = "Bit 0 - Early wakeup interrupt flag"]
#[inline (always)] pub fn ewif (& self) -> EwifR { EwifR :: new ((self . bits & 1) != 0) } }
#[doc = "Status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SrSpec ; impl crate :: RegisterSpec for SrSpec { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SrSpec { }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SrSpec { } } }
#[no_mangle] static mut DEVICE_PERIPHERALS : bool = false ;
#[doc = r" All the peripherals."]
#[allow (non_snake_case)] pub struct Peripherals {
#[doc = "ADC"] pub adc : Adc ,
#[doc = "COMP"] pub comp : Comp ,
#[doc = "CRC"] pub crc : Crc ,
#[doc = "DBG"] pub dbg : Dbg ,
#[doc = "DEVICE"] pub device : Device ,
#[doc = "DIV"] pub div : Div ,
#[doc = "DMA1"] pub dma1 : Dma1 ,
#[doc = "EXTI"] pub exti : Exti ,
#[doc = "FLASH"] pub flash : Flash ,
#[doc = "GPIOA"] pub gpioa : Gpioa ,
#[doc = "GPIOB"] pub gpiob : Gpiob ,
#[doc = "GPIOC"] pub gpioc : Gpioc ,
#[doc = "GPIOD"] pub gpiod : Gpiod ,
#[doc = "I2C1"] pub i2c1 : I2c1 ,
#[doc = "IWDG"] pub iwdg : Iwdg ,
#[doc = "PWM"] pub pwm : Pwm ,
#[doc = "PWR"] pub pwr : Pwr ,
#[doc = "RCC"] pub rcc : Rcc ,
#[doc = "SPI1"] pub spi1 : Spi1 ,
#[doc = "SPI2"] pub spi2 : Spi2 ,
#[doc = "TIM1"] pub tim1 : Tim1 ,
#[doc = "TIM2"] pub tim2 : Tim2 ,
#[doc = "TIM3"] pub tim3 : Tim3 ,
#[doc = "TIM14"] pub tim14 : Tim14 ,
#[doc = "TIM16"] pub tim16 : Tim16 ,
#[doc = "TIM17"] pub tim17 : Tim17 ,
#[doc = "UART1"] pub uart1 : Uart1 ,
#[doc = "UART2"] pub uart2 : Uart2 ,
#[doc = "WWDG"] pub wwdg : Wwdg , } impl Peripherals {
#[doc = r" Returns all the peripherals *once*."]
#[cfg (feature = "critical-section")]
#[inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) }
#[doc = r" Unchecked version of `Peripherals::take`."]
#[doc = r""]
#[doc = r" # Safety"]
#[doc = r""]
#[doc = r" Each of the returned peripherals must be used at most once."]
#[inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { adc : Adc :: steal () , comp : Comp :: steal () , crc : Crc :: steal () , dbg : Dbg :: steal () , device : Device :: steal () , div : Div :: steal () , dma1 : Dma1 :: steal () , exti : Exti :: steal () , flash : Flash :: steal () , gpioa : Gpioa :: steal () , gpiob : Gpiob :: steal () , gpioc : Gpioc :: steal () , gpiod : Gpiod :: steal () , i2c1 : I2c1 :: steal () , iwdg : Iwdg :: steal () , pwm : Pwm :: steal () , pwr : Pwr :: steal () , rcc : Rcc :: steal () , spi1 : Spi1 :: steal () , spi2 : Spi2 :: steal () , tim1 : Tim1 :: steal () , tim2 : Tim2 :: steal () , tim3 : Tim3 :: steal () , tim14 : Tim14 :: steal () , tim16 : Tim16 :: steal () , tim17 : Tim17 :: steal () , uart1 : Uart1 :: steal () , uart2 : Uart2 :: steal () , wwdg : Wwdg :: steal () , } } }